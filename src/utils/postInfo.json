{
  "markdownCount": 121,
  "markdownList": [
    {
      "link": "技术笔记/前端/div内元素居中.md",
      "title": "div内元素居中",
      "abstract": "![这里写图片描述](https://raw.githubusercontent.com/dellevin/BlogImgs/main/picGoUpload/SouthEast.webp)\n\n```html\n<!DOCTYPE html>\n<html>\n\t<head>\n\t\t<meta charset=\"UTF-8\">\n\t\t<meta name=\"viewport\" content=\"initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n\t\t<title>flex</title>\n\t\t<style>\n\t\t\t.container{\n\t\t\t\twidth: 100%;\n\t\t\t\theight: 350px;\n\t\t\t\tbackground-color: aqua;\n\t\t\t\tdisplay: flex;/*设为 Flex 布局以后，子元素的float、clear和vertical-align属性将失效*/\n\t\t\t\tdisplay: -webkit-flex; /* Safari */\n\t\t\t\tflex-direction: column;/*容器内项目的排列方向(默认横向排列 row)*/\n\t\t\t\tflex-wrap: nowrap;/*容器内项目换行方式*/\n\t\t\t\tjustify-content: center;/*项目在主轴上的对齐方式*/\n\t\t\t\talign-items: center;/*项目在交叉轴上如何对齐*/\n\t\t\t\talign-content: center;/*定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用*/\n\t\t\t}\n\t\t\t.item{\n\t\t\t\twidth: 80px;\n\t\t\t\theight: 50px;\n\t\t\t\tmargin: 5px;\n\t\t\t}\n\t\t</style>\n\t</head>\n\t<body>\n\t\t<div class=\"container\">\n\t\t\t<div class=\"item\" style=\"background-color: antiquewhite;\"></div>\n\t\t\t<div class=\"item\" style=\"background-color: burlywood;\"></div>\n\t\t\t<div class=\"item\" style=\"background-color: cornflowerblue;\"></div>\n\t\t</div>\n\t</body>\n</html>\n```",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2024-10-28 13:38:56",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 73,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/uni-app微信小程序属性为0.md",
      "title": "uni-app微信小程序属性为0",
      "abstract": "前几日在封装一个组件的时候，接收数据的时候遇到一个属性等于0，但是，前端死活不显示\r\n\r\n![12a45f4c84a9207a4affd2e5c8eb0de](./assets/uni-app%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E4%B8%BA0/12a45f4c84a9207a4affd2e5c8eb0de.png)\r\n\r\n这里是有值的，但\r\n\r\n![cad35a376e87b61ad1fc14a11ed0f73](./assets/uni-app%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E4%B8%BA0/cad35a376e87b61ad1fc14a11ed0f73.png)\r\n\r\n到了前端就没有了，卧槽，太神奇了是不是。打印一下看看\r\n\r\n![894db17d9f789235f50d744953c9448](./assets/uni-app%E5%BE%AE%E4%BF%A1%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B1%9E%E6%80%A7%E4%B8%BA0/894db17d9f789235f50d744953c9448.png)\r\n\r\n打印出来传入值竟然是undefined而不是0，一定是闹鬼了。。。\r\n\r\n最后再不断定位错误的时候，发现是这里的毛病\r\n\r\n```vue\r\npost: item.post || '', // 添加 post 属性，默认值为空字符串\r\n```\r\n\r\n原因是当数值为0的时候自己就默认是false\r\n\r\n0在布尔上下文中被认为是假值，因此 `item.post||‘’`  会在 `item.post ` 为 0 时返回空字符串。所以说为了保留0，需要改成\r\n\r\n```vue\r\n item.post !== undefined ? item.post : ''\r\n```\r\n\r\n来确保仅在 `item.post` 是 `undefined` 时返回空字符串。\r\n\r\n下面贴一下源代码\r\n\r\n```vue\r\n<template>\r\n\t<view>\r\n\t\t<!-- 绑定个人信息 -->\r\n\t\t<u-popup :show=\"localBindCompShow\" @close=\"onClickOverlayClose\" @open=\"localBindCompShow =true\" mode=\"center\"\r\n\t\t\tround=\"20\" :closeOnClickOverlay=\"true\">\r\n\t\t\t<view class=\"bindCompCard\">\r\n\r\n\t\t\t\t<view class=\"header-container\">\r\n\t\t\t\t\t<view class='header-button'>\r\n\t\t\t\t\t\t<u-button type=\"info\" size=\"5\" icon=\"close\" @click=\"onClickOverlayClose\" :plain=\"true\"\r\n\t\t\t\t\t\t\t:hairline=\"true\"></u-button>\r\n\t\t\t\t\t</view>\r\n\r\n\t\t\t\t\t<view class=\"header-text\">绑定企业信息</view>\r\n\t\t\t\t\t<u-tabs :list=\"bindCompTabList\" @click=\"selectTab\" class=\"tabs\"></u-tabs>\r\n\t\t\t\t</view>\r\n\r\n\t\t\t\t<view v-if=\"!bindCompNewShow\">\r\n\t\t\t\t\t<view class=\"supplier-container\">\r\n\t\t\t\t\t\t<view v-for=\"(item, index) in itemsToDisplay\" :key=\"index\" class=\"supplier-card\">\r\n\t\t\t\t\t\t\t<view class=\"supplier-details\">\r\n\t\t\t\t\t\t\t\t<view class=\"company-name\">{{ item.companyName }}</view>\r\n\t\t\t\t\t\t\t\t<view class=\"supplier-name\">政采账号：{{ item.supplierAccessName }}</view>\r\n\t\t\t\t\t\t\t</view>\r\n\t\t\t\t\t\t\t<view class=\"bind-button\">\r\n\r\n\t\t\t\t\t\t\t\t<view v-if=\"!item.isShow\">\r\n\t\t\t\t\t\t\t\t\t<view class=\"post-select\">\r\n\t\t\t\t\t\t\t\t\t\t{{ getPostText(item.post) }}\r\n\t\t\t\t\t\t\t\t\t</view>\r\n\t\t\t\t\t\t\t\t\t<button size=\"default\" type=\"default\"\r\n\t\t\t\t\t\t\t\t\t\tstyle=\"margin-top: 20rpx;color:#ffffff;background-color:#189f33;border-color:#ffffff;border-radius: 40rpx;height: 60rpx;display: flex;align-items: center;justify-content: center;\">已绑定</button>\r\n\t\t\t\t\t\t\t\t</view>\r\n\r\n\r\n\t\t\t\t\t\t\t\t<view v-if=\"item.isShow\">\r\n\t\t\t\t\t\t\t\t\t<view class=\"post-select\" v-if=\"item.isShow\">\r\n\t\t\t\t\t\t\t\t\t\t<uni-data-select v-model=\"item.post\" :localdata=\"postList\"\r\n\t\t\t\t\t\t\t\t\t\t\tplaceholder=\"选择职位\"></uni-data-select>\r\n\t\t\t\t\t\t\t\t\t</view>\r\n\t\t\t\t\t\t\t\t\t<button size=\"default\" type=\"default\" @click=\"submitBindCompCard(item)\"\r\n\t\t\t\t\t\t\t\t\t\tstyle=\"margin-top: 20rpx;color:#ffffff;background-color:#4874cb;border-color:#ffffff;border-radius: 40rpx;height: 60rpx;display: flex;align-items: center;justify-content: center;\">提交绑定</button>\r\n\t\t\t\t\t\t\t\t</view>\r\n\t\t\t\t\t\t\t</view>\r\n\t\t\t\t\t\t</view>\r\n\t\t\t\t\t</view>\r\n\t\t\t\t</view>\r\n\r\n\t\t\t\t<view v-if=\"bindCompNewShow\">\r\n\t\t\t\t\t<u--form labelPosition=\"left\" :model=\"formBindComp\">\r\n\t\t\t\t\t\t<u-form-item label=\"政采网账号\" prop=\"formBindComp.supplierAccessName\" borderBottom labelWidth='200'>\r\n\t\t\t\t\t\t\t<u--input v-model=\"formBindComp.supplierAccessName\" border=\"none\"></u--input>\r\n\t\t\t\t\t\t</u-form-item>\r\n\t\t\t\t\t\t<u-form-item label=\"职位\" prop=\"formBindComp.post\" borderBottom labelWidth='200'>\r\n\t\t\t\t\t\t\t<uni-data-select v-model=\"formBindComp.post\" :localdata=\"postList\"\r\n\t\t\t\t\t\t\t\tplaceholder=\"选择职位\"></uni-data-select>\r\n\t\t\t\t\t\t</u-form-item>\r\n\t\t\t\t\t</u--form>\r\n\r\n\t\t\t\t\t<!-- <u-button type=\"success\">提交</u-button> -->\r\n\t\t\t\t\t<button size=\"default\" type=\"default\" @click=\"submitBindComp\"\r\n\t\t\t\t\t\tstyle=\"margin-top: 40rpx;color:#ffffff;background-color:#4874cb;border-color:#ffffff;border-radius: 40rpx;height: 60rpx;display: flex;align-items: center;justify-content: center;\">提交绑定</button>\r\n\t\t\t\t</view>\r\n\r\n\t\t\t</view>\r\n\t\t</u-popup>\r\n\t</view>\r\n</template>\r\n\r\n<script>\r\n\timport {\r\n\t\tmapState,\r\n\t\tmapMutations\r\n\t} from 'vuex';\r\n\timport {\r\n\t\tgetFieldList,\r\n\t\tpostBindEnterprise,\r\n\t\tgetUserBindComp,\r\n\t\tgetUserHaveBindComp,\r\n\t} from \"@/api/user.js\";\r\n\texport default {\r\n\t\tname: 'BindComp',\r\n\t\tprops: {\r\n\t\t\tbindCompShow: {\r\n\t\t\t\ttype: Boolean,\r\n\t\t\t\tdefault: true\r\n\t\t\t},\r\n\t\t\tuserId: {\r\n\t\t\t\ttype: String,\r\n\t\t\t},\r\n\t\t\titemList: {\r\n\t\t\t\ttype: Array,\r\n\t\t\t\tdefault: () => []\r\n\t\t\t}\r\n\t\t},\r\n\t\tcomputed: {\r\n\t\t\t...mapState(\"user\", [\"token\", \"tokenExpire\", \"userInfo\"]),\r\n\t\t\tlocalBindCompShow: {\r\n\t\t\t\tget() {\r\n\t\t\t\t\treturn this.bindCompShow;\r\n\t\t\t\t},\r\n\t\t\t\tset(val) {\r\n\t\t\t\t\tthis.$emit('update:bindCompShow', val)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\titemsToDisplay() {\r\n\t\t\t\tlet list = this.itemList.length > 0 ? this.itemList : this.supplierList;\r\n\t\t\t\t// 处理 list，添加 post 和 isShow 属性\r\n\t\t\t\tlet processedList = list.map(item => ({\r\n\t\t\t\t    ...item,\r\n\t\t\t\t    post: item.post !== undefined ? item.post : '', // 添加 post 属性，保留原值或默认值为空字符串\r\n\t\t\t\t    isShow: item.isShow !== undefined ? item.isShow : true // 添加 isShow 属性，默认值为 true\r\n\t\t\t\t}));\r\n\t\t\t\treturn processedList;\t\t\r\n\t\t\t}\r\n\t\t},\r\n\t\tdata() {\r\n\t\t\treturn {\r\n\t\t\t\tsupplierList: [],\r\n\t\t\t\tbindCompNewShow: false,\r\n\t\t\t\tbindCompTabList: [{\r\n\t\t\t\t\t\tname: '政采企业信息绑定',\r\n\t\t\t\t\t},\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tname: '绑定其他企业',\r\n\t\t\t\t\t}\r\n\t\t\t\t],\r\n\t\t\t\tpostList: [],\r\n\t\t\t\tformBindComp: {\r\n\t\t\t\t\tsupplierAccessName: '',\r\n\t\t\t\t\tpost: '',\r\n\t\t\t\t\tuserId: '',\r\n\t\t\t\t}\r\n\t\t\t};\r\n\t\t},\r\n\t\tmounted() {\r\n\t\t\tthis.fieldListGet();\r\n\t\t\tif (this.userInfo.id != undefined) {\r\n\t\t\t\tthis.userBindCompGet();\r\n\t\t\t}\r\n\t\t},\r\n\t\tcreated() {\r\n\t\t\t\r\n\t\t},\r\n\t\tmethods: {\r\n\t\t\t...mapMutations(\"user\", [\"setUserInfo\"]),\r\n\t\t\tasync submitBindComp() {\r\n\t\t\t\tthis.formBindComp.userId = this.userId\r\n\t\t\t\tif (!this.formBindComp.userId) {\r\n\t\t\t\t\tthis.formBindComp.userId = this.userInfo.id\r\n\t\t\t\t}\r\n\r\n\t\t\t\tif (this.formBindComp.userId == \"\") {\r\n\t\t\t\t\tuni.$u.toast('绑定失败，请尝试重新登陆后绑定！');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.formBindComp.supplierAccessName === \"\") {\r\n\t\t\t\t\tuni.$u.toast('政采网账号不能为空！');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (this.formBindComp.post === \"\") {\r\n\t\t\t\t\tuni.$u.toast('职位信息不能为空！');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcode,\r\n\t\t\t\t\tmsg,\r\n\t\t\t\t\tdata\r\n\t\t\t\t} = await postBindEnterprise(this.formBindComp);\r\n\r\n\t\t\t\tif (code === 0) {\r\n\t\t\t\t\t// console.log(data)\r\n\t\t\t\t\tuni.$u.toast('绑定企业成功！');\r\n\t\t\t\t\tsetTimeout(() => {\r\n\t\t\t\t\t\tthis.$emit('close-popup');\r\n\t\t\t\t\t\tuni.reLaunch({\r\n\t\t\t\t\t\t\turl: '/pages/index/index'\r\n\t\t\t\t\t\t});\r\n\t\t\t\t\t}, 1000);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\tasync submitBindCompCard(item) {\r\n\t\t\t\tif (item.post === undefined || item.post === \"\") {\r\n\t\t\t\t\tuni.$u.toast('企业职位不能为空！');\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tlet userID = this.userId;\r\n\t\t\t\tif (!userID) {\r\n\t\t\t\t\tuserID = this.userInfo.id\r\n\t\t\t\t}\r\n\r\n\t\t\t\tconst params = {\r\n\t\t\t\t\tsupplierAccessName: item.supplierAccessName,\r\n\t\t\t\t\tpost: item.post,\r\n\t\t\t\t\tuserId: userID,\r\n\t\t\t\t}\r\n\t\t\t\tconsole.log(params)\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcode,\r\n\t\t\t\t\tmsg,\r\n\t\t\t\t\tdata\r\n\t\t\t\t} = await postBindEnterprise(params);\r\n\t\t\t\tif (code === 0) {\r\n\t\t\t\t\t// console.log(data)\r\n\t\t\t\t\t// 更新 item 的 isShow 属性\r\n\t\t\t\t\tthis.$set(item, 'isShow', false);\r\n\t\t\t\t\tuni.$u.toast('绑定' + item.companyName + '成功！');\r\n\t\t\t\t\t// 更新绑定企业\r\n\t\t\t\t\tthis.userBindCompGet();\r\n\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tonClickOverlayClose() {\r\n\t\t\t\tthis.$emit('close-popup');\r\n\t\t\t},\r\n\t\t\t//获取用户下面的政采企业信息\r\n\t\t\tasync userBindCompGet() {\r\n\t\t\t\ttry {\r\n\t\t\t\t\t// 如果resBindComp里面包含resHaveBind的数据,那么就设置该企业已经绑定好了\r\n\t\t\t\t\tconst resHaveBind = await getUserHaveBindComp();\r\n\t\t\t\t\tconst resBindComp = await getUserBindComp();\r\n\t\t\t\t\tif (resHaveBind.code === 0 && resBindComp.code === 0) {\r\n\r\n\t\t\t\t\t\tconst haveBindMap = new Map();\r\n\t\t\t\t\t\tresHaveBind.data.forEach(item => {\r\n\t\t\t\t\t\t\thaveBindMap.set(item.supplierId, item.post);\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tthis.supplierList = resBindComp.data.map(item => {\r\n\t\t\t\t\t\t\tif (haveBindMap.has(item.supplierId)) {\r\n\t\t\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\t\t\t...item,\r\n\t\t\t\t\t\t\t\t\tpost: haveBindMap.get(item.supplierId),\r\n\t\t\t\t\t\t\t\t\tisShow: false\r\n\t\t\t\t\t\t\t\t};\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\treturn item;\r\n\t\t\t\t\t\t});\r\n\r\n\t\t\t\t\t\tconsole.log(this.supplierList);\r\n\t\t\t\t\t}\r\n\t\t\t\t} catch (error) {\r\n\t\t\t\t\tconsole.error('获取用户绑定企业信息失败', error);\r\n\t\t\t\t}\r\n\r\n\t\t\t},\r\n\t\t\t//获取职位信息\r\n\t\t\tasync fieldListGet() {\r\n\t\t\t\tconst {\r\n\t\t\t\t\tcode,\r\n\t\t\t\t\tmsg,\r\n\t\t\t\t\tdata\r\n\t\t\t\t} = await getFieldList({\r\n\t\t\t\t\tfieldName: \"register_post\"\r\n\t\t\t\t});\r\n\t\t\t\tif (code === 0 && data) {\r\n\t\t\t\t\t// console.log(data)\r\n\t\t\t\t\tthis.postList = data.map(post => {\r\n\t\t\t\t\t\treturn {\r\n\t\t\t\t\t\t\tvalue: post.dictCode,\r\n\t\t\t\t\t\t\ttext: post.dictName\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t});\r\n\t\t\t\t\t// console.log(this.postList)\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t\tgetPostText(postValue) {\r\n\t\t\t\tconst postItem = this.postList.find(post => post.value === postValue);\r\n\t\t\t\t// console.log(postValue, postItem)\r\n\t\t\t\treturn postItem ? postItem.text : '未知职位';\r\n\t\t\t},\r\n\t\t\tselectTab(item) {\r\n\t\t\t\t// console.log(item.name)\r\n\t\t\t\tif (item.name == \"绑定其他企业\") {\r\n\t\t\t\t\tthis.bindCompNewShow = true;\r\n\t\t\t\t} else {\r\n\t\t\t\t\tthis.bindCompNewShow = false;\r\n\t\t\t\t}\r\n\t\t\t},\r\n\t\t},\r\n\t}\r\n</script>\r\n\r\n<style scoped lang=\"less\">\r\n\t.bindCompCard {\r\n\t\twidth: 650rpx;\r\n\t\tpadding: 20rpx;\r\n\t\tdisplay: flex;\r\n\t\tflex-direction: column;\r\n\t\tjustify-content: center;\r\n\t\talign-items: center;\r\n\t\ttext-align: center;\r\n\t}\r\n\r\n\t.header-container {\r\n\t\tdisplay: flex;\r\n\t\tflex-direction: column;\r\n\t\talign-items: center;\r\n\t\twidth: 100%;\r\n\t\tmargin-bottom: 20rpx;\r\n\t}\r\n\r\n\t.header-button {\r\n\t\tposition: absolute;\r\n\t\twidth: 80rpx;\r\n\t\ttop: 0;\r\n\t\tright: 5px;\r\n\t\tmargin: 10rpx;\r\n\t}\r\n\r\n\t.header-text {\r\n\t\tfont-size: 36rpx;\r\n\t\tmargin-bottom: 10rpx;\r\n\t\ttext-align: center;\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\t.tabs {\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\t// ------------------------\r\n\t.supplier-container {\r\n\t\tdisplay: flex;\r\n\t\tflex-direction: column;\r\n\t\tgap: 20rpx;\r\n\t\tpadding: 20rpx;\r\n\t\theight: 600rpx;\r\n\t\toverflow: auto;\r\n\t}\r\n\r\n\t.supplier-card {\r\n\t\tbackground: #fff;\r\n\t\tborder-radius: 10rpx;\r\n\t\tbox-shadow: 0 2rpx 5rpx rgba(0, 0, 0, 0.1);\r\n\t\tpadding: 20rpx;\r\n\t\tdisplay: flex;\r\n\t\t// flex-direction: column;\r\n\t\tgap: 10rpx;\r\n\t}\r\n\r\n\t.supplier-details {\r\n\t\tmargin-top: 27rpx;\r\n\t\twidth: 360rpx;\r\n\t\tdisplay: flex;\r\n\t\tflex-direction: column;\r\n\t\tgap: 10rpx;\r\n\t}\r\n\r\n\t.company-name,\r\n\t.supplier-name {\r\n\t\twhite-space: nowrap;\r\n\t\toverflow: hidden;\r\n\t\ttext-overflow: ellipsis;\r\n\t\twidth: 100%;\r\n\t}\r\n\r\n\t.company-name {\r\n\t\tfont-size: 32rpx;\r\n\t\tfont-weight: bold;\r\n\t\tcolor: #333;\r\n\t}\r\n\r\n\t.supplier-name {\r\n\t\tfont-size: 32rpx;\r\n\t\tcolor: #666;\r\n\t}\r\n\r\n\t.post-select {\r\n\t\tmargin-top: 10rpx;\r\n\t\twidth: 222rpx;\r\n\t}\r\n\r\n\t.bind-button {\r\n\t\tmargin-left: 10rpx;\r\n\t}\r\n</style>\r\n```\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2024-06-04 19:35:28",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 816,
        "text": "5分钟"
      }
    },
    {
      "link": "技术笔记/前端/v-if 与 v-show 的区别.md",
      "title": "v-if 与 v-show 的区别",
      "abstract": "## v-if 和 v-show 区别：\n\n在切换 v-if 块时，Vue.js 有一个局部编译/卸载过程，因为 v-if 之中的模板也可能包括数据绑定或子组件。v-if 是真实的条件渲染，因为它会确保条件块在切换当中合适地销毁与重建条件块内的事件监听器和子组件。\n\nv-if 也是惰性的：如果在初始渲染时条件为假，则什么也不做——在条件第一次变为真时才开始局部编译（编译会被缓存起来）。\n\n相比之下，v-show 简单得多——元素始终被编译并保留，只是简单地基于 CSS 切换。\n\n一般来说，v-if 有更高的切换消耗而 v-show 有更高的初始渲染消耗。因此，如果需要频繁切换 v-show 较好，如果在运行时条件不大可能改变 v-if 较好。\n\n## v-if 和 v-show 区别：\n\nv-if 是动态添加，当值为 false 时，是完全移除该元素，即 dom 树中不存在该元素。\n\nv-show 仅是隐藏 / 显示，值为 false 时，该元素依旧存在于 dom 树中。若其原有样式设置了 display: none 则会导致其无法正常显示。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-11-14 21:34:10",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 48,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/前端实现div的高度拖拽改变.md",
      "title": "前端实现div的高度拖拽改变",
      "abstract": "实现代码\r\n\r\n## html\r\n\r\n```vue\r\n        <div class=\"contactPerson_bottom_div\" id=\"fuDiv\">\r\n            <div class=\"dragDiv\" @mousedown=\"dragEagle\" >\r\n                    <el-icon><SemiSelect /></el-icon>\r\n            </div>\r\n         </div>\r\n\r\n```\r\n\r\n## script\r\n\r\n```javascript\r\ndragEagle(e) {\r\n            var targetDiv = document.getElementById('fuDiv');\r\n            //得到点击时该地图容器的宽高：\r\n            var targetDivHeight = targetDiv.offsetHeight;\r\n            var startX = e.clientX;\r\n            var startY = e.clientY;\r\n            document.onmousemove = function (e) {\r\n                e.preventDefault();\r\n                //得到鼠标拖动的宽高距离：取绝对值\r\n                var distY = Math.abs(e.clientY - startY);\r\n\r\n                //往上方拖动：\r\n                if (e.clientY < startY) {\r\n                    targetDiv.style.height = (targetDivHeight + distY) + 'px';\r\n                }\r\n\r\n                //往下方拖动：\r\n                if (e.clientX < startX && e.clientY > startY) {\r\n                    targetDiv.style.height = targetDivHeight - distY + 'px';\r\n                }\r\n\r\n                if (parseInt(targetDiv.style.height) >= 800) {\r\n                    targetDiv.style.height = 800 + 'px';\r\n                }\r\n                if (parseInt(targetDiv.style.height) <= 320) {\r\n                    targetDiv.style.height = 320 + 'px';\r\n                }\r\n            }\r\n            document.onmouseup = function () {\r\n                document.onmousemove = null;\r\n            }\r\n        },\r\n```\r\n\r\n## css\r\n\r\n```css\r\n.contactPerson_bottom_div {\r\n    position: absolute;\r\n    bottom: 0;\r\n    left: 0;\r\n    right: 0;\r\n    border-top-style: solid;\r\n    border-color: black;\r\n    background: rgb(255, 255, 255);\r\n    color: rgb(0, 0, 0);\r\n    z-index: 99;\r\n    height: 320px;\r\n    overflow-y: auto;/* 允许垂直滚动 */\r\n}\r\n.dragDiv{\r\n \theight:10px;\r\n    display: flex; \r\n    align-items: center; \r\n    justify-content: center;   \r\n}\r\n.dragDiv:hover {\r\n    /* background-color: #666; */\r\n    cursor: pointer;/* 在hover的时候，鼠标指针变成手 */\r\n}\r\n```\r\n\r\n\r\n\r\n首先针对需要设置的div添加一个id，再通过getElementById获取到目标div。\r\n\r\n然后在内部添加一个div，可以设置成自己想要的形式，做明显的标记使用。针对这个div设置操作活动@mousedown。也就是当鼠标按下去的时候调用此dragEagle方法，在此之前一定要传入对象参数e。\r\n\r\n`var targetDivHeight = targetDiv.offsetHeight;`: 这行代码获取了目标 `div` 元素的当前高度，并将其存储在 `targetDivHeight` 变量中。\r\n\r\n`var startX = e.clientX;` 和 `var startY = e.clientY;`: 这两行代码分别记录了鼠标点击位置的横坐标（X坐标）和纵坐标（Y坐标），用于后续计算鼠标拖动的距离。\r\n\r\n`document.onmousemove = function (e) { ... }`: 这是一个鼠标移动事件处理程序，当用户按住鼠标左键并移动时，会触发这个事件处理程序。在这个处理程序中，计算了鼠标拖动的距离，并根据拖动的方向来改变目标 `div` 元素的高度。\r\n\r\n- `e.preventDefault();`: 这一行代码用于防止浏览器默认的拖拽行为，确保我们自己的逻辑生效。\r\n- 通过比较鼠标当前的 `e.clientY` 和初始点击时的 `startY` 来计算垂直方向上的拖动距离 `distY`。\r\n- 接下来的条件判断分别处理向上拖动和向下拖动的情况。如果鼠标向上拖动，就增加目标 `div` 的高度，如果鼠标向下拖动，就减小目标 `div` 的高度。这样可以实现调整高度的效果。\r\n- 最后的两个条件判断用于限制目标 `div` 的最小和最大高度，以避免高度超出一定范围\r\n\r\n`document.onmouseup = function () { ... }`: 这是鼠标释放事件处理程序，在鼠标左键释放时触发。它用于清除鼠标移动事件处理程序，即当鼠标释放后停止拖动。\r\n\r\n\r\n\r\n在这之中\r\n```js\r\n                if (parseInt(targetDiv.style.height) >= 800) {\r\n                    targetDiv.style.height = 800 + 'px';\r\n                }\r\n                if (parseInt(targetDiv.style.height) <= 320) {\r\n                    targetDiv.style.height = 320 + 'px';\r\n                }\r\n```\r\n\r\n这一段是限制div拖动的最大高度和最小高度\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-11-04 12:02:45",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 258,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/前端/TypeError this.getOptions is not a function 的解决(vue,react).md",
      "title": "TypeError this.getOptions is not a function 的解决(vue,react)",
      "abstract": "卸载安装老版本的即可\n```cobol\nnpm uninstall less-loader\n\nnpm install less-loader@5.0.0\n```\n\n### 报错信息\n\nTypeError: this.getOptions is not a function 这个是在运行项目是遇到的问题\n\n![img](./assets/TypeError%20this.getOptions%20is%20not%20a%20function%20%E7%9A%84%E8%A7%A3%E5%86%B3(vue,react)/20210725131325906.png)\n\n​                                     **vue**\n\n![img](./assets/TypeError%20this.getOptions%20is%20not%20a%20function%20%E7%9A%84%E8%A7%A3%E5%86%B3(vue,react)/20210725131419470.png)                                    \t\t\t\t\t\t\t\t\t\t\t**react**\n\n\n\n这个报错是类型错误，this.getOptions 不是一个函数 。这个错误是less-loader库里的错误。\n\n主要是less-loader版本太高，不兼容this.getOptions方法。\n\n### 解决方案\n\n通过 `npm uninstall less-loader` 命令卸载原版本的 `less-loader`，然后 通过 `npm install less-loader@5.0.0` 命令下载降级版本的 `less-loader`，这个问题就可以解决了.\n\n```cobol\nnpm uninstall less-loader\n\nnpm install less-loader@5.0.0\n```\n\n或者可以删除node_modules文件夹，并且把package.json里less-loader里的版本改为5.0.0就行，然后npm install\n\n不止 less-loader 同样 scss-loader ,css-loader，style-loader都有可能出现 。\n\n![img](./assets/TypeError%20this.getOptions%20is%20not%20a%20function%20%E7%9A%84%E8%A7%A3%E5%86%B3(vue,react)/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5bS95bS955qE6LC36Zuo,size_20,color_FFFFFF,t_70,g_se,x_16.png)\n\n 只需要 看报错 具体 是什么 上图 为例 报的是css-loader .所以 卸载对应得就行。\n\n```cobol\nnpm uninstall css-loader\n\nnpm install css-loader@5.0.0\n```\n\n具体降到哪个版本 需要 看看 版本信息 比如 style-loader\n\nstyle-loader)降低 到 之前的版本 比如 2.0.0",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-11-04 11:48:39",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 86,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/vue.js 两个等号 == 和三个等号 ===的区别.md",
      "title": "vue.js 两个等号 == 和三个等号 ===的区别",
      "abstract": "`== `用于比较两者是否相等，忽略数据类型。\n\n`=== `用于更严谨的比较，值和值的数据类型都需要同时比较。\n\n```html\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0\">\n    <meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\">\n    <title>Document</title>\n</head>\n<script src=\"vue.js\" type=\"text/javascript\" charset=\"utf-8\"></script>\n<body>\n    <div id=\"app\">\n        <div v-if=\"text ==1 \">\n            1--值一样，类型不同，两个等号显示 \n        </div>\n        <div v-if=\"text ===1 \">\n            2--值一样，类型不同，三个等号不显示\n        </div>\n        <div v-if=\"text ==='1' \">\n            3--值一样，类型同，三个等号显示\n        </div>\n    </div>\n    <script type=\"text/javascript\">\n        /* text:\"1\" 这里的1是个字符串  */\n        var vm = new Vue({\n            el:\"#app\",\n            data:{\n                text:\"1\"\n            }\n        });\n    </script>\n</body>\n</html>\n```\n\n显示：\n\n```bash\n 1--值一样，类型不同，两个等号显示 \n 3--值一样，类型同，三个等号显示\n```\n\n\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 14:00:17",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 73,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/vue3无关系组件之间的方法调用.md",
      "title": "vue3无关系组件之间的方法调用",
      "abstract": "\n\n要实现在第一个页面中的方法 `onClick` 调用第二个页面中的 `updateBankToUser` 方法，我们可以使用事件总线来实现跨组件通信。在Vue 3中，我们可以使用 `mitt` 库来创建事件总线。\n\n首先，安装 `mitt` 库：\n```bash\nnpm install mitt\n```\n\n然后，我们可以创建一个全局的事件总线，并在第二个页面中将 `updateBankToUser` 方法注册为一个事件处理程序，然后在第一个页面的 `onClick` 方法中触发这个事件，从而调用第二个页面中的方法。\n\n以下是示例代码：\n\n**创建全局事件总线 bus.ts：**\n```ts\n// bus.ts\nimport mitt from 'mitt';\n\nexport const bus = mitt();\n```\n\n**第二个页面 user.vue：**\n```vue\n<template>\n  <div>\n    <!-- ...其他代码... -->\n    <el-button @click=\"updateBankToUser\">更新银行的用户</el-button>\n  </div>\n</template>\n\n<script setup>\nimport { bus } from './bus';\n\nconst updateBankToUser = async () => {\n  console.log('更新银行的用户');\n  // 在这里执行您的业务逻辑\n}\nbus.on('callUpdateBankToUser', updateBankToUser);\n</script>\n```\n\n**第一个页面 parent.vue：**\n```vue\n<template>\n  <div>\n    <el-button @click=\"onClick\">点击调用第二个页面的方法</el-button>\n  </div>\n</template>\n\n<script setup>\nimport { bus } from './bus';\n\nconst onClick = () => {\n  console.log('调用第二个页面的方法');\n  // 在这里执行您的业务逻辑\n  bus.emit('callUpdateBankToUser');\n}\n</script>\n```\n\n在这个示例中，我们在 bus.ts 中创建了一个全局事件总线 `bus`。然后在第二个页面 user.vue 中，我们将 `updateBankToUser` 方法注册为名为 'callUpdateBankToUser' 的事件处理程序。在第一个页面 parent.vue 中的 `onClick` 方法中，我们使用 `bus.emit` 触发了 'callUpdateBankToUser' 事件，从而调用了第二个页面中的 `updateBankToUser` 方法。\n\n通过这种方式，您可以在不直接引用第二个页面的情况下，实现跨组件调用其中的方法。\n\n\n\n\n\n## 什么是全局事件总线bus.ts import mitt from 'mitt'; export const bus = mitt(); 两行的作用是啥\n\n在这里，`bus.ts` 文件中的两行代码用来创建全局事件总线。全局事件总线是一个简单的事件管理器，它可以用于在应用程序中实现组件之间的通信，特别是当组件之间没有直接父子关系时。\n\n具体来说，这两行代码的作用是：\n\n1. `import mitt from 'mitt';`: 这里我们导入了 `mitt` 库，它是一个简单、小巧的 JavaScript 事件库。`mitt` 库允许我们创建事件总线，以便在应用程序的任何地方都可以访问该事件总线。\n\n2. `export const bus = mitt();`: 在这里，我们创建了一个全局的事件总线 `bus` 并将其导出。通过 `mitt()` 调用，我们创建了一个新的事件总线实例，可以用来管理事件的注册、触发和取消。\n\n总结起来，`bus.ts` 文件中的这两行代码的目的是创建一个全局的事件总线，以便在应用程序的任何地方都可以使用它进行组件之间的通信。通过这个全局事件总线，我们可以在不直接引用其他组件的情况下，实现组件之间的方法调用和数据传递。\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 14:00:05",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 164,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/vue实现新闻列表的无限滚动.md",
      "title": "vue实现新闻列表的无限滚动",
      "abstract": "这几天业务用到了这个，身为一个前端小白。。。垃圾的一批。百度的时候发现一个叫`vue-seamless-scroll`的组件，但是引入使用标签的适合前端会啥也不显示直接白花花的一大片。\n\n百度的时候发现一个大佬已经通过js模拟那个组件实现了效果，特此记录下来。因为应用场景的问题，对他的代码稍做了些更改。\n\n```vue\n<template>\n    <!-- 平台成果  -->\n    <div class=\"platform-outcomes\">\n\n        <div class=\"imgTitle\">\n            <img src=\"../assets/img/news.png\" alt=\"新闻png\">\n            <span>政策要闻</span>\n        </div>\n        <!-- 新闻展示div -->\n        <div class=\"box\">\n\n            <div class=\"scroll_parent_box\" @mouseenter=\"mEnter\" @mouseleave=\"mLeave\">\n                <div class=\"scroll_list\" :style=\"{ transform: `translate(0px,-${scrollTop}px)` }\">\n\n                    <div ref=\"scrollItemBox\">\n\n                        <div class=\"scroll_item\" v-for=\"(item, index) in newsData\" :key=\"index\">\n\n                            <div class=\"newsFont\">\n                                <img src=\"../assets/img/little_news.png\" alt=\"新闻小图标\">\n                            </div>\n\n                            <div class=\"newsMessage\">\n                                <a :href=\"item.sciUrl\" target=\"_blank\">\n                                    <p v-bind:style=\"{ fontWeight: 'bold' }\">\n                                        {{ item.content }}\n                                    </p>\n                                </a>\n                            </div>\n\n                        </div>\n\n                    </div>\n\n                    <div v-html=\"copyHtml\"></div>\n                </div>\n            </div>\n\n        </div>\n    </div>\n</template>\n\n<script>\nimport axios from 'axios'\n\n\nexport default {\n    data() {\n        return {\n            scrollTop: 0, //列表滚动高度\n            speed: 50, //滚动的速度\n            newsData: [\n            //     {\n            //     'content': '科创金融为科创企业注入金融“活水”',\n            //     'sciUrl': 'https://finance.sina.com.cn/jjxw/2023-04-15/doc-imyqknmc2885203.shtml',\n            // }, {\n            //     'content': '工商银行 坚定不移推进高质量发展 在服务中国式现代化进程中展现新担当',\n            //     'sciUrl': 'http://paper.people.com.cn/rmrb/html/2023-03/10/nw.D110000renmrb_20230310_1-12.htm',\n            // }, {\n            //     'content': '让科创企业股权“软实力”变融资“硬通货”',\n            //     'sciUrl': 'http://www.ccb.com/cn/ccbtoday/newsv3/20230414_1681445103.html',\n            // }, {\n            //     'content': '建设高质量科创板，更好促进科技、资本和产业良性循环',\n            //     'sciUrl': 'http://www.sse.com.cn/aboutus/mediacenter/hotandd/c/c_20221122_5712368.shtml',\n            // }, {\n            //     'content': '国泰君安发布服务上海科创中心建设行动方案_中国经济网——国家经济门户',\n            //     'sciUrl': 'http://finance.ce.cn/stock/gsgdbd/202305/06/t20230506_38533924.shtml.',\n            // }, {\n            //     'content': '中国人民银行营业管理部召开2023年第二季度新闻发布会',\n            //     'sciUrl': 'https://finance.sina.com.cn/money/bank/bank_yhfg/2023-04-27/doc-imyrvnht4400317.shtml',\n            // }, {\n            //     'content': '中国农业银行联合多家机构成功举办2023科创金融论坛',\n            //     'sciUrl': 'http://finance.people.com.cn/n1/2023/0426/c1004-32674304.html',\n            // }, {\n            //     'content': '中国科协启动“科创中国”金融伙伴计划- 社会综合',\n            //     'sciUrl': 'https://www.chinanews.com.cn/sh/2023/02-20/9957121.shtml',\n            // }, {\n            //     'content': '2023济南科创金融论坛举行马建堂袁亚湘作主旨演讲袁炳忠刘强致辞',\n            //     'sciUrl': 'http://jntzcjj.jinan.gov.cn/art/2023/4/15/art_88379_4775055.html',\n            // }, {\n            //     'content': '济南市政府门户网站新闻刘强会见出席2023济南科创金融论坛嘉宾',\n            //     'sciUrl': 'http://www.jinan.gov.cn/art/2023/4/14/art_22405_4947838.html',\n            // }, {\n            //     'content': '全国关注济南！科创+金融，一场盛会激涌发展“活水” ',\n            //     'sciUrl': 'https://new.qq.com/rain/a/20230415A01HXN00',\n            // }\n            ], //表示有多少个列表项\n            copyHtml: '', //复制多一份防止滚动到后面出现空白\n            msg: '',\n            outcomes: {\n                companyNum: '',\n                financingNum: '',\n                financingTotalAmount: ''\n            },\n        }\n    },\n    //同步执行的，意味着在该函数内的代码将在组件创建完成前立即执行\n    //可以在该函数下完成一些初始化的工作\n    created() {\n        this.initData();\n    },\n    mounted() {\n        // 如果列表数据是异步获取的，记得初始化在获取数据后再调用\n        this.initScroll();\n    },\n    methods: {\n        //获取政务新闻条例\n        initData() {\n            axios.get('http://localhost:8080/renren-admin/index/sciindexnews/page?limit=14&page=1').then((res) => {\n                this.newsData = res.data.data.list\n            }).catch((err) => {\n                console.log(err)\n                alert('请求出错！')\n            })\n        },\n        //以下是实现滚动的\n        initScroll() {\n            this.$nextTick(() => {\n                this.copyHtml = this.$refs.scrollItemBox.innerHTML\n                this.startScroll()\n            })\n        },\n        // 鼠标移入停止滚动\n        mEnter() {\n            clearInterval(this.timer);\n        },\n        // 鼠标移出继续滚动\n        mLeave() {\n            this.startScroll()\n        },\n        // 开始滚动\n        startScroll() {\n            //添加this指向，告诉他是自己的这个time，如果不加的话，没办法识别了\n            this.timer = setInterval(this.scroll, this.speed);\n        },\n        // 滚动处理方法\n        scroll() {\n            //用于复制上一次出现的所有数据，因为在使用axios之后滚动数据只会滚动一次，也就是说没有调用copyHtml所以退而求其次用这个\n            this.copyHtml = this.$refs.scrollItemBox.innerHTML\n\n            this.scrollTop++\n            // 获取需要滚动的盒子的高度\n            let scrollItemBox = this.$refs.scrollItemBox.offsetHeight;\n            // 当判断滚动的高度大于等于盒子高度时，从头开始滚动\n            if (this.scrollTop >= scrollItemBox) {\n                this.scrollTop = 0\n            }\n        },\n\n\n    },\n\n}\n</script>\n\n<style scoped>\n\na {\n    color: #000;\n}\n\n.newsMessage {\n    padding-left: 7%;\n}\n\n.newsFont {\n    text-align: left;\n    padding-left: 2%;\n}\n\n.scroll_parent_box {\n    width: 90%;\n    height: 100%;\n    /*边框*/\n    /* border: 1px solid #ebeef5;  */\n    overflow: hidden;\n    box-sizing: border-box;\n    padding: 0 10px;\n}\n\n.scroll_list {\n    transition: all 0ms ease-in 0s\n}\n\n.scroll_item {\n    height: 40px;\n    line-height: 40px;\n    /* text-align: center; */\n    font-size: 14px;\n}\n\n.platform-outcomes {\n    width: 1920px;\n    height: 600px;\n    background-image: url(\"../assets/img/chengguobg.jpg\");\n    background-repeat: no-repeat;\n    background-size: 100%;\n    /* background-position: center; */\n    padding-left: 300px;\n    padding-top: 80px;\n}\n\n.platform-outcomes .imgTitle {\n    padding-left: 10px;\n}\n\n.platform-outcomes .imgTitle span {\n    font-size: 25px;\n    font-weight: 700;\n    color: #313233;\n    margin-left: 10px;\n    margin-top: 15px;\n}\n\n.platform-outcomes .box {\n    padding-left: 10%;\n    /* box内的滚动条向左偏移10% */\n    width: 1200px;\n    height: 380px;\n    /* background: skyblue; */\n    background: white;\n    float: left;\n    margin-top: 35px;\n    margin-right: 10px;\n    border-top: 8px solid #d6ba83;\n    border-bottom: 8px solid #d6ba83;\n}\n\n.platform-outcomes .box ul {\n    margin-left: 80px;\n    margin-right: 80px;\n    margin-top: 25px;\n    /* background:  white; */\n}\n\n/* 背景图 3张 */\n.platform-outcomes .box .building {\n    background: url(\"../assets/img/chengguo1bg.png\") no-repeat;\n    background-position: center center;\n}\n\n.platform-outcomes .box .book {\n    background: url(\"../assets/img/chengguo2bg.png\") no-repeat;\n    background-position: center center;\n}\n\n.platform-outcomes .box .money {\n    background: url(\"../assets/img/chengguo3bg.png\") no-repeat;\n    background-position: center center;\n}\n\n\n.platform-outcomes .box ul span {\n    font-size: 30px;\n    font-weight: 500;\n    color: #cc4f4f;\n}</style>\n```\n\n再次分析一下以上代码：\n\n此处代码不做赘述，主要是用来实现页面展示的其中利用v-for实现不断地循环展示`@mouseenter`和`@mouseleave`作为监听鼠标的是否在此div上面滑入滑出\n\n```vue\n            <div class=\"scroll_parent_box\" @mouseenter=\"mEnter\" @mouseleave=\"mLeave\">\n                <div class=\"scroll_list\" :style=\"{ transform: `translate(0px,-${scrollTop}px)` }\">\n\n                    <div ref=\"scrollItemBox\">\n                        <div class=\"scroll_item\" v-for=\"(item, index) in newsData\" :key=\"index\">\n                            <div class=\"newsFont\">\n                                <img src=\"../assets/img/little_news.png\" alt=\"新闻小图标\">\n                            </div>\n                            <div class=\"newsMessage\">\n                                <a :href=\"item.sciUrl\" target=\"_blank\">\n                                    <p v-bind:style=\"{ fontWeight: 'bold' }\">\n                                        {{ item.content }}\n                                    </p>\n                                </a>\n                            </div>\n                        </div>\n                    </div>\n\n                    <div v-html=\"copyHtml\"></div>\n                </div>\n            </div>\n```\n\ncss部分在此不做解释：\n\n```css\na {\n    color: #000;\n}\n\n.newsMessage {\n    padding-left: 7%;\n}\n\n.newsFont {\n    text-align: left;\n    padding-left: 2%;\n}\n\n.scroll_parent_box {\n    width: 90%;\n    height: 100%;\n    /*边框*/\n    /* border: 1px solid #ebeef5;  */\n    overflow: hidden;\n    box-sizing: border-box;\n    padding: 0 10px;\n}\n\n.scroll_list {\n    transition: all 0ms ease-in 0s\n}\n\n.scroll_item {\n    height: 40px;\n    line-height: 40px;\n    /* text-align: center; */\n    font-size: 14px;\n}\n```\n\njavascript部分：\n\n```javascript\n\nimport axios from 'axios'\n\n\nexport default {\n    data() {\n        return {\n            scrollTop: 0, //列表滚动高度\n            speed: 50, //滚动的速度\n            newsData: [\n            //     {\n            //     'content': '科创金融为科创企业注入金融“活水”',\n            //     'sciUrl': 'https://finance.sina.com.cn/jjxw/2023-04-15/doc-imyqknmc2885203.shtml',\n            // }, {\n            //     'content': '工商银行 坚定不移推进高质量发展 在服务中国式现代化进程中展现新担当',\n            //     'sciUrl': 'http://paper.people.com.cn/rmrb/html/2023-03/10/nw.D110000renmrb_20230310_1-12.htm',\n            // }, {\n            //     'content': '让科创企业股权“软实力”变融资“硬通货”',\n            //     'sciUrl': 'http://www.ccb.com/cn/ccbtoday/newsv3/20230414_1681445103.html',\n            // }, {\n            //     'content': '建设高质量科创板，更好促进科技、资本和产业良性循环',\n            //     'sciUrl': 'http://www.sse.com.cn/aboutus/mediacenter/hotandd/c/c_20221122_5712368.shtml',\n            // }, {\n            //     'content': '国泰君安发布服务上海科创中心建设行动方案_中国经济网——国家经济门户',\n            //     'sciUrl': 'http://finance.ce.cn/stock/gsgdbd/202305/06/t20230506_38533924.shtml.',\n            // }, {\n            //     'content': '中国人民银行营业管理部召开2023年第二季度新闻发布会',\n            //     'sciUrl': 'https://finance.sina.com.cn/money/bank/bank_yhfg/2023-04-27/doc-imyrvnht4400317.shtml',\n            // }, {\n            //     'content': '中国农业银行联合多家机构成功举办2023科创金融论坛',\n            //     'sciUrl': 'http://finance.people.com.cn/n1/2023/0426/c1004-32674304.html',\n            // }, {\n            //     'content': '中国科协启动“科创中国”金融伙伴计划- 社会综合',\n            //     'sciUrl': 'https://www.chinanews.com.cn/sh/2023/02-20/9957121.shtml',\n            // }, {\n            //     'content': '2023济南科创金融论坛举行马建堂袁亚湘作主旨演讲袁炳忠刘强致辞',\n            //     'sciUrl': 'http://jntzcjj.jinan.gov.cn/art/2023/4/15/art_88379_4775055.html',\n            // }, {\n            //     'content': '济南市政府门户网站新闻刘强会见出席2023济南科创金融论坛嘉宾',\n            //     'sciUrl': 'http://www.jinan.gov.cn/art/2023/4/14/art_22405_4947838.html',\n            // }, {\n            //     'content': '全国关注济南！科创+金融，一场盛会激涌发展“活水” ',\n            //     'sciUrl': 'https://new.qq.com/rain/a/20230415A01HXN00',\n            // }\n            ], //表示有多少个列表项\n            copyHtml: '', //复制多一份防止滚动到后面出现空白\n            msg: '',\n            outcomes: {\n                companyNum: '',\n                financingNum: '',\n                financingTotalAmount: ''\n            },\n        }\n    },\n    //同步执行的，意味着在该函数内的代码将在组件创建完成前立即执行\n    //可以在该函数下完成一些初始化的工作\n    created() {\n        \n    },\n    mounted() {\n        this.initData();\n        // 如果列表数据是异步获取的，记得初始化在获取数据后再调用\n        //this.initScroll();\n    },\n    methods: {\n        //获取政务新闻条例\n        initData() {\n            axios.get('http://localhost:8080/renren-admin/index/sciindexnews/page?limit=14&page=1').then((res) => {\n                this.newsData = res.data.data.list\n                this.initScroll();\n            }).catch((err) => {\n                console.log(err)\n                alert('请求出错！')\n            })\n        },\n        //以下是实现滚动的\n        initScroll() {\n            this.$nextTick(() => {\n                this.copyHtml = this.$refs.scrollItemBox.innerHTML\n                this.startScroll()\n            })\n        },\n        // 鼠标移入停止滚动\n        mEnter() {\n            clearInterval(this.timer);\n        },\n        // 鼠标移出继续滚动\n        mLeave() {\n            this.startScroll()\n        },\n        // 开始滚动\n        startScroll() {\n            //添加this指向，告诉他是自己的这个time，如果不加的话，没办法识别了\n            this.timer = setInterval(this.scroll, this.speed);\n        },\n        // 滚动处理方法\n        scroll() {\n            //用于复制上一次出现的所有数据，因为在使用axios之后滚动数据只会滚动一次，也就是说没有调用copyHtml所以退而求其次用这个\n            this.copyHtml = this.$refs.scrollItemBox.innerHTML\n\n            this.scrollTop++\n            // 获取需要滚动的盒子的高度\n            let scrollItemBox = this.$refs.scrollItemBox.offsetHeight;\n            // 当判断滚动的高度大于等于盒子高度时，从头开始滚动\n            if (this.scrollTop >= scrollItemBox) {\n                this.scrollTop = 0\n            }\n        },\n\n\n    },\n\n}\n</script>\n```\n\n再次赘述一下以上的javascript代码，这段是最为关键的，其中data内的return不做叙述，主要功能是作为数据的初始化 `initData()`我们放在最后说。\n\n **initScroll()** 这个方法的作用就是用户初始化滚动，其中调用了`startScroll()`方法，`this.copyHtml = this.$refs.scrollItemBox.innerHTML`的作用就是复制`ref=”scrollItemBox“`这个div内的所有代码来阻止出现当先数据显示完的情况之下出现空白的情形。\n\n**mEnter()**这个方法是在鼠标进来的时候停止移动的clearInterval()就是阻塞setInterval()的方法。参考链接：http://caibaojian.com/setinterval-times.html\n\n**mLeave()**这个不多说，就是调用下面的 startScroll()方法\n\n**startScroll()**在此处的作用是调用滚动方法和设置滚动速度（滚动速度其实就是显示的时间，具体可以查看setInterval()方法）\n\n**scroll()**可以说是真正滚动方法的实现。scrollItemBox就是div的高度，初始化一个scrollTop为0让它随时间不断增加，这时候当scrollTop大于scrollItemBox也就是说显示的数据都没有了，那就重新初始化scrollTop数据让他们重新显示\n\n **initData()**这里的作用是用于初始化数据的，当数据写死的时候我们可以不用介意。但是当数据是异步请求的时候，我们就需要把初始化滚动放在数据请求之后了。也就是说是这个情况\n\n``` javascript\n        initData() {\n            axios.get('http://localhost:8080/renren-admin/index/sciindexnews/page?limit=14&page=1').then((res) => {\n                this.newsData = res.data.data.list\n                //初始化在获取数据后再调用\n                this.initScroll();\n            }).catch((err) => {\n                console.log(err)\n                alert('请求出错！')\n            })\n        },\n```\n\n同时在mounted更改\n\n```javascript\n    mounted() {\n        this.initData();\n        // 如果列表数据是异步获取的，记得初始化在获取数据后再调用\n        //this.initScroll();\n    },\n```\n\n其实这个this.initData();是可以放在created()生命周期里面的，我个人比较偏向放在created()声明周期里。\n\n普及一下这俩生命周期的区别：\n\n**created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。**\n\n**mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。**\n\n可以参考知乎这个帖子：https://zhuanlan.zhihu.com/p/479084392  \n\n**憨憨的我：**\n\n其实我一开始没有理解他的”记得初始化在获取数据后再调用“是什么意思，我还以为是初始化数据在获取数据之后初始化，我还寻思前端还能有这操作？这么神器吗？经过吾爱的大佬提示才知道，原来是，在数据初始化之后对方法的调用。。。。笨死我了\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:59:58",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 910,
        "text": "5分钟"
      }
    },
    {
      "link": "技术笔记/前端/轮询详解.md",
      "title": "轮询详解",
      "abstract": "> 即时通讯技术是实现：服务器端可以时地将数据的更新或变化反应到客户端，在Web中，由于浏览器的限制，实现即时通讯需要借助一些方法。这种限制出现的主要原因是，Web通信都是浏览器先发送请求到服务器，服务器再进行响应完成数据的现实更新。\n\n实现即时通讯主要有四种方式，它们分别是**短轮询、长轮询(comet)、长连接(SSE)、WebSocket**。\n\n> 它们大体可以分为两类\n> 　　 1. 一种是在**HTTP**基础上实现的，包括**轮询、comet和SSE**； 　　\n> 　　 2. 另一种不是在HTTP基础上实现是，即WebSocket；\n\n①[轮询](https://so.csdn.net/so/search?q=轮询&spm=1001.2101.3001.7020)\n　　短轮询是浏览器每隔一段时间向浏览器发送http请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。\n　　\n　　本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。\n\n**优点**：比较简单，易于理解。\n　\n**缺点**：需要不断的建立http连接，严重浪费了服务器端和客户端的资源。尤其是在客户端，距离来说，如果有数量级想对比较大的人同时位于基于短轮询的应用中，那么每一个用户的客户端都会疯狂的向服务器端发送http请求，而且不会间断。人数越多，服务器端压力越大，这是很不合理的。\n\n\n\n> 因此短轮询不适用于那些同时在线用户数量比较大，并且很注重性能的Web应用。\n\n```javascript\nvar xhr = new XMLHttpRequest();\n    setInterval(function(){\n        xhr.open('GET','/user');\n        xhr.onreadystatechange = function(){\n\n        };\n        xhr.send();\n    },1000)\n12345678\n```\n\n②长轮询（comet）\n\najax实现:\n　　当服务器收到客户端发来的请求后,服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制(服务器端设置)才返回。 客户端JavaScript响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。\n\n长轮询和短轮询比起来，明显减少了很多不必要的http请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。\n\n```javascript\n   function ajax(){\n        var xhr = new XMLHttpRequest();\n        xhr.open('GET','/user');\n        xhr.onreadystatechange = function(){\n              ajax();\n        };\n        xhr.send();\n    }\n12345678\n```\n\n轮询与长轮询都是基于HTTP的，两者本身存在着缺陷:轮询需要更快的处理速度；长轮询则更要求处理并发的能力;\n\n两者都是“被动型服务器”的体现:服务器不会主动推送信息，而是在客户端发送ajax请求后进行返回的响应。而理想的模型是\"在服务器端数据有了变化后，可以主动推送给客户端\",这种\"主动型\"服务器是解决这类问题的很好的方案。Web Sockets就是这样的方案。\n\n③长连接（SSE）\n　　SSE是HTML5新增的功能，全称为Server-Sent Events。它可以允许服务推送数据到客户端。SSE在本质上就与之前的长轮询、短轮询不同，虽然都是基于http协议的，但是轮询需要客户端先发送请求。而SSE最大的特点就是不需要客户端发送请求，可以实现只要服务器端数据有更新，就可以马上发送到客户端。\n\nSSE的优势很明显，它不需要建立或保持大量的客户端发往服务器端的请求，节约了很多资源，提升应用性能，如果想要了解[SSE的实现](https://zhuanlan.zhihu.com/p/90165274)，请戳👇这里。\n\n④WebSocket\n　　WebSocket是Html5定义的一个新协议，与传统的http协议不同，该协议可以实现服务器与客户端之间全双工通信。简单来说，首先需要在客户端和服务器端建立起一个连接，这部分需要http。连接一旦建立，客户端和服务器端就处于平等的地位，可以相互发送数据，不存在请求和响应的区别。\n\nWebSocket的优点是实现了双向通信，缺点是服务器端的逻辑非常复杂。\n\n**四种Web即时通信技术比较**\n\n```\n　　从兼容性角度考虑，短轮询>长轮询>长连接SSE>WebSocket；\n　　从性能方面考虑，WebSocket>长连接SSE>长轮询>短轮询；\n```",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:59:57",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 72,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/关于vue，ts，echart整合显示地图的实现方式.md",
      "title": "关于vue，ts，echart整合显示地图的实现方式",
      "abstract": "这两天需要做一个大屏的东西，看着网上那个地图的效果很酷很炫，所以想整一个这样的东西，话不多说，开始整。因为项目本体是人人开源项目，我是在这个基础上做的一个二次开发吧。后端代码就省略了。其实很简单。在此就不会做太多的赘述了。\n\n## 后端\n\n不过有一个点是可以关注的，就是当你的数据库过于庞大的话，我们可以建一个缓存。也就是一下的示例代码。\n\n2023年5月25日：针对这个数据，因为map里面是放到缓存中了，一直没有释放，所以改用redis，又因为这个是二次开发的项目，所以人家对redis进行了一系列的改造，我在自己新建redis配置类的时候一直报错有冲突，所以在看了一下结构之后，对后端的代码进行了一系列的重构。\n\n### redis工具类\n\n用于从 Redis 中获取缓存数据或者将数据存入 Redis\n\n```java\n\n    public List<Object> getListFromRedis(String key) {\n        Object cachedData = get(key);\n        if (cachedData != null) {\n            // 如果缓存中存在数据，则将其转换为 List 对象并返回\n            return (List) cachedData;\n        } else {\n            // 如果缓存中不存在数据，则返回空列表\n            return new ArrayList<>();\n        }\n    }\n    public void setListToRedis(String key, List<Object> data, long expire) {\n        set(key, data, expire);\n    }\n\n```\n\n\n\n### 控制层\n\n修改 `getEnterpriseNums` 方法，以先从 Redis 中获取数据，如果缓存中存在数据，则直接返回；如果缓存中不存在数据，则从数据库中获取数据，并将其存入 Redis 缓存中\n\n```java\n    @Autowired\n    private RedisUtils redisUtils;\n\t@GetMapping(\"/enterpriseNums\")\n    @ApiOperation(\"返回地图上的区域数据\")\n    public Result getEnterpriseNums(){\n//        List<ShowEnterpriseDetailsNumsDTO> enterpriseDetailsList = enterpriseDetailsService.getEnterpriseNums();\n//        return  new Result().ok(enterpriseDetailsList);\n        String redisKey = \"enterpriseNums\"; // 定义 Redis 缓存的键名\n        List enterpriseDetailsList = redisUtils.getListFromRedis(redisKey);\n        if (enterpriseDetailsList.isEmpty()) {\n            // 从数据库中获取数据\n            enterpriseDetailsList = enterpriseDetailsService.getEnterpriseNums();\n            // 将数据存入 Redis 缓存，设置过期时间为一小时\n            redisUtils.setListToRedis(redisKey, enterpriseDetailsList, RedisUtils.HOUR_ONE_EXPIRE);\n        }\n        return new Result().ok(enterpriseDetailsList);\n    }\n```\n\n~~首先从 `showEnterpriseDetailsServicesCache` 缓存中获取工厂信息列表数据。如果列表数据为空（即缓存中没有数据），则调用 `enterpriseDetailsService.getEnterpriseNums()` 方法获取工厂信息数据，并将其存入缓存中。在下次调用 `getEnterpriseNums()` 方法时，将直接从缓存中获取数据，避免了重复查询的开销。~~\n\n通过以上优化，当第一次请求 `getEnterpriseNums` 接口时，数据将从数据库中获取，并存入 Redis 缓存中。之后的请求将直接从 Redis 缓存中获取数据，从而提高响应速度和性能。请确保 Redis 配置正确，并已经启动了 Redis 服务。\n\n## 前端\n\necharts示例：https://echarts.apache.org/examples/zh/editor.html?c=map-HK\n\n他给的示例我们可以分析出来，我觉得是通过ajax请求来把地图搞到，然后绑定map最后，把数据显示出来。`$.get(ROOT_PATH + '/data/asset/geo/HK.json', function (geoJson)`用于异步加载地图数据。这段代码的作用是通过 AJAX 请求获取名为 `'HK.json' 的地图数据文件，然后在成功获取数据后，使用`echarts.registerMap('HK', geoJson)`将地图数据注册到 ECharts 中，并命名为 `'HK'`。这样，之后在配置地图的 `series` 中就可以通过指定 `map: 'HK'` 来使用该地图数据。\n\n再者我们需要提前的把地图数据导入到项目当中来。可以通过这个平台下载地图的数据\n\nhttp://datav.aliyun.com/portal/school/atlas/area_selector#&lat=30.332329214580188&lng=106.72278672066881&zoom=3.5\n\n![image-20230524221925701](./assets/%E5%85%B3%E4%BA%8Evue%EF%BC%8Cts%EF%BC%8Cechart%E6%95%B4%E5%90%88%E6%98%BE%E7%A4%BA%E5%9C%B0%E5%9B%BE%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/image-20230524221925701.png)\n\n然后的话导入方式，因为项目的原因我们需要这样做，\n\n**先是import**\n\n```typescript\nimport jiNanMapJson from \"src/views/enterprise/assets/json/济南市.json\";\n\nimport * as echarts from \"echarts\";\n```\n\n**再然后注册地图数据到 ECharts：**\n\n```typescript\necharts.registerMap('jiNan', jiNanMapJson);\n```\n\n**更新 `mapOption` 中的 `series` 配置，将 `map: 'HK'` 添加到相关的地图系列中，以便使用注册的地图数据：**\n\n```typescript\nconst mapOption = ref({\n  // ...其他配置项\n  series: [\n    {\n      // ...其他系列配置\n      map: 'jiNan', // 使用注册的地图数据\n      // ...其他系列配置\n    }\n  ]\n});\n```\n\n通过这种方式，我们可以注册到其中，完整代码如下：\n\n```vue\n<template>\n  <div class=\"box\">\n    <el-form-item>\n      <el-button type=\"warning\" @click=\"importHandle()\">{{ $t(\"excel.import\") }}</el-button>\n    </el-form-item>\n    <div style=\"width: 100%;margin-left: 6em;margin-bottom: 2em;\">\n      <div class=\"topShow\">\n        <div style=\"color:brown; font-size: 1.875rem /* 30/16 */;text-align: center;padding-top: 1.4375rem /* 23/16 */;\">\n          信用金桥大数据屏幕展示平台</div>\n        <div style=\"color:brown; font-size: 1.25rem /* 20/16 */;text-align: right;padding-right: 2.1875rem /* 35/16 */;;\">\n          {{ dataForm.currentTime }}</div>\n      </div>\n    </div>\n\n\n    <div class=\"line_01\">\n      <figure class=\"figure_left\">\n        <div v-for=\"(item, index) in dataForm.enterpriseNums\" :key=\"index\" style=\"width: 23em;text-align: center; \">\n          <div class=\"card\">\n            <span style=\"color: red;\">{{ item.name }}区</span>\n            在营企业总数 ：\n            <span style=\"color: sienna; font-size: 2em;\">{{ item.value }} 家</span>\n          </div>\n          <br />\n        </div>\n      </figure>\n\n      <figure class=\"figure_center\">\n\n      </figure>\n      <figure class=\"figure_right\">\n        <v-chart :option=\"mapOption\" :autoresize=\"true\" />\n      </figure>\n    </div>\n    <div class=\"line_02\">\n      <figure class=\"figure_left\">\n        <v-chart :option=\"pie\" :autoresize=\"true\" />\n      </figure>\n    </div>\n\n\n\n    <import ref=\"importRef\"></import>\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport { ref, provide, reactive } from \"vue\";\nimport { use } from \"echarts/core\";\nimport { CanvasRenderer } from \"echarts/renderers\";\nimport { BarChart, LineChart, PieChart, MapChart, RadarChart, ScatterChart, EffectScatterChart, LinesChart } from \"echarts/charts\";\nimport { GridComponent, PolarComponent, GeoComponent, TooltipComponent, LegendComponent, TitleComponent, VisualMapComponent, DatasetComponent, ToolboxComponent, DataZoomComponent } from \"echarts/components\";\nimport VChart, { THEME_KEY } from \"vue-echarts\";\nimport app from \"@/constants/app\";\nimport { getToken } from \"@/utils/cache\";\nimport Import from '@/views/enterprise/enterprise-library-import.vue';\nimport baseService from \"@/service/baseService\";\nimport jiNanMapJson from \"src/views/enterprise/assets/json/济南市.json\";\nimport zhangQiuMapJson from \"src/views/enterprise/assets/json/章丘区.json\";\nimport * as echarts from \"echarts\";\n\nuse([BarChart, LineChart, PieChart, MapChart, RadarChart, ScatterChart, EffectScatterChart, LinesChart, GridComponent, PolarComponent, GeoComponent, TooltipComponent, LegendComponent, TitleComponent, VisualMapComponent, DatasetComponent, CanvasRenderer, ToolboxComponent, DataZoomComponent]);\n\nprovide(THEME_KEY, \"westeros\");\n\nconst dataForm = reactive({\n  currentTime: '',\n  enterpriseNums: [],\n});\n\n\nconst importRef = ref();\nconst importHandle = () => {\n  importRef.value.init(`${app.api}/enterprise/details/import?token=${getToken()}`);\n};\n\nconst list = ref([]);\nconst industryNames = ref([]);\nconst getIndustryInfo = async () => {\n  let result = await (await baseService.get(\"/enterprise/details/industryInfo\")).data;\n  list.value = result;\n  industryNames.value = result.map((item: any) => item.name);\n};\ngetIndustryInfo();\n\nconst updateTime = () => {\n  const currentDate = new Date();\n  const year = String(currentDate.getFullYear());\n  const month = String(currentDate.getMonth() + 1).padStart(2, '0');\n  const date = String(currentDate.getDate()).padStart(2, '0');\n  const hours = String(currentDate.getHours()).padStart(2, '0');\n  const minutes = String(currentDate.getMinutes()).padStart(2, '0');\n  const seconds = String(currentDate.getSeconds()).padStart(2, '0');\n  dataForm.currentTime = `${year}年${month}月${date}日  ${hours}:${minutes}:${seconds}`;\n};\nsetInterval(() => {\n  updateTime();\n}, 1000);\n\nconst mapMsg = ref([]);\nconst getEnterpriseNums = async () => {\n  let result = await (await baseService.get(\"/enterprise/details/enterpriseNums\")).data;\n  dataForm.enterpriseNums = result;\n  mapMsg.value = result;\n  //console.log(mapMsg)\n};\ngetEnterpriseNums();\n\necharts.registerMap('jiNan', jiNanMapJson);\nconst mapOption = ref({\n  title: {\n    text: '济南市各区在营企业统计',\n    subtext: '数据来源XXXX',\n  },\n  tooltip: {\n    trigger: 'item',\n    formatter: '{b}<br/>{c} (家)'\n  },\n  toolbox: {\n    show: false,\n    orient: 'vertical',\n    left: 'right',\n    top: 'center',\n    feature: {\n      dataView: { readOnly: false },\n      restore: {},\n      saveAsImage: {}\n    }\n  },\n  visualMap: {\n    min: 800,\n    max: 500000,\n    text: ['High', 'Low'],\n    realtime: false,\n    calculable: true,\n    inRange: {\n      color: ['lightskyblue', 'yellow', 'orangered']\n    }\n  },\n  series: [\n    {\n      name: '济南市各区注册企业数量',\n      type: 'map',\n      map: 'jiNan',\n      label: {\n        show: true\n      },\n      data: mapMsg,\n    }\n  ]\n});\n\n\nconst pie = ref({\n  title: {\n    text: \"行业占比\",\n    left: \"center\"\n  },\n  tooltip: {\n    trigger: \"item\",\n    formatter: \"{a} <br/>{b} : {c} ({d}%)\"\n  },\n  legend: {\n    type: 'scroll',\n    orient: \"vertical\",\n    right: 10,\n    top: 20,\n    bottom: 20,\n    left: \"left\",\n    data: industryNames\n  },\n  series: [\n    {\n      name: \"行业占比\",\n      type: \"pie\",\n      label: {\n        show: false\n      },\n      radius: \"55%\",\n      center: [\"50%\", \"60%\"],\n      data: list,\n      emphasis: {\n        itemStyle: {\n          shadowBlur: 10,\n          shadowOffsetX: 0,\n          shadowColor: \"rgba(0, 0, 0, 0.5)\"\n        }\n      }\n    }\n  ]\n});\n</script>\n\n<style lang=\"less\" scoped>\n.topShow {\n  width: 90%;\n  height: 5rem\n    /* 80/16 */\n  ;\n  font-family: \"得意黑\";\n  border-radius: 3.125rem\n    /* 50/16 */\n  ;\n  border-radius: 3.4375rem\n    /* 55/16 */\n  ;\n  border-radius: 2.5rem\n    /* 40/16 */\n  ;\n  background: #f0f0ff;\n  box-shadow: .4375rem\n    /* 7/16 */\n    .4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ccccd9,\n    -.4375rem\n    /* 7/16 */\n    -.4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ffffff;\n}\n\n@font-face {\n  font-family: '得意黑';\n  src: url('./assets/font/SmileySans-Oblique-2.ttf');\n  font-weight: normal;\n  font-style: normal;\n}\n\n.card {\n  border-radius: .5rem\n    /* 8/16 */\n  ;\n  font-family: \"得意黑\";\n  font-size: large;\n  border-radius: 1.125rem\n    /* 18/16 */\n  ;\n  background: #f0f0ff;\n  box-shadow: inset .4375rem\n    /* 7/16 */\n    .4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ccccd9,\n    inset -.4375rem\n    /* 7/16 */\n    -.4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ffffff;\n}\n\n.box {\n  position: relative;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n\n  figure {\n    display: inline-block;\n    // position: relative;\n    //margin: 2em auto;\n    border: .0625rem\n      /* 1/16 */\n      solid rgba(0, 0, 0, 0.1);\n    border-radius: .5rem\n      /* 8/16 */\n    ;\n    box-shadow: 0 0 2.8125rem\n      /* 45/16 */\n      rgba(0, 0, 0, 0.2);\n    padding: 1.875rem\n      /* 30/16 */\n    ;\n\n    .echarts {\n      width: 40vw;\n      min-width: 25rem\n        /* 400/16 */\n      ;\n      height: 18.75rem\n        /* 300/16 */\n      ;\n    }\n  }\n}\n\n.line_01 {\n  width: 100%;\n  height: auto;\n\n  // 左对齐\n  .figure_left {\n    float: left;\n    width: 27em;\n    border-radius: 1.125rem\n      /* 18/16 */\n    ;\n    background: #f0f0ff;\n    box-shadow: .4375rem\n      /* 7/16 */\n      .4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ccccd9,\n      -.4375rem\n      /* 7/16 */\n      -.4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ffffff;\n  }\n\n  //右对齐\n  .figure_right {\n    float: right;\n    width: 50em;\n\n    .echarts {\n      width: auto;\n      height: 43.75rem\n        /* 700/16 */\n      ;\n    }\n\n    border-radius: 1.125rem\n    /* 18/16 */\n    ;\n    background: #f0f0ff;\n    box-shadow: .4375rem\n    /* 7/16 */\n    .4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ccccd9,\n    -.4375rem\n    /* 7/16 */\n    -.4375rem\n    /* 7/16 */\n    .875rem\n    /* 14/16 */\n    #ffffff;\n  }\n\n  .figure_center {\n    //float: right;\n    //position: absolute;\n    width: 21em;\n    border-radius: 1.125rem\n      /* 18/16 */\n    ;\n    background: #f0f0ff;\n    box-shadow: .4375rem\n      /* 7/16 */\n      .4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ccccd9,\n      -.4375rem\n      /* 7/16 */\n      -.4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ffffff;\n  }\n}\n\n.line_02 {\n  width: 100%;\n  height: auto;\n\n  // 左对齐\n  .figure_left {\n    float: left;\n    width: 50em;\n    border-radius: 1.125rem\n      /* 18/16 */\n    ;\n    background: #f0f0ff;\n    box-shadow: .4375rem\n      /* 7/16 */\n      .4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ccccd9,\n      -.4375rem\n      /* 7/16 */\n      -.4375rem\n      /* 7/16 */\n      .875rem\n      /* 14/16 */\n      #ffffff;\n  }\n}</style>\n\n```\n\n最终实现效果可参考echarts的案例。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:57:13",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1122,
        "text": "6分钟"
      }
    },
    {
      "link": "技术笔记/前端/JavaScript圣杯布局与双飞翼布局.md",
      "title": "JavaScript圣杯布局与双飞翼布局",
      "abstract": "参考：https://juejin.cn/post/6973562604581027853\r\n\r\n**圣杯布局**是通过`float`搭建布局+`margin`使三列布局到一行上+`relative`相对定位调整位置。\r\n\r\n**双飞翼布局**是通过`float`+`margin`，**没有使用相对定位**。\r\n\r\n![ss](./assets/JavaScript%E5%9C%A3%E6%9D%AF%E5%B8%83%E5%B1%80%E4%B8%8E%E5%8F%8C%E9%A3%9E%E7%BF%BC%E5%B8%83%E5%B1%80/2022080416035961.png)\r\n\r\n## 圣杯布局\r\n\r\n```javascript\r\n<style>\r\n  * {\r\n      padding: 0;\r\n      margin: 0;\r\n      text-align: center;\r\n  }\r\n  html{\r\n      height: 100%;\r\n  }\r\n  body{\r\n      display: flex;\r\n      flex-direction: column;\r\n      height: 100%;;\r\n  }\r\n  .header{\r\n      width: 100%;\r\n      height: 50px;\r\n      background-color:dimgray;\r\n  }\r\n  .footer{\r\n      width: 100%;\r\n      height: 50px;\r\n      background-color:dimgray;\r\n  }\r\n  .outer{\r\n      flex:1;\r\n      padding-left: 100px;\r\n      padding-right: 200px;\r\n  }\r\n  .center{\r\n      float: left;\r\n      background-color: darkslateblue;\r\n      height: 100%;\r\n      width: 100%;\r\n  }\r\n  .left{\r\n      float: left;\r\n      width: 100px;\r\n      margin-left: -100%;\r\n      background-color: burlywood;\r\n      height: 100%;\r\n      position: relative;\r\n      left: -100px;\r\n  }\r\n  .right{\r\n      float: left;\r\n      width: 200px;\r\n      margin-left: -200px;\r\n      height: 100%;\r\n      position: relative;\r\n      right: -200px;\r\n      background-color: cyan;\r\n  }\r\n</style>\r\n<body>\r\n    <div class=\"header\">header</div>\r\n    <div class=\"outer\">\r\n        <div class=\"center\">center</div>\r\n        <div class=\"left\">left</div>\r\n        <div class=\"right\">right</div>\r\n    </div>\r\n    <div class=\"footer\">footer</div>\r\n</body>\r\n```\r\n\r\n## 双飞翼布局\r\n\r\n```javascript\r\n<style>\r\n    *{\r\n        padding: 0;\r\n        margin: 0;\r\n    }\r\n    html{\r\n        width: 100%;\r\n        height: 100%;\r\n        text-align: center;\r\n    }\r\n    body{\r\n        display: flex;\r\n        width: 100%;\r\n        height: 100%;\r\n        flex-direction: column;\r\n    }\r\n    .header{\r\n        background-color:grey;\r\n        height: 50px;\r\n    }\r\n    .footer{\r\n        background-color:grey;\r\n        height: 50px;\r\n    }\r\n    .outer{\r\n        flex:1;\r\n    }\r\n    .center{\r\n        float: left;\r\n        width: 100%;\r\n        background-color: darkslateblue;\r\n        height: 100%;\r\n    }\r\n    .left{\r\n        float: left;\r\n        margin-left: -100%;\r\n        width: 100px;\r\n        background-color: burlywood;\r\n        height: 100%;\r\n    }\r\n    .right{\r\n        float: left;\r\n        width: 200px;\r\n        background-color: cyan;\r\n        margin-left: -200px;\r\n        height: 100%;\r\n    }\r\n    .content{\r\n        margin-left: 100px;\r\n        margin-right: 200px;\r\n        height: 100%;\r\n    }\r\n</style>\r\n<body>\r\n    <div class=\"header\">header</div>\r\n    <div class=\"outer\">\r\n        <div class=\"center\">\r\n            <div class=\"content\">content</div>\r\n        </div>\r\n        <div class=\"left\">left</div>\r\n        <div class=\"right\">right</div>\r\n    </div>\r\n    <div class=\"footer\">footer</div>\r\n</body>\r\n```\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 213,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/前端/vue数据传递加载以及v-if判断不显示.md",
      "title": "vue数据传递加载以及v-if判断不显示",
      "abstract": "今天在尽心数据传递的时候，在点击的时候，发现数据第一次会为空，但是控制台get到的数据时正常的，也就是说，赋值的时候能赋值上去，当时到了v-if判断的时候出现了小问题。\r\n\r\n一开始时按照h5的逻辑来，我以为是script在标签后面，所以才后渲染，导致判断失误的。以为时vue渲染的时候先吧标签渲染，然后才开始渲染script，但是这样的情况时不合理的，如果后加载标签的话，那么显示的时候标签上的颜色标签应该是不上色的情况。所以这个思路时错误的。\r\n\r\n\r\n\r\n代码大致的结构是这样的，之前的代码删了，大致情况时这个样子。\r\n\r\n```vue\r\n<template>\r\n  <el-dialog v-model=\"visible\" :title=\"$t('文件预览')\" :close-on-click-modal=\"false\" :close-on-press-escape=\"false\">\r\n    <div v-if=\"fileType == 'jpg' ||\r\n      fileType == 'png' ||\r\n      fileType == 'ico' ||\r\n      fileType == 'gif' ||\r\n      fileType == 'webp' \r\n      \">\r\n      <el-image style=\"width: 100%\" :src=\"getFilePath\"> </el-image>\r\n    </div>\r\n    <div v-else-if=\"fileType == 'docx' || fileType == 'doc'\">文档\r\n      <embed :src=\"getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else-if=\"fileType == 'xlsx' || fileType == 'xls'\">表格\r\n      <embed :src=\"getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else-if=\"fileType == 'pdf'\">\r\n      <embed :src=\"getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else>\r\n      <h2 style=\"text-align: center;color: brown; \">暂不支持该文件格式！</h2>\r\n    </div>\r\n    <template v-slot:footer>\r\n      <el-button @click=\"visible = false\">{{ $t(\"退出预览\") }}</el-button>\r\n    </template>\r\n  </el-dialog>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { reactive, ref } from \"vue\";\r\nimport baseService from \"@/service/baseService\";\r\nimport { ElMessage } from \"element-plus\";\r\n\r\nconst visible = ref(false);\r\nconst dataFormRef = ref();\r\nvar getFilePath = \"\";\r\nvar fileType = \"\";\r\n\r\nconst fileMessage = reactive({\r\n  getFilePath: \"\",\r\n  fileType: \"\"\r\n});\r\n\r\nconst dataForm = reactive({\r\n  uploadFileId: \"\",\r\n  uploadCompanyName: \"\",\r\n  uploadFileName: \"\",\r\n  uploadFilePath: \"\",\r\n  uploadUserName: \"\",\r\n  uploadFileTime: \"\",\r\n});\r\n\r\nconst init = (uploadFileId?: number) => {\r\n  visible.value = true;\r\n  dataForm.uploadFileId = \"\";\r\n\r\n  //重置表单数据\r\n  if (dataFormRef.value) {\r\n    dataFormRef.value.resetFields();\r\n  }\r\n\r\n  if (uploadFileId) {\r\n    getInfo(uploadFileId);\r\n  }\r\n};\r\n\r\n//var showType: string;\r\n// 获取信息\r\nconst getInfo = (uploadFileId: number) => {\r\n  baseService.get(\"/uploadFile/xyjqfileupload/\" + uploadFileId).then((res) => {\r\n    Object.assign(dataForm, res.data);\r\n    if (dataForm.uploadFilePath != \"\") {\r\n      getFilePath = dataForm.uploadFilePath; //获取到图片的路径，写在这里面才管用，写在外面，第一次请求时候没有数据\r\n      //获取文件的类型，取文件后缀名判断\r\n      fileType = getFilePath.substring(getFilePath.lastIndexOf(\".\") + 1, getFilePath.length);\r\n      console.log(\"文件类型：\" + fileType);\r\n      console.log(getFilePath);\r\n    } else {\r\n      ElMessage.error(\"链接地址为空，无法打开\");\r\n    }\r\n  });\r\n};\r\ndefineExpose({\r\n  init\r\n});\r\n</script>\r\n\r\n```\r\n\r\n代码大致时这个情况，后来发现主要原因出现在这两个赋值传递值的阶段\r\n\r\n```html\r\nvar filetype=\"\";\r\nvar getFilePath=\"\";\r\n```\r\n\r\n不知道是不是vue的结构还是html的结构问题，主要脚本语言时时typescript，需要const定义一下属性进行赋值，才可以在第一次传递数据和判断数据的时候生效，也就是说要改成下面的这个情况。而且在ts中，var的作用区间并不是和js一样，我想大概是因为这个情况吧，才学没多久，希望有人能指出这个bug来。。。。\r\n\r\n```html\r\nconst fileMessage = reactive({\r\n  getFilePath: \"\",\r\n  fileType: \"\"\r\n});\r\n```\r\n\r\n\r\n\r\n这个是正确的结构：\r\n\r\n```vue\r\n<template>\r\n  <el-dialog v-model=\"visible\" :title=\"$t('文件预览')\" :close-on-click-modal=\"false\" :close-on-press-escape=\"false\">\r\n    <div v-if=\"fileMessage.fileType == 'jpg' ||\r\n      fileMessage.fileType == 'png' ||\r\n      fileMessage.fileType == 'ico' ||\r\n      fileMessage.fileType == 'gif' ||\r\n      fileMessage.fileType == 'webp' \r\n      \">\r\n      <el-image style=\"width: 100%\" :src=\"fileMessage.getFilePath\"> </el-image>\r\n    </div>\r\n    <div v-else-if=\"fileMessage.fileType == 'docx' || fileMessage.fileType == 'doc'\">文档\r\n      <embed :src=\"fileMessage.getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else-if=\"fileMessage.fileType == 'xlsx' || fileMessage.fileType == 'xls'\">表格\r\n      <embed :src=\"fileMessage.getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else-if=\"fileMessage.fileType == 'pdf'\">\r\n      <embed :src=\"fileMessage.getFilePath\" style=\"width: 100%; height: 600px\" />\r\n    </div>\r\n    <div v-else>\r\n      <h2 style=\"text-align: center;color: brown; \">暂不支持该文件格式！</h2>\r\n    </div>\r\n    <template v-slot:footer>\r\n      <el-button @click=\"visible = false\">{{ $t(\"退出预览\") }}</el-button>\r\n    </template>\r\n  </el-dialog>\r\n</template>\r\n\r\n<script lang=\"ts\" setup>\r\nimport { reactive, ref } from \"vue\";\r\nimport baseService from \"@/service/baseService\";\r\nimport { ElMessage } from \"element-plus\";\r\n\r\nconst visible = ref(false);\r\nconst dataFormRef = ref();\r\n\r\nconst fileMessage = reactive({\r\n  getFilePath: \"\",\r\n  fileType: \"\"\r\n});\r\n\r\nconst dataForm = reactive({\r\n  uploadFileId: \"\",\r\n  uploadCompanyName: \"\",\r\n  uploadFileName: \"\",\r\n  uploadFilePath: \"\",\r\n  uploadUserName: \"\",\r\n  uploadFileTime: \"\",\r\n});\r\n\r\nconst init = (uploadFileId?: number) => {\r\n  visible.value = true;\r\n  dataForm.uploadFileId = \"\";\r\n\r\n  //重置表单数据\r\n  if (dataFormRef.value) {\r\n    dataFormRef.value.resetFields();\r\n  }\r\n\r\n  if (uploadFileId) {\r\n    getInfo(uploadFileId);\r\n  }\r\n};\r\n//var showType: string;\r\n// 获取信息\r\nconst getInfo = (uploadFileId: number) => {\r\n  baseService.get(\"/uploadFile/xyjqfileupload/\" + uploadFileId).then((res) => {\r\n    Object.assign(dataForm, res.data);\r\n    if (dataForm.uploadFilePath != \"\") {\r\n      fileMessage.getFilePath = dataForm.uploadFilePath; //获取到图片的路径，卸载这里面才管用，写在外面，第一次请求时候没有数据\r\n      //console.log(getFilePath.substring(getFilePath.lastIndexOf(\".\") + 1, getFilePath.length));\r\n      //console.log(getFilePath);\r\n      fileMessage.fileType = fileMessage.getFilePath.substring(fileMessage.getFilePath.lastIndexOf(\".\") + 1, fileMessage.getFilePath.length);\r\n      //showType = fileType;\r\n      console.log(\"文件类型：\" + fileMessage.fileType);\r\n      console.log(fileMessage.getFilePath);\r\n\r\n\r\n    } else {\r\n      ElMessage.error(\"链接地址为空，无法打开\");\r\n    }\r\n  });\r\n};\r\n\r\ndefineExpose({\r\n  init\r\n});\r\n</script>\r\n\r\n```\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 493,
        "text": "3分钟"
      }
    },
    {
      "link": "技术笔记/前端/前端实现时间刷新.md",
      "title": "前端实现时间刷新",
      "abstract": "前端实现个时间刷新的案例：\r\n\r\n## 标签\r\n\r\n```html\r\n<div style=\"color:brown; font-size: 1.25rem /* 20/16 */;text-align: right;padding-right: 2.1875rem /* 35/16 */;;\">\r\n          {{ dataForm.currentTime }}</div>\r\n```\r\n\r\n\r\n\r\n## script\r\n\r\n```typescript\r\nconst updateTime = () => {\r\n  const currentDate = new Date();\r\n  const year = String(currentDate.getFullYear());\r\n  const month = String(currentDate.getMonth() + 1).padStart(2, '0');\r\n  const date = String(currentDate.getDate()).padStart(2, '0');\r\n  const hours = String(currentDate.getHours()).padStart(2, '0');\r\n  const minutes = String(currentDate.getMinutes()).padStart(2, '0');\r\n  const seconds = String(currentDate.getSeconds()).padStart(2, '0');\r\n  dataForm.currentTime = `${year}年${month}月${date}日  ${hours}:${minutes}:${seconds}`;\r\n};\r\n```\r\n\r\n这里主要调用的是 Date();的前端的方法。\r\n\r\n然后我们设置定时器一秒刷新一次。\r\n\r\n```typescript\r\nsetInterval(() => {\r\n  updateTime();\r\n}, 1000);\r\n```\r\n\r\n这是根据人人开源项目做二次开发写的，其实二次开发真的有些难受。\r\n\r\n如果要根据vue的方式来写就是这样的\r\n\r\n```vue\r\n<script>\r\nexport default {\r\n  data() {\r\n    return {\r\n      currentTime: ''\r\n    };\r\n  },\r\n  mounted() {\r\n    // 更新时间\r\n    this.updateTime();\r\n\r\n    // 每秒钟更新一次时间\r\n    setInterval(() => {\r\n      this.updateTime();\r\n    }, 1000);\r\n  },\r\n  methods: {\r\n    updateTime() {\r\n  const currentDate = new Date();\r\n  const year = currentDate.getFullYear();\r\n  const month = String(currentDate.getMonth() + 1).padStart(2, '0');\r\n  const day = String(currentDate.getDate()).padStart(2, '0');\r\n  const hours = String(currentDate.getHours()).padStart(2, '0');\r\n  const minutes = String(currentDate.getMinutes()).padStart(2, '0');\r\n  const seconds = String(currentDate.getSeconds()).padStart(2, '0');\r\n  this.currentTime = `${year}-${month}-${day} ${hours}:${minutes}:${seconds}`;\r\n    }\r\n  }\r\n};\r\n</script>\r\n\r\n```\r\n\r\n在`mounted`生命周期钩子中，我们通过调用`updateTime`方法来初始化时间，并使用`setInterval`函数每秒钟更新一次时间。\r\n\r\n`updateTime`方法会获取当前时间并更新`currentTime`的值，然后将其显示在页面中。\r\n\r\n`getYear`方法返回的是四位数的年份，`getMonth`方法返回的是从0开始的月份（需要加1），`getDate`方法返回的是月份中的日期。我们将它们转换为字符串并使用`padStart`方法进行补零操作，以保证两位数的格式。\r\n\r\n最后，我们将年、月、日、时、分和秒拼接为一个完整的日期时间字符串，并将其赋值给`currentTime`，用于在页面中显示。\r\n\r\n其中有个点就是在获取日期时，`getDay()`方法返回的是星期几（0-6），而不是日期。今天就犯糊涂了，用了`getday()`\r\n\r\n另外推荐一个很好的拟态风格的css生成网站，简直不要太好用！！！！\r\n\r\nhttps://neumorphism.io/#e0e0e0",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 167,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/前端点击链接使用新建窗口打开外部链接.md",
      "title": "前端点击链接使用新建窗口打开外部链接",
      "abstract": "**方法一：**\r\n\r\n我们可以使用a标签的属性来实现新建窗口跳转\r\n\r\n```html\r\n<a :href=\"item.sciUrl\" target=\"_blank\">\r\n</a>\r\n```\r\n\r\n其中`target`有以下几种属性\r\n\r\n| 值          | 描述                                 |\r\n| :---------- | :----------------------------------- |\r\n| _blank      | 在新窗口中打开被链接文档。           |\r\n| _self       | 默认。在相同的框架中打开被链接文档。 |\r\n| _parent     | 在父框架集中打开被链接文档。         |\r\n| _top        | 在整个窗口中打开被链接文档。         |\r\n| *framename* | 在指定的框架中打开被链接文档。       |\r\n\r\n**方法二：**\r\n\r\n我们可以使用js脚本来配合跳转\r\n\r\nhtml部分\r\n\r\n```vue\r\n<span @click=\"See(url)\">点击此处实现跳转</span>\r\n```\r\n\r\njs部分\r\n\r\n```javascript\r\nSee (e) {\r\n        window.location.href = e\r\n      }\r\n```\r\n\r\n其中url也就是你的传入值。\r\n\r\n\r\n\r\n\r\n\r\n在这里面说明一下，你的链接在写的时候，必须带上`http://`或者`https://`如果不带的话，vue会自动识别为路由的\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 64,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/前端获取上传文件大小.md",
      "title": "前端获取上传文件大小",
      "abstract": "上传文件需要判别文件大小\r\n\r\n以这个为案例\r\n\r\n**显示部分**\r\n\r\n```html\r\n<input id=\"uploadFile\" type=\"file\" name=\"myPhoto\"/> \r\n<button id=\"btnConfirm\" class=\"btn\" onclick=\"checkFile()\">确认上传</button> \r\n```\r\n\r\n**JS部分**\r\n\r\n```javascript\r\n<script>\r\n        function checkFile() {\r\n          //获取文件 \r\n          var file = document.getElementById(\"uploadFile\").files[0];\r\n          var filesize=file.size;//文件的字节数\r\n          alert(filesize)\r\n        }; \r\n</script>\r\n```\r\n\r\n通过id获取文件来判断文件大小，这种方式是获取的文件字节数，也就是说是b如果要显示大小的话还需要除1024*1024\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 32,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/如何修改vue项目运行的端口号.md",
      "title": "如何修改vue项目运行的端口号",
      "abstract": "### 配置文件修改端口号\r\n\r\n打开 config里面的index.js文件  ，找到配置：\r\n\r\n```javascript\r\nport: 8080\r\n```\r\n\r\n![image-20230507183326621](./assets/%E5%A6%82%E4%BD%95%E4%BF%AE%E6%94%B9vue%E9%A1%B9%E7%9B%AE%E8%BF%90%E8%A1%8C%E7%9A%84%E7%AB%AF%E5%8F%A3%E5%8F%B7/image-20230507183326621.png)\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/油猴脚本优化csdn.md",
      "title": "油猴脚本优化csdn",
      "abstract": "在百度的时候，发现CSDN是真滴丑陋，现有的油猴脚本更改的并不如我所愿。而且CSDN的弹出搜索评论笔记这三个框框让我很不喜欢，所以想办法去除。\r\n\r\n![image-20230504185928783](./assets/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96csdn/image-20230504185928783.png)\r\n\r\n经过实践发现，这三个按钮，也可以说是链接，因为他的表现形式是`<a>`标签。他的总的class标签是`articleSearchTip`这个标签，但是把通过测试发现，只有你在选中的时候，这标签才会出现，补选中的这个标签就不会显示，可以理解为vue中的v-if标签。这倒是让人很头疼呢。\r\n\r\n所以我们要做个鼠标监听的动作也就是mouseup在鼠标抬起的时候进行监听，这个标签是否出现。然后再删除评论和笔记这俩带有类标签名字的标签。\r\n\r\n接下来的步骤就是针对搜索进行一定的优化`var txt = window.getSelection();`在这里\r\n\r\n`window.getSelection()`的作用就是从你鼠标选择的那些东西，拿上面图片举例子的话就是“需要使用java”这个数据。\r\n\r\n然后利用`setAttribute`进行跳转搜索\r\n\r\n---\r\n\r\n整体的油猴代码就是这个样子的\r\n\r\n```javascript\r\n// ==UserScript==\r\n// @name         自用csdn优化\r\n// @namespace    http://tampermonkey.net/\r\n// @version      0.1\r\n// @author       DelLevin\r\n// @description  个人自用，选中弹出优化\r\n// @connect      www.csdn.net\r\n// @match        *://*.csdn.net/*\r\n// @match        *://*.51cto.com/*\r\n// @grant        GM_addStyle\r\n// @grant        GM_setValue\r\n// @grant        GM_getValue\r\n// @require      https://code.jquery.com/jquery-2.1.4.min.js\r\n// @icon         https://www.google.com/s2/favicons?sz=64&domain=csdn.net\r\n// @license MIT\r\n// ==/UserScript==\r\n//this.$ = this.jQuery = jQuery.noConflict(true);\r\n(function() {\r\n    'use strict';\r\n//51cto的脚本\r\n\r\n//CSDN的脚本\r\n    function removeACdiv()\r\n    {\r\n      var txt = window.getSelection();\r\n      if(txt.toString()!=\"\"){\r\n            if(document.getElementsByClassName(\"article-search\")[0]){\r\n            $(\".article-comment\").remove();\r\n            $(\".cnote\").remove();\r\n            txt=\"https://www.baidu.com/s?wd=\"+txt;\r\n            document.getElementsByClassName(\"article-search\")[0].setAttribute(\"href\",txt);\r\n            clearInterval(removeACdiv);\r\n        }else{\r\n            setTimeout(removeACdiv,50);\r\n        }\r\n      }\r\n    }\r\n    //松开鼠标出发动作  https://developer.aliyun.com/article/443201\r\n    $('.baidu_pl').mouseup(removeACdiv);\r\n   $(\".option-box\").remove();\r\n   //顶部搜索框中间\r\n    var toolbar_menus = document.getElementsByClassName(\"toolbar-menus\");\r\n    //console.log(toolbar_menus[0]);\r\n    for(var m=0;m<toolbar_menus.length;m++){\r\n     if (toolbar_menus[m] != null)\r\n           toolbar_menus[m].parentNode.removeChild(toolbar_menus[m]);\r\n }\r\n    //顶部搜索框\r\n    var toolbar_search_container = document.getElementsByClassName(\"toolbar-search-container\");\r\n    for(var i=0;i<toolbar_search_container.length;i++){\r\n     if (toolbar_search_container[i] != null)\r\n           toolbar_search_container[i].parentNode.removeChild(toolbar_search_container[i]);\r\n }\r\n    //顶部搜索框右边\r\n    var toolbar_btns = document.getElementsByClassName(\"toolbar-btns\");\r\n    for(var j=0;j<toolbar_btns.length;j++){\r\n     if (toolbar_btns[j] != null)\r\n           toolbar_btns[j].parentNode.removeChild(toolbar_btns[j]);\r\n }\r\n    //下面的分享这一行框框\r\n    var left_toolbox = document.getElementsByClassName(\"left-toolbox\");\r\n    for(var k=0;k<left_toolbox.length;k++){\r\n     if (left_toolbox[k] != null)\r\n           left_toolbox[k].parentNode.removeChild(left_toolbox[k]);\r\n }\r\n\r\n})();\r\n```\r\n\r\n显示方式是这样的（缺点是，字符少的时候他就不起作用了，因为主要判断方式是判断字符是否存在，我也不知道是什么毛病，欸。。。。）\r\n\r\n![image-20230504191243205](./assets/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96csdn/image-20230504191243205.png)\r\n\r\n然后删除了上面搜索栏那些东西\r\n\r\n![image-20230504191444758](./assets/%E6%B2%B9%E7%8C%B4%E8%84%9A%E6%9C%AC%E4%BC%98%E5%8C%96csdn/image-20230504191444758.png)\r\n\r\n主要用到了这些：\r\n\r\n**jq的选择器：**\r\n\r\nhttps://www.runoob.com/jquery/jquery-ref-selectors.html\r\n\r\n这个是个关键点，因为需要监听这个类标签内的选中文本的内容，所以  `$('.baidu_pl').mouseup(removeACdiv);`要这么写\r\n\r\n**参考文章（没用，但是学到了）**\r\n\r\nhttps://www.jianshu.com/p/760079b716e7",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 159,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/前端/获取小数点后一位且不进行四舍五入.md",
      "title": "获取小数点后一位且不进行四舍五入",
      "abstract": "今天计算PUE的时候遇到了一个问题，对方要求取小数点后一位，不能进行四舍五入。这样的话`toFixed`方法就用不了了。同时`Math.round`也不能使用，他的本事就是四舍五入的计算方式。\n\n**toFixed() 方法**\n\n- toFixed() 方法可以将数字转换为字符串，并指定小数点后保留几位。如果小数实际位数不够指定的位数，不足的部分会补 0。所有主要浏览器都支持 toFixed() 方法。\n- toFixed() 使用的是银行家舍入规则：四舍六入五取偶（又称四舍六入五留双）。\n\n在网上找了一个自建的方法。\n\n```javascript\n/**\n *\n * @param {number|string} num 需要处理的数字\n * @param {number} n 保留位数,默认1\n * @param {string} flag = 'ceil' || 'floor' 向上或向下保留，默认四舍五入\n * @returns {string}\n */\nfunction formatFloat(num, n = 1, flag) {\n    var f = parseFloat(num);\n    if (isNaN(f)) {\n        return false;\n    }\n    if (flag === 'ceil') {\n        f = Math.ceil(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    } else if (flag === 'floor') {\n        f = Math.floor(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    } else {\n        f = Math.round(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    }\n    var s = f.toString();\n    var rs = s.indexOf('.');\n    //判定如果是整数，增加小数点再补0\n    if (rs < 0) {\n        rs = s.length;\n        s += '.';\n    }\n    while (s.length <= rs + n) {\n        s += '0';\n    }\n    return s;\n}\n```\n\n测试结果：\n\n![image-20221113193653400](assets/获取小数点后一位且不进行四舍五入/image-20221113193653400.png)\n\n\n\n项目引用案例：\n\n```html\n<!DOCTYPE html>\n<html style=\"height: 100%\">\n\n<head>\n  <meta charset=\"utf-8\">\n</head>\n\n<body style=\"height: 100%; margin: 0; background-color: transparent\">\n  <div id=\"container\" style=\"height: 100%; background-color: transparent\"></div>\n  <script type=\"text/javascript\" src=\"echarts.min.js\"></script>\n  <script type=\"text/javascript\">\n    var dom = document.getElementById(\"container\");\n    var myChart = echarts.init(dom);\n    var app = {};\n\n    var option;\n\n    option = {\n      backgroundColor: 'transparent',\n\n      series: [\n        {\n          type: 'gauge',\n          axisLine: {\n            lineStyle: {\n              width: 15,\n              color: [\n                [0.3, '#67e0e3'],\n                [0.7, '#37a2da'],\n                [1, '#fd666d']\n              ]\n            }\n          },\n          min: 0,\n      max: 3,\n          pointer: {\n            itemStyle: {\n              color: 'auto'\n            }\n          },\n          axisTick: {//轴刻度\n            distance: -15,\n            length: 8,\n            lineStyle: {\n              color: '#fff',\n              width: 2\n            }\n          },\n          splitLine: {\n            distance: -15,\n            length: 15,\n            lineStyle: {\n              color: '#fff',\n              width: 2\n            }\n          },\n          axisLabel: {\n            color: 'auto',\n            distance: 20,\n            fontSize: 12\n          },\n          detail: {//pue显示\n            valueAnimation: true,\n            formatter: 'PUE={value}  ',\n            color: 'green',\n            fontSize: 20\n          },\n          data: [\n            {\n              value: 99.999,\n              min: 0,\n              max: 3\n            }\n          ]\n        }\n      ]\n    };\n\n\n    \n\n    oaJsApi.dpConnect('System1:PueReceive.PUEreceive:_original.._value', true,\n      {\n        success: function (data) {\n          var newF = data.value[0];\n          var test = formatFloat(newF, n = 1,'floor');\n          console.log(\"自建方法\",test);\n          console.log(\"print\",newF);\n          \n          myChart.setOption({\n            series: [\n              {\n                data: [\n                  {\n                    value:test,\n                  }\n                ]\n              }\n            ]\n          });\n\n        }\n      });\n\n\n    if (option && typeof option === 'object') {\n      myChart.setOption(option);\n    }\n\n    function formatFloat(num, n = 1, flag) {\n    var f = parseFloat(num);\n    if (isNaN(f)) {\n        return false;\n    }\n    if (flag === 'ceil') {\n        f = Math.ceil(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    } else if (flag === 'floor') {\n        f = Math.floor(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    } else {\n        f = Math.round(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\n    }\n    var s = f.toString();\n    var rs = s.indexOf('.');\n    //判定如果是整数，增加小数点再补0\n    if (rs < 0) {\n        rs = s.length;\n        s += '.';\n    }\n    while (s.length <= rs + n) {\n        s += '0';\n    }\n    return s;\n    }\n\n  </script>\n  <script>\n\n  </script>\n\n</body>\n\n</html>\n```\n\n在网上找到一个针对小数点后取值解释比较好的帖子\n\n\n\n[JS - 控制小数位数的方法（保留小数点后N位、以及小数取整）](https://www.cnblogs.com/NazLee/p/11646023.html)\n\n\n\n\n\n开发中有时我们需要对小数进行取整，或者只保留 N 位小数进行显示。下面分别对这两种情况进行说明。这里假设我们有如下数字进行处理：\n\n```html\nvar num = 5/3;\nconsole.log(num);\n```\n\n \n\n输出如下：\n\n[![原文:JS - 控制小数位数的方法（保留小数点后N位、以及小数取整）](assets/获取小数点后一位且不进行四舍五入/2017091514272519762.png)](https://www.hangge.com/blog/cache/detail_1791.html#)\n\n \n\n## 一、取整\n\n### 1，直接取整（丢弃小数部分）\n\n```javascript\nvar num = parseInt(5/3);  // 1\n```\n\n \n\n### 2，四舍五入取整\n\n```javascript\nvar num = Math.round(5/3); ``// 2\n```\n\n \n\n### 3，向上取整\n\n```javascript\nvar num = Math.ceil(5/3);   // 2\n```\n\n \n\n### 4，向下取整\n\n```javascript\nvar num = Math.floor(5/3);  // 1\n```\n\n \n\n## 二、保留小数点后N位\n\n### 1，使用 toFixed() 方法\n\n（1）方法介绍\n\n- toFixed() 方法可以将数字转换为字符串，并指定小数点后保留几位。如果小数实际位数不够指定的位数，不足的部分会补 0。所有主要浏览器都支持 toFixed() 方法。\n- toFixed() 使用的是银行家舍入规则：四舍六入五取偶（又称四舍六入五留双）。\n\n银行家舍入法：\n四舍六入五考虑，五后非零就进一，五后为零看奇偶，五前为偶应舍去，五前为奇要进一。\n\n \n\n（2）使用样例\n\n```javascript\nvar  num1 = (5/3).toFixed(2);  // 1.67 \nvar num2 = (4).toFixed(2); // 4.00\nvar num3 = (0.015).toFixed(2); // 0.01 \nvar num4 = (0.025).toFixed(2); // 0.03\n```\n\n \n\n### 2，自定义转换方法\n\n（1）如果嫌 toFixed 这种四舍六入五取偶规则太奇葩。可以考虑自己实现个四舍五入的方法，下面方法转换后仍为数字类型。\n\n- 第一个参数为待转换的数字\n- 第二个参数为保留的小数个数\n\n```javascript\n//保留n位小数 \nfunction roundFun(value, n) \n{ \nreturn Math.round(value*Math.pow(10,n))/Math.pow(10,n); \n}\n```\n\n\n（2）使用样例\n\n```javascript\nvar num1 = roundFun(5/3, 2);  // 1.67\nvar num2 = roundFun(4, 2); // 4 \nvar num3 = roundFun(0.015, 2);  // 0.02  \nvar num4 = roundFun(0.025, 2);  // 0.03\n```\n\n\n\n### 3，自定义格式化输出方法\n\n（1）下面方法同样是指定小数位数进行四舍五入，不过返回的不再是数字而是格式化后的字符串，小数点后面不足的位数会自动补 0。比如数字为 4，会在 4 后面补上 00，变成 4.00 返回。\n\n```javascript\n//保留n位小数并格式化输出（不足的部分补0） \nvar fomatFloat =  function (value, n) {\nvar f = Math.round(value*Math.pow(10,n))/Math.pow(10,n);\nvar s = f.toString();\nvar rs = s.indexOf( '.' );  \n    if (rs < 0)  {   \n      s += '.' ; \n    }\n    for ( var i = s.length - s.indexOf( '.' ) ; i <= n ; i++){ \n        s +=  \"0\" ; \n    } \n\treturn s;\n}\n```\n\n \n\n（2）使用样例\n\n```javascript\nvar num1 = fomatFloat(5/3, 2);  // 1.67\nvar num2 = fomatFloat(4, 2); // 4.00\nvar num3 = fomatFloat(0.015, 2); // 0.02\nvar num4 = fomatFloat(0.025, 2); // 0.03\n```\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 701,
        "text": "4分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法学习/什么是动态规划.md",
      "title": "什么是动态规划",
      "abstract": "### 一、动态规划的三大步骤\n\n动态规划，无非就是利用**历史记录**，来避免我们的重复计算。而这些**历史记录**，我们得需要一些**变量**来保存，一般是用**一维数组**或者**[二维数组](https://www.zhihu.com/search?q=二维数组&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})**来保存。下面我们先来讲下做动态规划题很重要的三个步骤，\n\n> 如果你听不懂，也没关系，下面会有很多例题讲解，估计你就懂了。之所以不配合例题来讲这些步骤，也是为了怕你们脑袋乱了\n\n**第一步骤**：定义**数组元素的含义**，上面说了，我们会用一个数组，来保存历史数组，假设用一维数组 dp[] 吧。这个时候有一个非常非常重要的点，就是规定你这个数组元素的含义，例如你的 dp[i] 是代表什么意思？\n\n**第二步骤**：找出**数组元素之间的关系式**，我觉得动态规划，还是有一点类似于我们高中学习时的**[归纳法](https://www.zhihu.com/search?q=归纳法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})**的，当我们要计算 dp[n] 时，是可以利用 dp[n-1]，dp[n-2].....dp[1]，来推出 dp[n] 的，也就是可以利用**历史数据**来推出新的元素值，所以我们要找出数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，这个就是他们的关系式了。而这一步，也是最难的一步，后面我会讲几种类型的题来说。\n\n> 学过动态规划的可能都经常听到**最优子结构**，把大的问题拆分成小的问题，说实话，最开始的时候，我是对**[最优子结构](https://www.zhihu.com/search?q=最优子结构&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})**一梦懵逼的。估计你们也听多了，所以这一次，我将**换一种形式来讲，不再是各种子问题，各种最优子结构**。所以大佬可别喷我再乱讲，因为我说了，这是我自己平时做题的套路。\n\n**第三步骤**：找出**初始值**。学过**[数学归纳法](https://www.zhihu.com/search?q=数学归纳法&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})**的都知道，虽然我们知道了数组元素之间的关系式，例如 dp[n] = dp[n-1] + dp[n-2]，我们可以通过 dp[n-1] 和 dp[n-2] 来计算 dp[n]，但是，我们得知道初始值啊，例如一直推下去的话，会由 dp[3] = dp[2] + dp[1]。而 dp[2] 和 dp[1] 是不能再分解的了，所以我们必须要能够直接获得 dp[2] 和 dp[1] 的值，而这，就是**所谓的初始值**。\n\n由了**初始值**，并且有了**数组元素之间的关系式**，那么我们就可以得到 dp[n] 的值了，而 dp[n] 的含义是由你来定义的，你想**求什么，就定义它是什么**，这样，这道题也就解出来了。\n\n**不懂？没事，我们来看三四道例题**，我讲严格按这个步骤来给大家讲解。\n\n### 二、案例详解\n\n### 案例一、简单的一维 DP\n\n> 问题描述：一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。\n\n### (1)、定义数组元素的含义\n\n按我上面的步骤说的，首先我们来定义 dp[i] 的含义，我们的问题是要求青蛙跳上 n 级的台阶总共由多少种跳法，那我们就定义 dp[i] 的含义为：**跳上一个 i 级的台阶总共有 dp[i] 种跳法**。这样，如果我们能够算出 dp[n]，不就是我们要求的答案吗？所以第一步定义完成。\n\n### （2）、找出数组元素间的关系式\n\n我们的目的是要求 dp[n]，动态规划的题，如你们经常听说的那样，就是把一个**规模**比较大的问题分成几个**规模**比较小的问题，然后由小的问题推导出大的问题。也就是说，dp[n] 的规模为 n，比它规模小的是 n-1, n-2, n-3.... 也就是说，dp[n] 一定会和 dp[n-1], dp[n-2]....存在某种关系的。我们要找出他们的关系。\n\n**那么问题来了，怎么找？**\n\n这个怎么找，**是最核心最难的一个**，我们必须回到问题本身来了，来寻找他们的关系式，dp[n] 究竟会等于什么呢？\n\n对于这道题，由于情况可以选择跳一级，也可以选择跳两级，所以青蛙到达第 n 级的台阶有两种方式\n\n一种是从第 n-1 级跳上来\n\n一种是从第 n-2 级跳上来\n\n由于我们是要算**所有可能的跳法的**，所以有 dp[n] = dp[n-1] + dp[n-2]。\n\n### （3）、找出初始条件\n\n当 n = 1 时，dp[1] = dp[0] + dp[-1]，而我们是数组是不允许下标为负数的，所以对于 dp[1]，我们必须要**直接给出它的数值**，相当于初始值，显然，dp[1] = 1。一样，dp[0] = 0（0 个台阶，有人说是0种跳法，有人说是1种，我们暂时当作0种处理吧，不过无论哪种，都不影响问题都思路哈）。于是得出初始值：\n\ndp[0] = 0. dp[1] = 1. 即 n <= 1时，dp[n] = n\n\n三个步骤都做出来了，那么我们就来写代码吧，代码会详细注释滴。\n\n```java\nint f( int n ){\n    if(n <= 1)\n    return n;\n    // 先创建一个数组来保存历史数据\n    int[] dp = new int[n+1];\n    // 给出初始值\n    dp[0] = 0;\n    dp[1] = 1;\n    // 通过关系式来计算出 dp[n]\n    for(int i = 2; i <= n; i++){\n        dp[i] = dp[i-1] + dp[i-2];\n    }\n    // 把最终结果返回\n    return dp[n];\n}\n```\n\n### （4）、再说初始化\n\n大家先想以下，你觉得，上面的代码有没有问题？\n\n答是有问题的，还是错的，错在**对初始值的寻找不够严谨**，这也是我故意这样弄的，意在告诉你们，关于**初始值的严谨性**。例如对于上面的题，当 n = 2 时，dp[2] = dp[1] + dp[0] = 1。这显然是错误的，你可以模拟一下，应该是 dp[2] = 2。\n\n也就是说，在寻找初始值的时候，一定要注意不要找漏了，dp[2] 也算是一个初始值，不能通过公式计算得出。有人可能会说，我想不到怎么办？这个很好办，多做几道题就可以了。\n\n> 下面我再列举三道不同的例题，并且，再在未来的文章中，我也会持续按照这个步骤，给大家找几道有难度且类型不同的题。下面这几道例题，不会讲的特性详细哈。实际上 ，上面的一维数组是可以把空间优化成更小的，不过我们现在先不讲优化的事，下面的题也是，不讲优化版本。\n\n### 案例二：二维数组的 DP\n\n我做了几十道 DP 的算法题，可以说，80% 的题，都是要用二维数组的，所以下面的题主要以二维数组为主，当然有人可能会说，要用一维还是二维，我怎么知道？这个问题不大，接着往下看。\n\n### 问题描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n\n\n![img](assets/什么是动态规划/v2-ae8382594927d2660a20b56cb1d5401d_720w.webp)\n\n\n\n> 这是 leetcode 的 62 号题：https://leetcode-cn.com/problems/unique-paths/\n\n还是老样子，三个步骤来解决。\n\n### 步骤一、定义数组元素的含义\n\n由于我们的目的是从左上角到右下角一共有多少种路径，那我们就定义 dp[i] [j]的含义为：**当机器人从左上角走到(i, j) 这个位置时，一共有 dp[i] [j] 种路径**。那么，dp[m-1] [n-1] 就是我们要的答案了。\n\n> 注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 右下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要找的答案。\n\n### 步骤二：找出关系数组元素间的关系式\n\n想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达\n\n一种是从 (i-1, j) 这个位置走一步到达\n\n一种是从(i, j - 1) 这个位置走一步到达\n\n因为是计算所有可能的步骤，所以是把所有可能走的路径都加起来，所以关系式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]。\n\n### 步骤三、找出初始值\n\n显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：\n\ndp[0] [0….n-1] = 1; // 相当于最上面一行，机器人只能一直往左走\n\ndp[0…m-1] [0] = 1; // 相当于最左面一列，机器人只能一直往下走\n\n### 撸代码\n\n三个步骤都写出来了，直接看代码\n\n```java\npublic static int uniquePaths(int m, int n) {\n    if (m <= 0 || n <= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n]; // \n    // 初始化\n    for(int i = 0; i < m; i++){\n      dp[i][0] = 1;\n    }\n    for(int i = 0; i < n; i++){\n      dp[0][i] = 1;\n    }\n        // 推导出 dp[m-1][n-1]\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\n> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲\n\n### 案例三、二维数组 DP\n\n写到这里，有点累了，，但还是得写下去，所以看的小伙伴，你们可得继续看呀。下面这道题也不难，比上面的难一丢丢，不过也是非常类似\n\n### 问题描述\n\n给定一个包含[非负整数](https://www.zhihu.com/search?q=非负整数&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})的 *m* x *n* 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。\n\n**说明：**每次只能向下或者向右移动一步。\n\n```java\n举例：\n输入:\narr = [\n  [1,3,1],\n  [1,5,1],\n  [4,2,1]\n]\n输出: 7\n解释: 因为路径 1→3→1→1→1 的总和最小。\n```\n\n和上面的差不多，不过是算最优路径和，这是 leetcode 的第64题：https://leetcode-cn.com/problems/minimum-path-sum/\n\n> 还是老样子，可能有些人都看烦了，哈哈，但我还是要按照步骤来写，让那些不大懂的加深理解。有人可能觉得，这些题太简单了吧，别慌，小白先入门，这些属于 medium 级别的，后面在给几道 hard 级别的。\n\n### 步骤一、定义数组元素的含义\n\n由于我们的目的是从左上角到右下角，最小路径和是多少，那我们就定义 dp[i] [j]的含义为：**当机器人从左上角走到(i, j) 这个位置时，最下的路径和是 dp[i] [j]**。那么，dp[m-1] [n-1] 就是我们要的答案了。\n\n> 注意，这个网格相当于一个二维数组，数组是从下标为 0 开始算起的，所以 由下角的位置是 (m-1, n - 1)，所以 dp[m-1] [n-1] 就是我们要走的答案。\n\n### 步骤二：找出关系数组元素间的关系式\n\n想象以下，机器人要怎么样才能到达 (i, j) 这个位置？由于机器人可以向下走或者向右走，所以有两种方式到达\n\n一种是从 (i-1, j) 这个位置走一步到达\n\n一种是从(i, j - 1) 这个位置走一步到达\n\n不过这次不是计算所有可能路径，而是**计算哪一个路径和是最小的**，那么我们要从这两种方式中，选择一种，使得dp[i] [j] 的值是最小的，显然有\n\n```java\ndp[i] [j] = min(dp[i-1][j]，dp[i][j-1]) + arr[i][j];// arr[i][j] 表示网格种的值\n```\n\n### 步骤三、找出初始值\n\n显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n-1] 和所有的 dp[0….m-1] [0]。这个还是非常容易计算的，相当于计算机图中的最上面一行和左边一列。因此初始值如下：\n\ndp[0] [j] = arr[0] [j] + dp[0] [j-1]; // 相当于最上面一行，机器人只能一直往左走\n\ndp[i] [0] = arr[i] [0] + dp[i] [0]; // 相当于最左面一列，机器人只能一直往下走\n\n### 代码如下\n\n```java\npublic static int uniquePaths(int[][] arr) {\n    int m = arr.length;\n    int n = arr[0].length;\n    if (m <= 0 || n <= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n]; // \n    // 初始化\n    dp[0][0] = arr[0][0];\n    // 初始化最左边的列\n    for(int i = 1; i < m; i++){\n      dp[i][0] = dp[i-1][0] + arr[i][0];\n    }\n    // 初始化最上边的行\n    for(int i = 1; i < n; i++){\n      dp[0][i] = dp[0][i-1] + arr[0][i];\n    }\n        // 推导出 dp[m-1][n-1]\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = Math.min(dp[i-1][j], dp[i][j-1]) + arr[i][j];\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\n> O(n*m) 的空间复杂度可以优化成 O(min(n, m)) 的空间复杂度的，不过这里先不讲\n\n### 案例 4：[编辑距离](https://www.zhihu.com/search?q=编辑距离&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})\n\n这次给的这道题比上面的难一些，在 leetcdoe 的定位是 hard 级别。好像是 leetcode 的第 72 号题。\n\n**问题描述**\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符 删除一个字符 替换一个字符\n\n```java\n示例：\n输入: word1 = \"horse\", word2 = \"ros\"\n输出: 3\n解释: \nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**解答**\n\n还是老样子，按照上面三个步骤来，并且我这里可以告诉你，90% 的字符串问题都可以用动态规划解决，并且90%是采用二维数组。\n\n### 步骤一、定义数组元素的含义\n\n由于我们的目的求将 word1 转换成 word2 所使用的最少操作数 。那我们就定义 dp[i] [j]的含义为：**当字符串 word1 的长度为 i，字符串 word2 的长度为 j 时，将 word1 转化为 word2 所使用的最少操作次数为 dp[i] [j]**。\n\n> 有时候，数组的含义并不容易找，所以还是那句话，我给你们一个套路，剩下的还得看你们去领悟。\n\n### 步骤二：找出关系数组元素间的关系式\n\n接下来我们就要找 dp[i] [j] 元素之间的关系了，比起其他题，这道题相对比较难找一点，但是，不管多难找，大部分情况下，dp[i] [j] 和 dp[i-1] [j]、dp[i] [j-1]、dp[i-1] [j-1] 肯定存在某种关系。因为我们的目标就是，**从规模小的，通过一些操作，推导出规模大的。对于这道题，我们可以对 word1 进行三种操作\n\n插入一个字符 删除一个字符 替换一个字符\n\n由于我们是要让操作的次数最小，所以我们要寻找最佳操作。那么有如下关系式：\n\n一、如果我们 word1[i] 与 word2 [j] 相等，这个时候不需要进行任何操作，显然有 dp[i] [j] = dp[i-1] [j-1]。（别忘了 dp[i] [j] 的含义哈）。\n\n二、如果我们 word1[i] 与 word2 [j] 不相等，这个时候我们就必须进行调整，而调整的操作有 3 种，我们要选择一种。三种操作对应的关系试如下（注意字符串与字符的区别）：\n\n（1）、如果把字符 word1[i] 替换成与 word2[j] 相等，则有 dp[i] [j] = dp[i-1] [j-1] + 1;\n\n（2）、如果在字符串 word1末尾插入一个与 word2[j] 相等的字符，则有 dp[i] [j] = dp[i] [j-1] + 1;\n\n（3）、如果把字符 word1[i] 删除，则有 dp[i] [j] = dp[i-1] [j] + 1;\n\n那么我们应该选择一种操作，使得 dp[i] [j] 的值最小，显然有\n\n**dp[i] [j] = min(dp[i-1] [j-1]，dp[i] [j-1]，dp[[i-1] [j]]) + 1;**\n\n于是，我们的关系式就推出来了，\n\n### 步骤三、找出初始值\n\n显然，当 dp[i] [j] 中，如果 i 或者 j 有一个为 0，那么还能使用关系式吗？答是不能的，因为这个时候把 i - 1 或者 j - 1，就变成负数了，数组就会出问题了，所以我们的初始值是计算出所有的 dp[0] [0….n] 和所有的 dp[0….m] [0]。这个还是非常容易计算的，因为当有一个字符串的长度为 0 时，转化为另外一个字符串，那就只能一直进行插入或者删除操作了。\n\n### 代码如下\n\n```java\npublic int minDistance(String word1, String word2) {\n    int n1 = word1.length();\n    int n2 = word2.length();\n    int[][] dp = new int[n1 + 1][n2 + 1];\n    // dp[0][0...n2]的初始值\n    for (int j = 1; j <= n2; j++) \n        dp[0][j] = dp[0][j - 1] + 1;\n    // dp[0...n1][0] 的初始值\n    for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;\n        // 通过公式推出 dp[n1][n2]\n    for (int i = 1; i <= n1; i++) {\n        for (int j = 1; j <= n2; j++) {\n            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)){\n                p[i][j] = dp[i - 1][j - 1];\n            }else {\n               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;\n            }         \n        }\n    }\n    return dp[n1][n2];  \n}\n```\n\n最后说下，如果你要练习，可以去 leetcode，选择动态规划专题，然后连续刷几十道，保证你以后再也不怕动态规划了。当然，遇到很难的，咱还是得挂。\n\nLeetcode 动态规划直达：https://leetcode-cn.com/tag/dynamic-programming/\n\n### 三、如何优化？\n\n前两天写一篇长达 8000 子的关于**动态规划**的文章[告别动态规划，连刷40道动规算法题，我总结了动规的套路](https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw)\n\n这篇文章更多讲解我平时做题的套路，不过由于篇幅过长，举了 4 个案例之后，没有讲解优化，今天这篇文章就来讲解下，对动态规划的优化如何下手，并且以前几天那篇文章的题作为例子直接讲优化，如果没看过的建议看一下（不看也行，我会直接给出题目以及没有优化前的代码）：[告别动态规划，连刷40道动规算法题，我总结了动规的套路](https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw)\n\n### 四、优化核心：画图！画图！画图\n\n没错，80% 的动态规划题都可以画图，其中 80% 的题都可以通过画图一下子知道怎么优化，当然，DP 也有一些很难的题，想优化可没那么容易，不过，今天我要讲的，是属于不怎么难，且最常见，面试笔试最经常考的难度的题。\n\n下面我们直接通过三道题目来讲解优化，你会发现，这些题，优化过后，代码只有细微的改变，你只要会一两道，可以说是会了 80% 的题。\n\n### O(n*m) 空间复杂度优化成 O(n)\n\n上次那个青蛙跳台阶的 dp 题是可以把空间复杂度 O( n) 优化成 O(1)，本来打算从这道题讲起的，但想了下，想要学习 dp 优化的感觉至少都是 **小小大佬**了，所以就不讲了，就从二维数组的 dp 讲起。\n\n### 案例1：最多路径数\n\n### 问题描述\n\n一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。\n\n机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。\n\n问总共有多少条不同的路径？\n\n\n\n![img](assets/什么是动态规划/v2-ae8382594927d2660a20b56cb1d5401d_720w.webp)\n\n\n\n> 这是 leetcode 的 62 号题：https://leetcode-cn.com/problems/unique-paths/\n\n这道题的 dp 转移公式是 dp[i] [j] = dp[i-1] [j] + dp[i] [j-1]，代码如下\n\n> 不懂的看我之前文章：[告别动态规划，连刷40道动规算法题，我总结了动规的套路](https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw)\n\n```java\npublic static int uniquePaths(int m, int n) {\n    if (m <= 0 || n <= 0) {\n        return 0;\n    }\n\n    int[][] dp = new int[m][n]; // \n    // 初始化\n    for(int i = 0; i < m; i++){\n      dp[i][0] = 1;\n    }\n    for(int i = 0; i < n; i++){\n      dp[0][i] = 1;\n    }\n        // 推导出 dp[m-1][n-1]\n    for (int i = 1; i < m; i++) {\n        for (int j = 1; j < n; j++) {\n            dp[i][j] = dp[i-1][j] + dp[i][j-1];\n        }\n    }\n    return dp[m-1][n-1];\n}\n```\n\n这种做法的空间复杂度是 O(n * m)，下面我们来讲解如何优化成 O(n)。\n\ndp[i] [j] 是一个二维矩阵，我们来画个二维矩阵的图，对矩阵进行初始化\n\n\n\n![img](assets/什么是动态规划/v2-04bc10adf68ccaf73fef7bf496953b7c_720w.webp)\n\n然后根据公式 dp[i][j] = dp[i-1][j] + dp[i][j-1] 来填充矩阵的其他值。下面我们先填充第二行的值。\n\n![img](assets/什么是动态规划/v2-0359e28b955e86391a2d776a4f776a4f_720w.jpeg)\n\n大家想一个问题，**当我们要填充第三行的值的时候，我们需要用到第一行的值吗？**答是不需要的，不行你试试，当你要填充第三，第四....第 n 行的时候，第一行的值永远不会用到，只要填充第二行的值时会用到。\n\n根据公式 dp[i][j] = dp[i-1][j] + dp[i][j-1]，我们可以知道，当我们要计算第 i 行的值时，**除了会用到第 i - 1 行外，其他第 1 至 第 i-2 行的值我们都是不需要用到的**，也就是说，对于那部分用不到的值我们还有必要保存他们吗？\n\n答是没必要，我们只需要用一个一维的 dp[] 来保存**一行**的历史记录就可以了。然后在计算机的过程中，不断着更新 dp[] 的值。单说估计你可能不好理解，下面我就手把手来演示下这个过程。\n\n1、刚开始初始化第一行，此时 dp[0..n-1] 的值就是第一行的值。\n\n![img](assets/什么是动态规划/v2-04bc10adf68ccaf73fef7bf496953b7c_720w-1676301973866-1.webp)\n\n\n\n2、接着我们来一边填充第二行的值一边更新 dp[i] 的值，一边把第一行的值抛弃掉。\n\n> 为了方便描述，下面我们用arr (i，j）表示矩阵中第 i 行 第 j 列的值。从 0 开始哈，就是说有第 0 行。\n\n（1）、显然，矩阵(1, 0) 的值相当于以往的初始化值，为 1。然后这个时候矩阵 (0，0）的值不在需要保存了，因为再也用不到了。\n\n![img](assets/什么是动态规划/v2-f9e89955a62a15509c23d8ad142384cd_720w.jpeg)\n\n这个时候，我们也要跟着更新 dp[0] 的值了，刚开始 dp[0] = (0, 0)，现在更新为 dp[0] = (1, 0)。\n\n（2）、接着继续更新 (1, 1) 的值，根据之前的公式 （i, j) = (i-1, j) + (i, j- 1)。即 （1，1）=（0，1）+（1，0）=2。\n\n![img](assets/什么是动态规划/v2-639b6b510b429855c53b3c688e3cd588_720w.webp)\n\n大家看图，以往的二维的时候， dp[i][j] = dp[i-1] [j]+ dp[i][j-1]。现在转化成一维，不就是 **dp[i] = dp[i] + dp[i-1]** 吗？\n\n即 dp[1] = dp[1] + dp[0]，而且还动态帮我们更新了 dp[1] 的值。因为刚开始 dp[i] 的保存第一行的值的，现在更新为保存第二行的值。\n\n![img](assets/什么是动态规划/v2-c9168e86d57a7f018c4a205abfac2978_720w.webp)\n\n(3)、同样的道理，按照这样的模式一直来计算第二行的值，顺便把第一行的值抛弃掉，结果如下\n\n![img](assets/什么是动态规划/v2-928867f1120cadc10300e49f7786f491_720w.webp)\n\n此时，dp[i] 将完全保存着第二行的值，并且我们可以推导出公式\n\ndp[i] = dp[i-1] + dp[i]\n\n> dp[i-1] 相当于之前的 dp[i-1][j]，dp[i] 相当于之前的 dp[i][j-1]。\n\n于是按照这个公式不停着填充到最后一行，结果如下：\n\n![img](assets/什么是动态规划/v2-94ac15c606c7477450738a8c13680b99_720w.webp)\n\n最后 dp[n-1] 就是我们要求的结果了。所以优化之后，代码如下：\n\n```java\npublic static int uniquePaths(int m, int n) {\n    if (m <= 0 || n <= 0) {\n        return 0;\n    }\n\n    int[] dp = new int[n]; // \n    // 初始化\n    for(int i = 0; i < n; i++){\n      dp[i] = 1;\n    }\n\n        // 公式：dp[i] = dp[i-1] + dp[i]\n    for (int i = 1; i < m; i++) {\n        // 第 i 行第 0 列的初始值\n        dp[0] = 1;\n        for (int j = 1; j < n; j++) {\n            dp[j] = dp[j-1] + dp[j];\n        }\n    }\n    return dp[n-1];\n}\n```\n\n### 案例2：编辑距离\n\n接着我们来看昨天的另外一道题，就是**编辑矩阵**，这道题的优化和这一道有一点点的不同，上面这道 dp[i][j] 依赖于 dp[i-1][j] 和 dp[i][j-1]。而还有一种情况就是 dp[i][j] 依赖于 dp[i-1][j]，dp[i-1][j-1] 和 dp[i][j-1]。\n\n**问题描述**\n\n给定两个单词 word1 和 word2，计算出将 word1 转换成 word2 所使用的最少操作数 。\n\n你可以对一个单词进行如下三种操作：\n\n插入一个字符 删除一个字符 替换一个字符\n\n```java\n示例：\n输入: word1 = \"horse\", word2 = \"ros\"\n输出: 3\n解释: \nhorse -> rorse (将 'h' 替换为 'r')\nrorse -> rose (删除 'r')\nrose -> ros (删除 'e')\n```\n\n**解答**\n\n昨天的代码如下所示，不懂的记得看之前的文章哈：[告别动态规划，连刷40道动规算法题，我总结了动规的套路](https://mp.weixin.qq.com/s/pg-IJ8rA1duIzt5hW1Cycw)\n\n```java\npublic int minDistance(String word1, String word2) {\n    int n1 = word1.length();\n    int n2 = word2.length();\n    int[][] dp = new int[n1 + 1][n2 + 1];\n    // dp[0][0...n2]的初始值\n    for (int j = 1; j <= n2; j++) \n        dp[0][j] = dp[0][j - 1] + 1;\n    // dp[0...n1][0] 的初始值\n    for (int i = 1; i <= n1; i++) dp[i][0] = dp[i - 1][0] + 1;\n        // 通过公式推出 dp[n1][n2]\n    for (int i = 1; i <= n1; i++) {\n        for (int j = 1; j <= n2; j++) {\n            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)){\n                p[i][j] = dp[i - 1][j - 1];\n            }else {\n               dp[i][j] = Math.min(Math.min(dp[i - 1][j - 1], dp[i][j - 1]), dp[i - 1][j]) + 1;\n            }         \n        }\n    }\n    return dp[n1][n2];  \n}\n```\n\n> 没有优化之间的空间复杂度为 O(n*m)\n\n大家可以自己动手做下，按照上面的那个模式，你会优化吗？\n\n![img](assets/什么是动态规划/v2-0dd7f74fa3ddf11921484f3fab4d2108_720w.webp)\n\n对于这道题其实也是一样的，如果要计算 第 i 行的值，我们最多只依赖第 i-1 行的值，不需要用到第 i-2 行及其以前的值，所以一样可以采用一维 dp 来处理的。\n\n不过这个时候要注意，在上面的例子中，我们每次更新完 (i, j) 的值之后，就会把 (i, j-1) 的值抛弃，也就是说之前是一边更新 dp[i] 的值，一边把 dp[i] 的旧值抛弃的，不过在这道题中则不可以，因为我们还需要用到它。\n\n哎呀，直接举例子看图吧，文字绕来绕去估计会绕晕你们。当我们要计算图中 (i,j) 的值的时候，在案例1 中，我们值需要用到 (i-1, j) 和 (i, j-1)。（看图中方格的颜色）\n\n![img](assets/什么是动态规划/v2-68700c96d697db50cb33d1b6cf611123_720w.webp)\n\n不过这道题中，我们还需要用到 （i-1, j-1) 这个值（但是这个值在以往的案例1 中，它会被抛弃掉）\n\n![img](assets/什么是动态规划/v2-e419dbed2c8c5d5a482a17568ffd7304_720w.webp)\n\n**所以呢，对于这道题，我们还需要一个额外的变量 pre 来时刻保存 (i-1,j-1) 的值**。推导公式就可以从二维的\n\n```text\ndp[i][j] = min(dp[i-1][j] , dp[i-1][j-1] , dp[i][j-1]) + 1\n```\n\n转化为一维的\n\n```text\ndp[i] = min(dp[i-1], pre, dp[i]) + 1。\n```\n\n所以呢，案例2 其实和案例1 差别不大，就是多了个变量来临时保存。最终代码如下（但是初学者话，代码也没那么好写）\n\n### 代码如下\n\n```java\npublic int minDistance(String word1, String word2) {\n    int n1 = word1.length();\n    int n2 = word2.length();\n    int[] dp = new int[n2 + 1];\n    // dp[0...n2]的初始值\n    for (int j = 0; j <= n2; j++) \n        dp[j] = j;\n    // dp[j] = min(dp[j-1], pre, dp[j]) + 1\n    for (int i = 1; i <= n1; i++) {\n        int temp = dp[0];\n        // 相当于初始化\n        dp[0] = i;\n        for (int j = 1; j <= n2; j++) {\n            // pre 相当于之前的 dp[i-1][j-1]\n            int pre = temp;\n            temp = dp[j];\n            // 如果 word1[i] 与 word2[j] 相等。第 i 个字符对应下标是 i-1\n            if (word1.charAt(i - 1) == word2.charAt(j - 1)){\n                dp[j] = pre;\n            }else {\n               dp[j] = Math.min(Math.min(dp[j - 1], pre), dp[j]) + 1;\n            } \n            // 保存要被抛弃的值       \n        }\n    }\n    return dp[n2]; \n}\n```\n\n### 总结\n\n上面的这些题，基本都是不怎么难的入门题，除了最后一道相对难一点。并且基本 80% 的二维矩阵 dp 都可以像上面的方法一样优化成 一维矩阵的 dp，核心就是要画图，看他们的**值依赖**，当然，还有很多其他比较难的优化，但是，我遇到的题中，大部分都是我上面这种类型的优化。后面如何遇到其他的，我会作为案例来讲，今天就先讲**最普遍最通用的优化方案**。记住，画二维 dp 的[矩阵图](https://www.zhihu.com/search?q=矩阵图&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra={\"sourceType\"%3A\"answer\"%2C\"sourceId\"%3A1094101149})，然后看元素之间的值依赖，然后就可以很清晰着知道该如何优化了。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法学习",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1770,
        "text": "9分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法学习/算法的时间与空间复杂度.md",
      "title": "算法的时间与空间复杂度",
      "abstract": "算法（Algorithm）是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终得到的结果是一样的，但在过程中消耗的资源和时间却会有很大的区别。\r\n\r\n那么我们应该如何去衡量不同算法之间的优劣呢？\r\n\r\n主要还是从算法所占用的「时间」和「空间」两个维度去考量。\r\n\r\n- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。\r\n- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。\r\n\r\n因此，评价一个算法的效率主要是看它的时间复杂度和空间复杂度情况。然而，有的时候时间和空间却又是「鱼和熊掌」，不可兼得的，那么我们就需要从中去取一个平衡点。\r\n\r\n下面我来分别介绍一下「时间复杂度」和「空间复杂度」的计算方式。\r\n\r\n## **一、时间复杂度**\r\n\r\n我们想要知道一个算法的「时间复杂度」，很多人首先想到的的方法就是把这个算法程序运行一遍，那么它所消耗的时间就自然而然知道了。\r\n\r\n这种方式可以吗？当然可以，不过它也有很多弊端。\r\n这种方式非常容易受运行环境的影响，在性能高的机器上跑出来的结果与在性能低的机器上跑的结果相差会很大。而且对测试时使用的数据规模也有很大关系。再者，并我们在写算法的时候，还没有办法完整的去运行呢。\r\n\r\n因此，另一种更为通用的方法就出来了：「 **大O符号表示法** 」，即 T(n) = O(f(n))\r\n\r\n我们先来看个例子：\r\n\r\n```text\r\nfor(i=1; i<=n; ++i)\r\n{\r\n   j = i;\r\n   j++;\r\n}\r\n```\r\n\r\n通过「 大O符号表示法 」，这段代码的时间复杂度为：O(n) ，为什么呢?\r\n\r\n在 大O符号表示法中，时间复杂度的公式是： T(n) = O( f(n) )，其中f(n) 表示每行代码执行次数之和，而 O 表示正比例关系，这个公式的全称是：**算法的渐进时间复杂度**。\r\n\r\n我们继续看上面的例子，假设每行代码的执行时间都是一样的，我们用 1颗粒时间 来表示，那么这个例子的第一行耗时是1个颗粒时间，第三行的执行时间是 n个颗粒时间，第四行的执行时间也是 n个颗粒时间（第二行和第五行是符号，暂时忽略），那么总时间就是 1颗粒时间 + n颗粒时间 + n颗粒时间 ，即 (1+2n)个颗粒时间，即： T(n) = (1+2n)*颗粒时间，从这个结果可以看出，这个算法的耗时是随着n的变化而变化，因此，我们可以简化的将这个算法的时间复杂度表示为：T(n) = O(n)\r\n\r\n为什么可以这么去简化呢，因为大O符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。\r\n\r\n所以上面的例子中，如果n无限大的时候，T(n) = time(1+2n)中的常量1就没有意义了，倍数2也意义不大。因此直接简化为T(n) = O(n) 就可以了。\r\n\r\n常见的时间复杂度量级有：\r\n\r\n- 常数阶O(1)\r\n- 对数阶O(logN)\r\n- 线性阶O(n)\r\n- 线性对数阶O(nlogN)\r\n- 平方阶O(n²)\r\n- 立方阶O(n³)\r\n- K次方阶O(n^k)\r\n- 指数阶(2^n)\r\n\r\n上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。\r\n\r\n下面选取一些较为常用的来讲解一下（没有严格按照顺序）：\r\n\r\n1. **常数阶O(1)**\r\n\r\n无论代码执行了多少行，只要是没有循环等复杂结构，那这个代码的时间复杂度就都是O(1)，如：\r\n\r\n```text\r\nint i = 1;\r\nint j = 2;\r\n++i;\r\nj++;\r\nint m = i + j;\r\n```\r\n\r\n上述代码在执行的时候，它消耗的时候并不随着某个变量的增长而增长，那么无论这类代码有多长，即使有几万几十万行，都可以用O(1)来表示它的时间复杂度。\r\n\r\n1. **线性阶O(n)**\r\n\r\n这个在最开始的代码示例中就讲解过了，如：\r\n\r\n```text\r\nfor(i=1; i<=n; ++i)\r\n{\r\n   j = i;\r\n   j++;\r\n}\r\n```\r\n\r\n这段代码，for循环里面的代码会执行n遍，因此它消耗的时间是随着n的变化而变化的，因此这类代码都可以用O(n)来表示它的时间复杂度。\r\n\r\n1. **对数阶O(logN)**\r\n\r\n还是先来看代码：\r\n\r\n```text\r\nint i = 1;\r\nwhile(i<n)\r\n{\r\n    i = i * 2;\r\n}\r\n```\r\n\r\n从上面代码可以看到，在while循环里面，每次都将 i 乘以 2，乘完之后，i 距离 n 就越来越近了。我们试着求解一下，假设循环x次之后，i 就大于 2 了，此时这个循环就退出了，也就是说 2 的 x 次方等于 n，那么 x = log2^n\r\n也就是说当循环 log2^n 次以后，这个代码就结束了。因此这个代码的时间复杂度为：**O(logn)**\r\n\r\n1. **线性对数阶O(nlogN)**\r\n\r\n线性对数阶O(nlogN) 其实非常容易理解，将时间复杂度为O(logn)的代码循环N遍的话，那么它的时间复杂度就是 n * O(logN)，也就是了O(nlogN)。\r\n\r\n就拿上面的代码加一点修改来举例：\r\n\r\n```text\r\nfor(m=1; m<n; m++)\r\n{\r\n    i = 1;\r\n    while(i<n)\r\n    {\r\n        i = i * 2;\r\n    }\r\n}\r\n```\r\n\r\n1. **平方阶O(n²)**\r\n\r\n平方阶O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。\r\n举例：\r\n\r\n```text\r\nfor(x=1; i<=n; x++)\r\n{\r\n   for(i=1; i<=n; i++)\r\n    {\r\n       j = i;\r\n       j++;\r\n    }\r\n}\r\n```\r\n\r\n这段代码其实就是嵌套了2层n循环，它的时间复杂度就是 O(n*n)，即 O(n²)\r\n如果将其中一层循环的n改成m，即：\r\n\r\n```text\r\nfor(x=1; i<=m; x++)\r\n{\r\n   for(i=1; i<=n; i++)\r\n    {\r\n       j = i;\r\n       j++;\r\n    }\r\n}\r\n```\r\n\r\n那它的时间复杂度就变成了 O(m*n)\r\n\r\n1. **立方阶O(n³)**、**K次方阶O(n^k)**\r\n\r\n参考上面的O(n²) 去理解就好了，O(n³)相当于三层n循环，其它的类似。\r\n\r\n除此之外，其实还有 平均时间复杂度、均摊时间复杂度、最坏时间复杂度、最好时间复杂度 的分析方法，有点复杂，这里就不展开了。\r\n\r\n## **二、空间复杂度**\r\n\r\n既然时间复杂度不是用来计算程序具体耗时的，那么我也应该明白，空间复杂度也不是用来计算程序实际占用的空间的。\r\n\r\n空间复杂度是对一个算法在运行过程中临时占用存储空间大小的一个量度，同样反映的是一个趋势，我们用 S(n) 来定义。\r\n\r\n空间复杂度比较常用的有：O(1)、O(n)、O(n²)，我们下面来看看：\r\n\r\n1. **空间复杂度 O(1)**\r\n\r\n如果算法执行所需要的临时空间不随着某个变量n的大小而变化，即此算法空间复杂度为一个常量，可表示为 O(1)\r\n举例：\r\n\r\n```text\r\nint i = 1;\r\nint j = 2;\r\n++i;\r\nj++;\r\nint m = i + j;\r\n```\r\n\r\n代码中的 i、j、m 所分配的空间都不随着处理数据量变化，因此它的空间复杂度 S(n) = O(1)\r\n\r\n1. **空间复杂度 O(n)**\r\n\r\n我们先看一个代码：\r\n\r\n```text\r\nint[] m = new int[n]\r\nfor(i=1; i<=n; ++i)\r\n{\r\n   j = i;\r\n   j++;\r\n}\r\n```\r\n\r\n这段代码中，第一行new了一个数组出来，这个数据占用的大小为n，这段代码的2-6行，虽然有循环，但没有再分配新的空间，因此，这段代码的空间复杂度主要看第一行即可，即 S(n) = O(n)",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法学习",
          "link": "#"
        }
      ],
      "stats": {
        "words": 305,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_两个数组的交集 II.md",
      "title": "初级算入门_两个数组的交集 II",
      "abstract": "给你两个整数数组 `nums1` 和 `nums2` ，请你以数组形式返回两数组的交集。返回结果中每个元素出现的次数，应与元素在两个数组中都出现的次数一致（如果出现次数不一致，则考虑取较小值）。可以不考虑输出结果的顺序。\n\n  \n\n**示例 1：**\n\n  \n```bash\n\n输入：nums1 = [1,2,2,1], nums2 = [2,2]\n\n输出：[2,2]\n\n```\n\n  \n\n**示例 2:**\n\n  \n\n```bash\n\n输入：nums1 = [4,9,5], nums2 = [9,4,9,8,4]\n\n输出：[4,9]\n\n```\n\n  \n\n  \n\n**提示：**\n\n  \n\n- `1 <= nums1.length, nums2.length <= 1000`\n\n- `0 <= nums1[i], nums2[i] <= 1000`\n\n  \n\n**代码:**\n\n  \n\n```java\nclass Solution {\n    public int[] intersect(int[] nums1, int[] nums2) {\n        int len1=nums1.length;\n        int len2=nums2.length;\n        int len = len1<len2?len1:len2;\n        int[] mark =new int[len];\n        //排好序\n        Arrays.sort(nums1);\n        Arrays.sort(nums2);\n        int i=0,j=0,k=0;\n\n        while(i<len1 && j<len2){\n            if(nums1[i] == nums2[j]){\n                //相等的时候赋值\n                mark[k] = nums2[j];\n                k++;\n                i++;\n                j++;\n            }else if(nums1[i] < nums2[j]){\n                //如果nums[i]小于nums2[j]i需要右移,左边肯定更小了\n                i++;\n            }else{\n                //反之j就右移动\n                j++;\n            }\n        }\n        return Arrays.copyOfRange(mark,0,k);\n    }\n}\n\n\n```\n\n  \n\n**思路:**\n\n  \n\n对两个数组进行排序，然后使用两个指针，分别指向两个数组开始的位置。\n\n  \n\n如果两个指针指向的值相同，说明这个值是他们的交集，就把这个值加入到集合list中，然后两个指针在分别往后移一步。\n\n如果两个指针指向的值不同，那么指向的值相对小的往后移一步，相对大的先不动，然后再比较。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 104,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_买卖股票的最佳时机.md",
      "title": "初级算入门_买卖股票的最佳时机",
      "abstract": "给定一个数组 `prices` ，它的第 `i` 个元素 `prices[i]` 表示一支给定股票第 `i` 天的价格。\n\n你只能选择 **某一天** 买入这只股票，并选择在 **未来的某一个不同的日子** 卖出该股票。设计一个算法来计算你所能获取的最大利润。\n\n返回你可以从这笔交易中获取的最大利润。如果你不能获取任何利润，返回 `0` 。\n\n \n\n**示例 1：**\n\n```bash\n输入：[7,1,5,3,6,4]\n输出：5\n解释：在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。\n     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格；同时，你不能在买入前卖出股票。\n```\n\n**示例 2：**\n\n```bash\n输入：prices = [7,6,4,3,1]\n输出：0\n解释：在这种情况下, 没有交易完成, 所以最大利润为 0。\n```\n\n \n\n**提示：**\n\n- `1 <= prices.length <= 105`\n- `0 <= prices[i] <= 104`\n\n## 代码:\n\n```java\nclass Solution {\n    public int maxProfit(int[] prices) {\n        /*\n        //超时了，tmd，注意 1 <= prices.length <= 105\n        int res = 0;\n        for(int i=0 ; i<prices.length ;i++){\n            for(int j =i+1;j<prices.length;j++){\n                if(prices[j]-prices[i]>=0){\n                    res=Math.max(res,prices[j]-prices[i]);\n                }\n            }\n        }\n        return res;\n        */\n\n        //max（当前价格max-最低价格min）\n        int min = 10001;\n        int res = 0;\n        for(int i=0; i<prices.length;i++){\n            min = Math.min(min,prices[i]);\n            res = Math.max(res,prices[i]-min);\n        }\n        return res;\n\n    }\n}\n```\n\n## 思路:\n\n原本是准备使用双循环解决这个问题的,结果时间超时了,因为数组长度太长了`1 <= prices.length <= 105`\n\n思考了一下不能这样解决问题。可以循环求最小值，用当前值减去最小值就是一个新的值，然后再用新值和下一次的新值作比较就能求出来了。\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 138,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_加一.md",
      "title": "初级算入门_加一",
      "abstract": "给定一个由 **整数** 组成的 **非空** 数组所表示的非负整数，在该数的基础上加一。\n\n最高位数字存放在数组的首位， 数组中每个元素只存储**单个**数字。\n\n你可以假设除了整数 0 之外，这个整数不会以零开头。\n\n \n\n**示例 1：**\n\n```\n输入：digits = [1,2,3]\n输出：[1,2,4]\n解释：输入数组表示数字 123。\n```\n\n**示例 2：**\n\n```\n输入：digits = [4,3,2,1]\n输出：[4,3,2,2]\n解释：输入数组表示数字 4321。\n```\n\n**示例 3：**\n\n```\n输入：digits = [0]\n输出：[1]\n```\n\n \n\n**提示：**\n\n- `1 <= digits.length <= 100`\n- `0 <= digits[i] <= 9`\n\n**代码:**\n\n```java\nclass Solution {\n    public int[] plusOne(int[] digits) {\n        int last = digits.length;\n        for(int i = digits.length-1 ; i>=0 ;i--){\n            if(digits[i] < 9){\n                 digits[i] = digits[i]+1;\n                 return digits;\n            }else{\n                 digits[i]=0;\n            }\n        }\n        int[] newDig = new int[last+1];\n        newDig[0]=1;\n        return newDig;   \n    }\n}\n```\n\n**思路:**\n\n乍一看很有思路,我一开始就是各种类型转换,转换来转换去。但是这样算法的存在就没有任何意义了。\n\n其实仔细查找规律可以发现，在小于9的时候仅仅是个在数组末尾的数字加一的操作。所以我们可以写一个倒叙的循环在循环末尾进行是否位9的判断。如果这个数是小于9的。那么我们可以直接在数组的最后一个数字上加一。\n\n剩下的就是末位数子是9的话。那么所有的数字都要进1。则就赋值为0，其余数字可以按照判断进行操作了。\n\n当然右999的情况出现的话那就是扩容数组，也就是生成一个数组长度+1的数组。然后在第一位赋值为1。这样这个题就轻而易举的出来了。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 100,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_反转字符串.md",
      "title": "初级算入门_反转字符串",
      "abstract": "编写一个函数，其作用是将输入的字符串反转过来。输入字符串以字符数组 `s` 的形式给出。\n\n  \n\n不要给另外的数组分配额外的空间，你必须**[原地](https://baike.baidu.com/item/原地算法)修改输入数组**、使用 O(1) 的额外空间解决这一问题。\n\n  \n\n  \n\n**示例 1：**\n\n  \n\n```bash\n\n输入：s = [\"h\",\"e\",\"l\",\"l\",\"o\"]\n\n输出：[\"o\",\"l\",\"l\",\"e\",\"h\"]\n\n```\n\n  \n\n**示例 2：**\n\n  \n\n```bash\n\n输入：s = [\"H\",\"a\",\"n\",\"n\",\"a\",\"h\"]\n\n输出：[\"h\",\"a\",\"n\",\"n\",\"a\",\"H\"]\n\n```\n\n  \n\n  \n\n**提示：**\n\n  \n\n- `1 <= s.length <= 105`\n\n- `s[i]` 都是 [ASCII](https://baike.baidu.com/item/ASCII) 码表中的可打印字符\n\n  \n  \n  \n\n**代码:**\n\n  \n\n```java\n\nclass Solution {\n    public void reverseString(char[] s) {\n        char temp;\n        for(int i =0,j=s.length-1-i;i<=j;i++){\n            temp=s[i];\n            s[i]=s[j];\n            s[j]=temp;\n            j--;\n        }\n    }\n}\n\n```\n\n  \n\n**思路:**\n\n  \n\n没什么思路,双指针,前后替换就行，一眼出结果。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 59,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_斐波那契数.md",
      "title": "初级算入门_斐波那契数",
      "abstract": "**斐波那契数** （通常用 `F(n)` 表示）形成的序列称为 **斐波那契数列** 。该数列由 `0` 和 `1` 开始，后面的每一项数字都是前面两项数字的和。也就是：\n\n```bash\nF(0) = 0，F(1) = 1\nF(n) = F(n - 1) + F(n - 2)，其中 n > 1\n```\n\n给定 `n` ，请计算 `F(n)` 。\n\n \n\n**示例 1：**\n\n```bash\n输入：n = 2\n输出：1\n解释：F(2) = F(1) + F(0) = 1 + 0 = 1\n```\n\n**示例 2：**\n\n```bash\n输入：n = 3\n输出：2\n解释：F(3) = F(2) + F(1) = 1 + 1 = 2\n```\n\n**示例 3：**\n\n```bash\n输入：n = 4\n输出：3\n解释：F(4) = F(3) + F(2) = 2 + 1 = 3\n```\n\n \n\n**提示：**\n\n- `0 <= n <= 30`\n\n\n\n**代码:**\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n==0||n==1) return n;\n        int temp=0,t0=0,t1=1;\n        for(int i=2;i<=n;i++){\n            temp=t0+t1;\n            t0=t1;\n            t1=temp;\n        }\n        return temp;\n    }\n}\n```\n\n**思路:**\n\n乍一看题目我是蒙的,但仔细思考规律之后就发现很简单\n\n斐波那契数列是这样的\n\n0 1 2 3 5 8\n\n也就是\n\n```bash\n0+1=2\n\n1+2=3\n\n2+3=5\n\n3+5=8\n```\n\n生成的数字是前两项之和\n\n那么这样看下去我们很容易发现规律\n\n```bash\n     t0  t1 \n数列 0   1   2   3   5   8  13\n下标 0   1   2   3   4   5  6\n\n```\n\n这样我们只需要改变t0和t1的记录值就可以了t0=t1,t1=temp的值就可以算出生成的新temp了\n\n **代码:**\n\n```java\nclass Solution {\n    public int fib(int n) {\n        if(n==0||n==1){\n            return n;\n        }else{\n            return fib(n-1)+fib(n-2);\n        }\n\n    }\n}\n```\n\n**思路:**\n\n用递归的方式解决问题,自己调用自己就可以了......\n\n设n=2就会走else然后fib(1)+fib(0)=2\n\n  n=3            fib(2)+fib(1)=3\n\n以此类推......",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 189,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_最长重复子数组.md",
      "title": "初级算入门_最长重复子数组",
      "abstract": "给两个整数数组 `nums1` 和 `nums2` ，返回 *两个数组中 **公共的** 、长度最长的子数组的长度* 。\n\n \n\n**示例 1：**\n\n```bash\n输入：nums1 = [1,2,3,2,1], nums2 = [3,2,1,4,7]\n输出：3\n解释：长度最长的公共子数组是 [3,2,1] 。\n```\n\n**示例 2：**\n\n```bash\n输入：nums1 = [0,0,0,0,0], nums2 = [0,0,0,0,0]\n输出：5\n```\n\n \n\n**提示：**\n\n- `1 <= nums1.length, nums2.length <= 1000`\n- `0 <= nums1[i], nums2[i] <= 100`\n\n**代码:**\n\n```java\nclass Solution {\n    public int findLength(int[] nums1, int[] nums2) {\n        int len1=nums1.length,len2=nums2.length;\n        int[][] table = new int[len1+1][len2+1];\n        //初始化table行列\n        /*\n        for(int i=0;i<len1;i++){\n            if(nums1[i]==nums2[0]){\n                table[i][0]=1;\n            }\n        }\n        for(int i=0;i<len2;i++){\n            if(nums1[0]==nums2[i]){\n                table[0][i]=1;\n            }\n        }\n        */\n        //往里面填入数字+1计算长度（对角+1）\n        int res =0;\n        for(int i=0; i<len1 ; i++){\n            for(int j=0; j<len2 ; j++){\n                if( nums1[i] == nums2[j] ){\n                    //如果相等,就把上次的值+1  （上次值就是对角md）\n                    table[i+1][j+1]=table[i][j]+1;\n                    res=Math.max(res,table[i+1][j+1]);\n                }else{\n                    table[i+1][j+1]=0;\n                }  \n            }        \n        }\n        return res;\n    }\n}\n```\n\n**思路:**\n\n按理说很好容易的一个题,给我凎蒙了\n\n我以为是数组找同一个元素,仔细读题之后并不是这样。寻找最长的公共子数组的长度。这是很关键的一点。以示例1为例子，他们都有的子数组是321和21和1，当然了相同元素也算是一个数组，但是我们需要找的是一个子数组，还是最长的，前提条件就是存在相同元素并且这相同元素在两个数组里面是挨着的。\n\n那[0,0,0,0,1]和[1,0,0,0,0]举例子\n\n|       | **0** | **0** | **0** | **0** | **1** |\n| ----- | ----- | ----- | ----- | ----- | ----- |\n| **1** | 0     | 0     | 0     | 0     | 1     |\n| **0** | 1     | 1     | 1     | 1     | 0     |\n| **0** | 1     | 2     | 2     | 2     | 0     |\n| **0** | 1     | 2     | 3     | 3     | 0     |\n| **0** | 1     | 2     | 3     | 4     | 0     |\n\n\n\n以示例1画表\n\n|      | 1    | 2    | 3    | 2    | **1** |\n| ---- | ---- | ---- | ---- | ---- | ----- |\n| 3    | 0    | 0    | 1    | 0    | 0     |\n| 2    | 0    | 1    | 0    | 2    | 0     |\n| 1    | 1    | 0    | 0    | 0    | 3     |\n| 4    | 0    | 0    | 0    | 0    | 0     |\n| 7    | 0    | 0    | 0    | 0    | 0     |\n\n上面我们可以看出来当第二个连续数出现时候，下标就开始改变，我们从for循环可以知道外for一次内for一轮。所以赋值出现了下面的这种情况,还有一点的是因为你是从上次的i和j开始找的，所以下次的i和j都加1后是下角的值，也就是说，我上次再[1,1]单元格相等赋值为1之后，那么再若在[2,2]单元格相等的话我们需要+1当前值就是2以此类推，要是不明白的话，你可以理解就是找对角线+1。\n\n我们就可以从初始化数组从0开始for\n\n```java\n for(int i=0; i<len1 ; i++){\n            for(int j=0; j<len2 ; j++){\n                if( nums1[i] == nums2[j] ){\n                    //如果相等,就把上次的值+1\n                    table[i+1][j+1]=table[i][j]+1;\n                    //进行比较，看看谁最大res是记录最大值\n                    res=Math.max(res,table[i+1][j+1]);\n                }else{\n                    table[i+1][j+1]=0;\n                }  \n            }        \n}\n```\n\n至于为什么这样写，不把二维数组初始值赋值为num1和num2的length，那是因为测试用例的时候有一个值相等的数组过不去\n\n也就是nums1 =[1,2,3,2,8]和nums2 =[5,6,1,4,7]\n\n这里面只有1是相等的，还算是一个数组。。。。。要是再外面判断二维数组里面的最大值，这样的时间复杂度就太高了。。。\n\n所以只能再二维数组+1了，所以上面图表的显示方式应该是整体往右下角整体移动一下，剩下位置补0。\n\n整体核心在这里\n\n**递推：**\n\n```java\nif(A[i]==B[j]){\n        dp[i][j]=dp[i-1][j-1]+1;\n    }else{\n        dp[i][j]=0;\n}\n```\n\n\n\n\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 345,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_杨辉三角.md",
      "title": "初级算入门_杨辉三角",
      "abstract": "给定一个非负整数 *`numRows`，*生成「杨辉三角」的前 *`numRows`* 行。\n\n在「杨辉三角」中，每个数是它左上方和右上方的数的和。\n\n![img](assets/初级算入门_杨辉三角/1626927345-DZmfxB-PascalTriangleAnimated2.gif)\n\n \n\n**示例 1:**\n\n```bash\n输入: numRows = 5\n输出: [[1],[1,1],[1,2,1],[1,3,3,1],[1,4,6,4,1]]\n```\n\n**示例 2:**\n\n```bash\n输入: numRows = 1\n输出: [[1]]\n```\n\n**提示:**\n\n- `1 <= numRows <= 30`\n\n**代码：**\n\n```java\n\nclass Solution {\n    public List<List<Integer>> generate(int numRows) {\n\n        List<List<Integer>> res = new ArrayList<>();\n\n        for(int i=0 ; i<numRows ; i++){\n            ArrayList<Integer> row = new ArrayList<>();\n                for(int j = 0;j<=i;j++){\n                    if(j==0 || j==i){\n                        row.add(1);\n                    }else{\n                        //第i层的第j个元素 = i-1层的第j个元素 + i-1层的第j-1元素\n                        row.add(res.get(i - 1).get(j - 1) + res.get(i - 1).get(j));\n                    }\n                    \n                }\n            res.add(row);\n        }\n\n        return res;\n    }\n}\n```\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 92,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_爬楼梯.md",
      "title": "初级算入门_爬楼梯",
      "abstract": "假设你正在爬楼梯。需要 `n` 阶你才能到达楼顶。\n\n每次你可以爬 `1` 或 `2` 个台阶。你有多少种不同的方法可以爬到楼顶呢？\n\n\n\n\n\n**示例 1：**\n\n```bash\n输入：n = 2\n输出：2\n解释：有两种方法可以爬到楼顶。\n1. 1 阶 + 1 阶\n2. 2 阶\n```\n\n**示例 2：**\n\n```bash\n输入：n = 3\n输出：3\n解释：有三种方法可以爬到楼顶。\n1. 1 阶 + 1 阶 + 1 阶\n2. 1 阶 + 2 阶\n3. 2 阶 + 1 阶\n```\n\n \n\n**提示：**\n\n- `1 <= n <= 45`\n\n**代码:**\n\n```java\n\nclass Solution {\n    public int climbStairs(int n) {\n/*\n        int res=0;\n        if(n==1||n==2){\n            return n;\n        }else{\n            res = climbStairs(n-1)+climbStairs(n-2);\n        }\n        return res;\n*/\n          \n        if(n==1||n==2) return n;\n        int temp=0,s1=1,s2=2;\n        for(int i=3;i<=n;i++){\n            temp = s1+s2;\n            s1=s2;\n            s2=temp;\n        }\n        return temp;\n\n    }\n}\n```\n\n**思路:**\n\n这个仔细一看不就是斐波那契数列嘛只不过初始值变了一下这个是从1开始的,其余不变。下意识是使用递归解决问题，结果n=45的时候超时了。。。。\n\n只能利用交换的方式了，`n==1`和`n==2`的时候他们是自己本身\n\n也就是这个情况数列\n\n```bash\n1  2  3  5  8  13\n```\n\n大差不差...所以设置初始值s1=1和s2=2就可以了,从n=3的时候开始计算。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 118,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_移动零.md",
      "title": "初级算入门_移动零",
      "abstract": "给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。\n\n**请注意** ，必须在不复制数组的情况下原地对数组进行操作。\n\n \n\n**示例 1:**\n\n```bash\n输入: nums = [0,1,0,3,12]\n输出: [1,3,12,0,0]\n```\n\n**示例 2:**\n\n```bash\n输入: nums = [0]\n输出: [0]\n```\n\n \n\n**提示**:\n\n- `1 <= nums.length <= 104`\n- `-231 <= nums[i] <= 231 - 1`\n\n\n\n**代码:**\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int temp =0;\n        for(int i = 0 ; i<nums.length;i++){\n            if(nums[i]!=0){\n                nums[temp++]=nums[i];\n            }\n        }\n        for(int j = temp;j<nums.length;j++){\n            nums[j]=0;\n        }\n\n    }\n}\n```\n\n这个方式的解题思路主要是记录0的个数,然后将不等于0的数字往前挪,也就是说你的第一位是0那么就不动，第二位是1那么就放到下标0的位置上，第三位是0不动，第四位是3那么就放到下标为1的位置上，往下同理。\n\n这样我们把不等于0的数字全部放到前面了。因为我们记录了temp的值。所以从temp开始遍历到数组结束，把从temp开始到数组结束的值都赋值为0。这样这道题就解出来了。\n\n**代码：**\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        int temp=0,i=0;\n        for(int j = 0 ; j<nums.length;j++){\n            if(nums[j]!=0){\n                temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i++;\n            }\n        }\n\n    }\n}\n```\n\n这个是我想到的方法，利用**双指针**解决问题，把不等于0的放到第一位的同时，也把这个不等于0数字对应的位置替换成0。\n\n**错误示范：**\n\n一开始想错了，竟然想到排序数组，把等于0和末尾数字交换位置。这样0就放到最后了，但是这样的情况下数组的顺序就变了，所以我们只能对不等于0的数字进行操作。\n\n```java\nclass Solution {\n    public void moveZeroes(int[] nums) {\n        //Arrays.sort(nums);\n        int temp=0;\n        for(int j = 0 ,i=nums.length-1; j<=i;j++){\n            if(nums[j]==0){\n                temp = nums[i];\n                nums[i] = nums[j];\n                nums[j] = temp;\n                i--;\n            }\n        }\n       \n    }\n}\n```\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 147,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_行和列中一和零的差值.md",
      "title": "初级算入门_行和列中一和零的差值",
      "abstract": "给你一个下标从 **0** 开始的 `m x n` 二进制矩阵 `grid` 。\n\n我们按照如下过程，定义一个下标从 **0** 开始的 `m x n` 差值矩阵 `diff` ：\n\n- 令第 `i` 行一的数目为 `onesRowi` 。\n- 令第 `j` 列一的数目为 `onesColj` 。\n- 令第 `i` 行零的数目为 `zerosRowi` 。\n- 令第 `j` 列零的数目为 `zerosColj` 。\n- `diff[i][j] = onesRowi + onesColj - zerosRowi - zerosColj`\n\n请你返回差值矩阵 `diff` 。\n\n \n\n**示例 1：**\n\n![img](assets/初级算入门_行和列中一和零的差值/image-20221106171729-5.png)\n\n```bash\n输入：grid = [[0,1,1],[1,0,1],[0,0,1]]\n输出：[[0,0,4],[0,0,4],[-2,-2,2]]\n解释：\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 2 + 1 - 1 - 2 = 0 \n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 2 + 1 - 1 - 2 = 0 \n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 2 + 3 - 1 - 0 = 4 \n- diff[2][0] = onesRow2 + onesCol0 - zerosRow2 - zerosCol0 = 1 + 1 - 2 - 2 = -2\n- diff[2][1] = onesRow2 + onesCol1 - zerosRow2 - zerosCol1 = 1 + 1 - 2 - 2 = -2\n- diff[2][2] = onesRow2 + onesCol2 - zerosRow2 - zerosCol2 = 1 + 3 - 2 - 0 = 2\n```\n\n**示例 2：**\n\n![img](assets/初级算入门_行和列中一和零的差值/image-20221106171747-6.png)\n\n```bash\n输入：grid = [[1,1,1],[1,1,1]]\n输出：[[5,5,5],[5,5,5]]\n解释：\n- diff[0][0] = onesRow0 + onesCol0 - zerosRow0 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[0][1] = onesRow0 + onesCol1 - zerosRow0 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[0][2] = onesRow0 + onesCol2 - zerosRow0 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n- diff[1][0] = onesRow1 + onesCol0 - zerosRow1 - zerosCol0 = 3 + 2 - 0 - 0 = 5\n- diff[1][1] = onesRow1 + onesCol1 - zerosRow1 - zerosCol1 = 3 + 2 - 0 - 0 = 5\n- diff[1][2] = onesRow1 + onesCol2 - zerosRow1 - zerosCol2 = 3 + 2 - 0 - 0 = 5\n```\n\n \n\n**提示：**\n\n- `m == grid.length`\n- `n == grid[i].length`\n- `1 <= m, n <= 105`\n- `1 <= m * n <= 105`\n- `grid[i][j]` 要么是 `0` ，要么是 `1` 。\n\n**代码:**\n\n```java\nclass Solution {\n    public int[][] onesMinusZeros(int[][] grid) {\n        int len1 =grid.length;\n        int len2 =grid[0].length;\n        int[] onesRowi = new int[len1];\n        int[] onesColj = new int[len2];\n        int[] zerosRowi = new int[len1];\n        int[] zerosColj = new int[len2];\n        int[][] diff = new int[len1][len2];\n\n        for(int i =0;i<len1;i++){\n            for(int j=0;j<len2;j++){\n                if(grid[i][j]==1){\n                    onesRowi[i]++;\n                    onesColj[j]++;\n                }else{\n                    zerosRowi[i]++;\n                    zerosColj[j]++;\n                }\n            }\n        }\n        for(int i=0; i<len1;i++){\n            for(int j=0;j<len2;j++){\n                diff[i][j]=onesRowi[i]+onesColj[j]-zerosRowi[i]-zerosColj[j];\n            }\n        }\n        return diff;\n    }\n}\n```\n\n**思路:**\n\n这题看着难,其实简单,首先grid是一个二维数组,并且不是0就是1。所以关于diff的赋值就只需要做一个判断就可以了。初始化数组的时候默认都是0。计算的都是行列中0和1的个数只需要判断在自己原来的数值上进行+1就可以了。\n\n最后在进行遍历相加减赋值，就出来了。\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 478,
        "text": "3分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算入门_跳跃游戏.md",
      "title": "初级算入门_跳跃游戏",
      "abstract": "给定一个非负整数数组 `nums` ，你最初位于数组的 **第一个下标** 。\r\n\r\n数组中的每个元素代表你在该位置可以跳跃的最大长度。\r\n\r\n判断你是否能够到达最后一个下标。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n```javascript\r\n输入：nums = [2,3,1,1,4]\r\n输出：true\r\n解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。\r\n```\r\n\r\n**示例 2：**\r\n\r\n```javascript\r\n输入：nums = [3,2,1,0,4]\r\n输出：false\r\n解释：无论怎样，总会到达下标为 3 的位置。但该下标的最大跳跃长度是 0 ， 所以永远不可能到达最后一个下标。\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= nums.length <= 3 * 104`\r\n- `0 <= nums[i] <= 105`\r\n\r\n\r\n\r\n**代码**\r\n\r\n```java\r\nclass Solution {\r\n    public boolean canJump(int[] nums) {\r\n\r\n        int tempMax=nums.length;\r\n        int temp =0;//记录能跳到数字的下标\r\n        for(int i=0;i<nums.length;i++){\r\n            if(i<=temp){//防止num[i]跳到的位置是个0\r\n                //就找出他能跳最远的位置\r\n                temp=Math.max(temp,i+nums[i]);\r\n                //如果这个位置数大于等于他数组的长度就说明可以跳到\r\n                if(temp>=tempMax-1){\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n        return false;\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n**理解**\r\n\r\n**子问题**：设想一下，对于数组中的**任意一个位置** **y**，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x + nums[x]，这个值大于等于 y，即 x+nums[x]≥y，那么位置 y 也可以到达。\r\n\r\n**步骤**：我们依次遍历数组中的每一个位置，并实时维护最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新最远可以到达的位置。\r\n\r\n如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，直接返回 True 。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 111,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算法入门_减小和重新排列数组后的最大元素.md",
      "title": "初级算法入门_减小和重新排列数组后的最大元素",
      "abstract": "\n\n给你一个正整数数组 `arr` 。请你对 `arr` 执行一些操作（也可以不进行任何操作），使得数组满足以下条件：\n\n- `arr` 中 **第一个** 元素必须为 `1` 。\n- 任意相邻两个元素的差的绝对值 **小于等于** `1` ，也就是说，对于任意的 `1 <= i < arr.length` （**数组下标从 0 开始**），都满足 `abs(arr[i] - arr[i - 1]) <= 1` 。`abs(x)` 为 `x` 的绝对值。\n\n你可以执行以下 2 种操作任意次：\n\n- **减小** `arr` 中任意元素的值，使其变为一个 **更小的正整数** 。\n- **重新排列** `arr` 中的元素，你可以以任意顺序重新排列。\n\n请你返回执行以上操作后，在满足前文所述的条件下，`arr` 中可能的 **最大值** 。\n\n \n\n**示例 1：**\n\n```bash\n输入：arr = [2,2,1,2,1]\n输出：2\n解释：\n我们可以重新排列 arr 得到 [1,2,2,2,1] ，该数组满足所有条件。\narr 中最大元素为 2 。\n```\n\n**示例 2：**\n\n```bash\n输入：arr = [100,1,1000]\n输出：3\n解释：\n一个可行的方案如下：\n1. 重新排列 arr 得到 [1,100,1000] 。\n2. 将第二个元素减小为 2 。\n3. 将第三个元素减小为 3 。\n现在 arr = [1,2,3] ，满足所有条件。\narr 中最大元素为 3 。\n```\n\n**示例 3：**\n\n```bash\n输入：arr = [1,2,3,4,5]\n输出：5\n解释：数组已经满足所有条件，最大元素为 5 。\n```\n\n \n\n**提示：**\n\n- `1 <= arr.length <= 105`\n- `1 <= arr[i] <= 109`\n\n## 代码\n\n```java\nclass Solution {\n    public int maximumElementAfterDecrementingAndRearranging(int[] arr) {\n        Arrays.sort(arr);\n        int res=0;\n        //1\n        for(int i=0;i<arr.length ;i++){\n            if(arr[i]>res){\n                res++;\n            }\n        }\n        return res;\n    }\n}\n```\n\n## 思路\n\n贪心,他默认是从1开始的,就假设下标为1。然后进行遍历\n\n1>0就res+1此时res=1\n\n2>1就res+1此时res=2\n\n2>2?此时不进行+1，res=2\n\n如此循环往复\n\n最后返回res就可以",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 164,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/初级算法入门_存在重复元素.md",
      "title": "初级算法入门_存在重复元素",
      "abstract": "给你一个整数数组 `nums` 。如果任一值在数组中出现 **至少两次** ，返回 `true` ；如果数组中每个元素互不相同，返回 `false` 。\n\n \n\n**示例 1：**\n\n```\n输入：nums = [1,2,3,1]\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：nums = [1,2,3,4]\n输出：false\n```\n\n**示例 3：**\n\n```\n输入：nums = [1,1,1,3,3,4,3,2,4,2]\n输出：true\n```\n\n \n\n**提示：**\n\n- `1 <= nums.length <= 105`\n- `-109 <= nums[i] <= 109`\n\n\n\n**代码:**\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n        Arrays.sort(nums);\n        for(int i=1;i<nums.length;i++){\n            if(nums[i]==nums[i-1]){\n                return true;\n            }\n        }   \n        return false;\n    }\n}\n```\n\n基本上是先排序在做比较,这种很直接,但是很慢，很暴力。\n## 拓展新思路\n在看别人怎么做的时候忽然看见个去重比较长度的。不禁感叹思路千奇百怪。\n\n```java\nclass Solution {\n    public boolean containsDuplicate(int[] nums) {\n            Set<Integer> integerSet = new HashSet<>();\n            for (int num : nums) {\n                integerSet.add(num);\n            }\n            return integerSet.size() != nums.length;\n    }\n}\n```\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 103,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/判断两个事件是否存在冲突.md",
      "title": "判断两个事件是否存在冲突",
      "abstract": "给你两个字符串数组 `event1` 和 `event2` ，表示发生在同一天的两个闭区间时间段事件，其中：\r\n\r\n- `event1 = [startTime1, endTime1]` 且\r\n- `event2 = [startTime2, endTime2]`\r\n\r\n事件的时间为有效的 24 小时制且按 `HH:MM` 格式给出。\r\n\r\n当两个事件存在某个非空的交集时（即，某些时刻是两个事件都包含的），则认为出现 **冲突** 。\r\n\r\n如果两个事件之间存在冲突，返回 `true` ；否则，返回 `false` 。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：event1 = [\"01:15\",\"02:00\"], event2 = [\"02:00\",\"03:00\"]\r\n输出：true\r\n解释：两个事件在 2:00 出现交集。\r\n```\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：event1 = [\"01:00\",\"02:00\"], event2 = [\"01:20\",\"03:00\"]\r\n输出：true\r\n解释：两个事件的交集从 01:20 开始，到 02:00 结束。\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：event1 = [\"10:00\",\"11:00\"], event2 = [\"14:00\",\"15:00\"]\r\n输出：false\r\n解释：两个事件不存在交集。\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `evnet1.length == event2.length == 2.`\r\n- `event1[i].length == event2[i].length == 5`\r\n- `startTime1 <= endTime1`\r\n- `startTime2 <= endTime2`\r\n- 所有事件的时间都按照 `HH:MM` 格式给出\r\n\r\n## 代码\r\n\r\n```java\r\nclass Solution {\r\n    public boolean haveConflict(String[] event1, String[] event2) {\r\n        int event1StartTime = strToIntTime(event1[0]);\r\n        int event1EndTime   = strToIntTime(event1[1]);\r\n        int event2StartTime = strToIntTime(event2[0]);\r\n        int event2EndTime   = strToIntTime(event2[1]);\r\n\r\n        if(event1EndTime < event2StartTime || event2EndTime <event1StartTime ){\r\n            return false;\r\n        }\r\n        return true;\r\n    }\r\n    public static int strToIntTime(String str) {\r\n        String[] ss = str.split(\":\");\r\n        int hours = Integer.parseInt(ss[0])*60;\r\n        return  hours+Integer.parseInt(ss[1]);\r\n    }\r\n}\r\n```\r\n\r\n\r\n\r\n## 思路\r\n\r\n比对时间不在另一个区间内就可以了，但是string不能进行比较，只能使用int类型比较。",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 160,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/剑指 Offer 05. 替换空格.md",
      "title": "剑指 Offer 05. 替换空格",
      "abstract": "请实现一个函数，把字符串 `s` 中的每个空格替换成\"%20\"。\n\n \n\n**示例 1：**\n\n```bash\n输入：s = \"We are happy.\"\n输出：\"We%20are%20happy.\"\n```\n\n \n\n**限制：**\n\n```bash\n0 <= s 的长度 <= 10000\n```\n\n## 代码\n\n```java\nclass Solution {\n    public String replaceSpace(String s) {\n        return s.replace(\" \",\"%20\");\n    }\n}\n```\n\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 40,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/算法/算法题解/负二进制数相加.md",
      "title": "负二进制数相加",
      "abstract": "给出基数为 **-2** 的两个数 `arr1` 和 `arr2`，返回两数相加的结果。\r\n\r\n数字以 *数组形式* 给出：数组由若干 0 和 1 组成，按最高有效位到最低有效位的顺序排列。例如，`arr = [1,1,0,1]` 表示数字 `(-2)^3 + (-2)^2 + (-2)^0 = -3`。*数组形式* 中的数字 `arr` 也同样不含前导零：即 `arr == [0]` 或 `arr[0] == 1`。\r\n\r\n返回相同表示形式的 `arr1` 和 `arr2` 相加的结果。两数的表示形式为：不含前导零、由若干 0 和 1 组成的数组。\r\n\r\n \r\n\r\n**示例 1：**\r\n\r\n```\r\n输入：arr1 = [1,1,1,1,1], arr2 = [1,0,1]\r\n输出：[1,0,0,0,0]\r\n解释：arr1 表示 11，arr2 表示 5，输出表示 16 。\r\n```\r\n\r\n\r\n\r\n**示例 2：**\r\n\r\n```\r\n输入：arr1 = [0], arr2 = [0]\r\n输出：[0]\r\n```\r\n\r\n**示例 3：**\r\n\r\n```\r\n输入：arr1 = [0], arr2 = [1]\r\n输出：[1]\r\n```\r\n\r\n \r\n\r\n**提示：**\r\n\r\n- `1 <= arr1.length, arr2.length <= 1000`\r\n- `arr1[i]` 和 `arr2[i]` 都是 `0` 或 `1`\r\n- `arr1` 和 `arr2` 都没有前导0\r\n\r\n## 代码：\r\n\r\n```java\r\nclass Solution {\r\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\r\n        // 定义规则：0+1=1，进位向前边减一，够减则减，不够减则借位\r\n        int[] outCome = null;\r\n        if (arr1.length > arr2.length) {\r\n            for (int i = 1; i <= arr2.length; i++) {\r\n                arr1[arr1.length - i] += arr2[arr2.length - i];\r\n            }\r\n            outCome = arr1;\r\n        } else {\r\n            for (int i = 1; i <= arr1.length; i++) {\r\n                arr2[arr2.length - i] += arr1[arr1.length - i];\r\n            }\r\n            outCome = arr2;\r\n        }\r\n        // System.out.println(Arrays.toString(outCome));\r\n        int add = 0;\r\n        for (int i = outCome.length - 1; i > 0; i--) {\r\n            if (outCome[i] + add >= 2) {\r\n                add = -1;\r\n                outCome[i] -= 2;\r\n            } else if (outCome[i] + add < 0) {\r\n                outCome[i - 1] += 1;\r\n                outCome[i] = 1;\r\n                add = 0;\r\n            } else {\r\n                outCome[i] += add;\r\n                add = 0;\r\n            }\r\n        }\r\n        outCome[0] += add;\r\n        //System.out.println(Arrays.toString(outCome));\r\n        if (outCome[0] >= 2) {\r\n            outCome[0] -= 2;\r\n            int[] newOutCome = new int[outCome.length + 2];\r\n            newOutCome[0] = 1;\r\n            newOutCome[1] = 1;\r\n            for (int i = 0; i < outCome.length; i++) {\r\n                newOutCome[2 + i] = outCome[i];\r\n            }\r\n            outCome = newOutCome;\r\n        }\r\n        // System.out.println(Arrays.toString(outCome));\r\n        if (outCome[0] == 0) {\r\n            int zlength = 0;\r\n            while (zlength < outCome.length && outCome[zlength] == 0) {\r\n                zlength++;\r\n            }\r\n            System.out.println(zlength);\r\n            if (zlength == outCome.length) {\r\n                outCome = new int[1];\r\n                outCome[0] = 0;\r\n            } else {\r\n                int[] newOutCome = new int[outCome.length - zlength];\r\n                for (int i = 0; i < newOutCome.length; i++) {\r\n                    newOutCome[i] = outCome[zlength + i];\r\n                }\r\n                outCome = newOutCome;\r\n            }\r\n        }\r\n\r\n        return outCome;\r\n    }\r\n}\r\n\r\n```\r\n\r\n\r\n\r\n## 错误的办法：\r\n\r\n这里主要错误的原因是因为忽略了数组之间的长度，因为长度是1000也就是最大的数是-2的1000次幂。远远的超出了bigint，int，以及long类型的计算长度。所以下面的办法是妥妥的不对的\r\n\r\n| 关键字 | 所占位数 | 范围                   |\r\n| ------ | -------- | ---------------------- |\r\n| int    | 32       | −231−231 ~ 2 ^{31} - 1 |\r\n| long   | 64       | −263−263 ~ 2 ^{63} - 1 |\r\n\r\n```java\r\nclass Solution {\r\n    public int[] addNegabinary(int[] arr1, int[] arr2) {\r\n        int xx = lowBinaryToInt(arr1) + lowBinaryToInt(arr2);\r\n        String ss= intToLowBinaryString(xx);\r\n        String[] ssArr = ss.split(\"\");\r\n        int[] res = new int[ss.length()];\r\n        for (int i = 0; i <= ss.length()-1; i++) {\r\n            res[i] = Integer.parseInt(ssArr[i]);\r\n        }\r\n        return res;\r\n    }\r\n    public static int lowBinaryToInt(int[] arr) {\r\n        double res=0;\r\n        int xx = 0;\r\n        for (int i = arr.length - 1; i>=0; i--) {\r\n            if (arr[i] == 1) {\r\n                res = res+Math.pow(-2, xx);\r\n                xx++;\r\n            }else{\r\n                xx++;\r\n            }\r\n        }\r\n        return (int)res;\r\n    }\r\n    public static String intToLowBinaryString(int N) {\r\n        StringBuilder sb = new StringBuilder();\r\n        while (N != 0) {\r\n            int r = N % -2;\r\n            N = N / -2;\r\n            if (r < 0) {\r\n                r = r + 2;\r\n                N = N+1;\r\n            }\r\n            sb.append(r);\r\n        }\r\n        return sb.length() > 0 ? sb.reverse().toString() : \"0\";\r\n    }\r\n}\r\n```\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:41",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "算法",
          "link": "#"
        },
        {
          "name": "算法题解",
          "link": "#"
        }
      ],
      "stats": {
        "words": 532,
        "text": "3分钟"
      }
    },
    {
      "link": "技术笔记/前端/echarts显示小数点后两位.md",
      "title": "echarts显示小数点后两位",
      "abstract": "```html\r\n\r\n<!DOCTYPE html>\r\n<html style=\"height: 100%\">\r\n\r\n<head>\r\n  <meta charset=\"utf-8\">\r\n</head>\r\n\r\n<body style=\"height: 100%; margin: 0; background-color: transparent\">\r\n  <div id=\"container\" style=\"height: 100%; background-color: transparent\"></div>\r\n  \r\n  <script type=\"text/javascript\" src=\"echarts.min.js\"></script>\r\n  <script type=\"text/javascript\">\r\n    var dom = document.getElementById(\"container\");\r\n    var myChart = echarts.init(dom);\r\n    var app = {};\r\n    var option;\r\n    option = {\r\n      backgroundColor: 'transparent',\r\n\r\n      series: [\r\n        {\r\n          type: 'gauge',\r\n          axisLine: {\r\n            lineStyle: {\r\n              width: 15,\r\n              color: [\r\n                [0.3, '#67e0e3'],\r\n                [0.7, '#37a2da'],\r\n                [1, '#fd666d']\r\n              ]\r\n            }\r\n          },\r\n          min: 0,\r\n      max: 3,\r\n          pointer: {\r\n            itemStyle: {\r\n              color: 'auto'\r\n            }\r\n          },\r\n          axisTick: {//轴刻度\r\n            distance: -15,\r\n            length: 8,\r\n            lineStyle: {\r\n              color: '#fff',\r\n              width: 2\r\n            }\r\n          },\r\n          splitLine: {\r\n            distance: -15,\r\n            length: 15,\r\n            lineStyle: {\r\n              color: '#fff',\r\n              width: 2\r\n            }\r\n          },\r\n          axisLabel: {\r\n            color: 'auto',\r\n            distance: 20,\r\n            fontSize: 12\r\n          },\r\n          detail: {//pue显示\r\n            valueAnimation: true,\r\n            formatter: 'PUE= {value}',\r\n            color: 'green',\r\n            fontSize: 20\r\n          },\r\n          data: [\r\n            {\r\n              value: 0.00,\r\n              min: 0.00,\r\n              max: 3.00\r\n            }\r\n          ]\r\n        }\r\n      ]\r\n    };\r\n\r\n    oaJsApi.dpConnect('System1:PUE5.PUE:_online.._value', true,\r\n      {\r\n        success: function (data) {\r\n          var value = data.value[0];\r\n          //var pueShow =   newF.toFixed(2); \r\n          //var pueShow = formatFloat(newF, n = 2,'floor');\r\n          //console.log(newF);\r\n          //console.log(pueShow);\r\n\r\n          myChart.setOption({\r\n            series: [\r\n              {\r\n                detail:{\r\n                      formatter: function (value) {\r\n                            return  \"PUE=\"+value.toFixed(2);\r\n                      }\r\n                    },\r\n                data: [\r\n                  {\r\n                    value:value,\r\n                  }\r\n                ]\r\n\r\n              }\r\n            ]\r\n          });\r\n\r\n        }\r\n      });\r\n\r\n\r\n    if (option && typeof option === 'object') {\r\n      myChart.setOption(option);\r\n    }\r\n    //自建方法 ceil 向上取   floor 向下区\r\n    function formatFloat(num, n = 1, flag) {\r\n    var f = parseFloat(num);\r\n    if (isNaN(f)) {\r\n        return false;\r\n    }\r\n    if (flag === 'ceil') {\r\n        f = Math.ceil(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\r\n    } else if (flag === 'floor') {\r\n        f = Math.floor(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\r\n    } else {\r\n        f = Math.round(num * Math.pow(10, n)) / Math.pow(10, n); // n 幂\r\n    }\r\n    var s = f.toString();\r\n    var rs = s.indexOf('.');\r\n    //判定如果是整数，增加小数点再补0\r\n    if (rs < 0) {\r\n        rs = s.length;\r\n        s += '.';\r\n    }\r\n    while (s.length <= rs + n) {\r\n        s += '0';\r\n    }\r\n    return s;\r\n    }\r\n\r\n  </script>\r\n  <script>\r\n\r\n  </script>\r\n\r\n</body>\r\n\r\n</html>\r\n```\r\n\r\n先处理传入的value值，\r\n\r\n```javascript\r\ndata: [\r\n                  {\r\n                    value:value,\r\n                  }\r\n      ]\r\n```\r\n\r\n然后利用函数给formatter发送数据，return数据可以是string类型\r\n\r\n```javascript\r\ndetail:{\r\n                      formatter: function (value) {\r\n                            return  \"PUE=\"+value.toFixed(2);\r\n                      }\r\n         },\r\n```\r\n\r\n前端针对pue数据进行显示  `formatter: '{value}'`\r\n\r\n```javascript\r\ndetail: {//pue显示\r\n            valueAnimation: true,\r\n            formatter: '{value}',\r\n            color: 'green',\r\n            fontSize: 20\r\n          },\r\n```\r\n\r\n",
      "dateFormat": "2024-11-12 20:36:16",
      "changeTime": "2023-08-05 13:45:40",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "前端",
          "link": "#"
        }
      ],
      "stats": {
        "words": 355,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/test.md",
      "title": "test",
      "abstract": "测试内容1",
      "dateFormat": "2024-11-12 16:09:14",
      "changeTime": "2024-11-12 16:09:25",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/随笔记：.md",
      "title": "随笔记：",
      "abstract": "随笔记：\n　　入睡前我在想一件事情，为什么人这么容易被感动，但又那么容易脱离这种感动。那种容易勾起人内心深处的柔软大抵是至亲之人的嘘寒问暖，与自己同命相连之人的痛苦。我们活着，看到比自己好的人会羡慕，看到比自己不好的人会痛苦。一颗怜悯之心被自己这样反反复复的使用，最后归为麻木。\n　　有时候挺恨的，这是个什么破时代，破时代，破时代啊，想当个好官都要匿名，都要被嘲笑。“好好干，日子会越来越甜”一句话充满着上层阶级对底层人民的怜悯，这句怜悯甚至带着些许的自视甚高。我讨厌谷爱凌，讨厌白岩松，有的时候想过，自己讨厌的不是他们，是讨厌的这种高高在上的人，努力实现了阶级的跃迁，真的是一件美事，有背后家境的撑腰，就算是猪过的也比普通人好上百倍。百年出来了雷锋，可惜再难有了。\n　　一场疫情打碎了太多人的美梦，疫情期间，回忆过往成了那几年的主旋律。现在年轻人的批判成为了近几年的主旋律。没一个时代都有一个时代的标志。可以是一个人，也可以是一种意。\n　　随着时代的发展，阶级固化，再去冲破他不知道还要多久，有的人不愿意放手，就会用制度经验来压。以前是人推动着社会走，现在是社会逼着人再跑。\n　　有些跑题了，随便了，反正是睡前的胡思乱想，也许短视频的出现改变了这个时代。以前人民获取信息的方式是报纸，权威大，官方，留给人足够的思考辩证看待事物的时间。现在我们获取信息的方式有很多，可是这种驳杂带来的思考时间几乎为零，同时各种逆天言论带来了人门思想的解放。在此推荐尼尔波茨曼的三部曲。\n　　之前在知乎上针对追星问题的谈论，结果因为指名道姓的说了蔡徐坤和肖战被某些人举报了。我在说追星的意义和时代的悲剧，她们和我扯自己的哥哥有太多的努力。我真的是。。。一头牛永远无法和一头狮子在同一个草原上谈论生存，一个想要吃草，一个想要吃牛。\n　　安得广厦千万间，大庇天下寒士俱欢颜。我当年背的时候满满的豪气，现在留给自己的只是苦笑。我好佩服辛弃疾啊！尤其是那“少年不识愁滋味，爱上层楼。爱上层楼，为赋新词强说愁。”（这是上半阙），我当时也好喜欢背这首诗的下半阙。因为我相信我终有一天会明白他的，是现在吗？之前和一位前辈谈论过这些闲言碎语，他和我说资本论已经过时了，资本论真的过时了吗？\n　　兴，百姓苦。亡，百姓苦。到最后天下还真的是归于这一句话。​\n",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:31:33",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 10,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/所有的这一切都只是希望我们不被片面的信息所绑架，成为某个标签的放大器，哪怕我们无法做到完全的客观理性.md",
      "title": "所有的这一切都只是希望我们不被片面的信息所绑架，成为某个标签的放大器，哪怕我们无法做到完全的客观理性",
      "abstract": "所有的这一切都只是希望我们不被片面的信息所绑架，成为某个标签的放大器，哪怕我们无法做到完全的客观理性，至少要对自己说过的话负责，对自己不了解的东西不要那么轻易去下定论。牢骚太盛防肠断，风物长宜放眼量。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/所谓超脱，并不是超然物外，遗世独立，而只是与自己在人世间的遭遇保持一个距离。有了这个距离，也就有了一.md",
      "title": "所谓超脱，并不是超然物外，遗世独立，而只是与自己在人世间的遭遇保持一个距离。有了这个距离，也就有了一",
      "abstract": "所谓超脱，并不是超然物外，遗世独立，而只是与自己在人世间的遭遇保持一个距离。有了这个距离，也就有了一种看世界的眼光。一个人一旦省悟人生的底蕴和限度，他在这个浮华世界上就很难成为一个踌躇满志的风云人物了。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/承认自己的无知乃是开启智慧的大门，但是智者学派却认为一切的辩论都只是为了利益，没有真理，但是大家会发.md",
      "title": "承认自己的无知乃是开启智慧的大门，但是智者学派却认为一切的辩论都只是为了利益，没有真理，但是大家会发",
      "abstract": "承认自己的无知乃是开启智慧的大门，但是智者学派却认为一切的辩论都只是为了利益，没有真理，但是大家会发现，大家会发现智者学派有一个严重的逻辑问题，就是认为这个世界上没有什么是绝对的，对，也没有什么是绝对的，错儿这句话本身就是绝对的，所以他们在逻辑上犯下了一个错误，我认为这个世界一切都没有意义，当你说这句话，你本身就应该闭嘴，因为你说的这个话不就在告诉我一个意义吗？这是智者学派致命的漏洞，但是马上有同学说了，说老师，你看不对，不对不对，苏格拉底也说什么呢？苏格拉底说，我只知道一件事，那就是我一无所知，他说，这难道和刚才你所说的，没有什么是绝对的，对，也没有什么是绝对的，错儿这句话本身就是绝对。\n不一样呢，各位觉得有什么区别呢？我再给大家捋一捋，智者学派说，没有什么是绝对的，对，也没有什么是绝对的错，这个世界上没有证明，但它本身却说了一个绝对的术语，就是没有什么是绝对的，对，也没有什么是绝对的错误，而苏格拉底也说什么呢，我只知道一件事情，那就是我一无所知，表面上好像真的是很相似。难怪会有人认为苏格拉底是智者学派，但苏格拉底是免费的，智者学派收费的苏格拉底是为了追求真理，智者学派是为了消解真理，我想说什么？当苏格拉底说，我只知道一件事情，那就是我一无所知，这其实是一种比喻，因为诸葛垃圾肯定是知道的一些事情，但是当你知道的一些事情，在知识的海洋中，你才会意识到自己的渺小，你才会发现你真的就相当于什么都不知道，这就相当于我有这一瓶水，我的知识含量是这一瓶水，我站在大海边上，我觉得我所拥有的水甚至可笑，我站在大海旁边，我对于那种拥有大海含量的知识，我说我拥有一点知识，我在搞笑，我只能说，我什么都不知道，我这个水在广袤的大海面前算得了什么吗？所以这就是。为什么当你知道的越多，你越觉得自己不知道啊，当你越不知道你越觉得自己知道智者学派是似是而非，而苏格拉底是是非，而是我想问问大家，在座的同学有没有那种你能够为之生也为之死的信念和使命，这种信念和使命，能够让你超越你有限的人生，说实话人这一生啊，其实不需要影响太多的人，你只需要影响几个，你可以影响。\n未经省察的人生没有意义，未经省察的人生没有意义，未经省察的人生没有意义，谢谢各位，很高兴各位同学能够花那么多时间和我一起来阅读这本书，我们的时间是如此宝贵，我们每分每秒都在接近我们生命的终点，我们能不能够省察我们的内心，我们能不能够拥有真正的对焦，我们能不能够也拥有自己的崇高与感动，成为人类历史的高光一颗。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/有些人痴迷于整理相册，可能会发现拍摄时觉察不到的重要细节。比如一次邂逅，发现挚友出现在老照片的背景里.md",
      "title": "有些人痴迷于整理相册，可能会发现拍摄时觉察不到的重要细节。比如一次邂逅，发现挚友出现在老照片的背景里",
      "abstract": "有些人痴迷于整理相册，可能会发现拍摄时觉察不到的重要细节。比如一次邂逅，发现挚友出现在老照片的背景里，原来相识相知之前，就曾擦肩而过。一次别离，某个重要的人再也消失不见。也可能拍到人与事从未展露的侧面，乃至一种可供解读的巧合。 \n这些偶然发现，讲述了现实生活的另一种可能。而这发现每天都是新的，因为手机相册始终在膨胀，拍完一张，总是再加一张。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/甘居人下者鲜。御之失谋，非犯，则篡耳。上无威，下生乱。威成于礼，恃以刑，失之纵。私勿与人，谋必辟。幸.md",
      "title": "甘居人下者鲜。御之失谋，非犯，则篡耳。上无威，下生乱。威成于礼，恃以刑，失之纵。私勿与人，谋必辟。幸",
      "abstract": "甘居人下者鲜。御之失谋，非犯，则篡耳。上无威，下生乱。威成于礼，恃以刑，失之纵。私勿与人，谋必辟。幸非一人，专固害。机心信隐，交接靡密，庶下者知威而畏也。下附上以成志，上恃下以成名。下有所求，其心必进，迁之宜缓，速则满矣。上有所欲，其神若亲，礼下勿辞，拒者无助矣。人有所好，以好诱之无不取，人有所惧，以惧迫之无不纳。才可用者，非大害而隐忍。其不可制，果大材而亦诛。赏勿吝，以坠其志。罚适时，以警其心。恩威同施，才德相较，苟无功，得无天耶？​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/白发戴花君莫笑，岁月从不败美人。若有诗书藏在心，撷来芳华成至真。​.md",
      "title": "白发戴花君莫笑，岁月从不败美人。若有诗书藏在心，撷来芳华成至真。​",
      "abstract": "白发戴花君莫笑，岁月从不败美人。若有诗书藏在心，撷来芳华成至真。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/自懂事以来，老师教育的，父母叮嘱的，周围看到的，第一都是要坚强地活着。岩缝里缓缓冒出的绿草，嫩枝上静.md",
      "title": "自懂事以来，老师教育的，父母叮嘱的，周围看到的，第一都是要坚强地活着。岩缝里缓缓冒出的绿草，嫩枝上静",
      "abstract": "自懂事以来，老师教育的，父母叮嘱的，周围看到的，第一都是要坚强地活着。岩缝里缓缓冒出的绿草，嫩枝上静静张开的花骨朵儿，对坚强品质的崇拜和渴望，在我们心里生长。坚强成为了我们心中永远的烙印，是我们一生都要恪守的信条。\n\n我们一直坚信，无论遇到什么事，我们都要坚强地面对，坚强地活下去，独自一人默默地承受着。因为这本是我们理所应当的，是我们的使命。\n可是当灾难痛苦真正来临时，才发现自己太弱小，太可悲，我们执念的坚强像飘荡的泡沫，一触就破。悲伤如跗骨之蛆，阴魂不散，灭却了热情，带来了噩梦。微微开口，如芒刺在喉，语塞木然，言语之间也只剩叹气和尴尬。\n不是所有的事情都能被时间打磨平，不是经过了岁月，我们就能和自己和解，有些东西，就像深扎进肉里的刺，永远永远，刺痛且无可奈何。就算你挖开血肉，想给自己一个摆脱它的机会，却还是会发现，它早就融在身体里，成了无药的顽疾，余生必须与其为伴，永远如鲠在喉。\n世间无限丹青手，一片伤心画不成。\n\n\n作者：天空的鱼鱼",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 6,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/西天取经是十万八千里，孙悟空一个筋斗云也是十万八千里，为什么一个筋斗云就能直接到达目的地，却要耗费十.md",
      "title": "西天取经是十万八千里，孙悟空一个筋斗云也是十万八千里，为什么一个筋斗云就能直接到达目的地，却要耗费十",
      "abstract": "西天取经是十万八千里，孙悟空一个筋斗云也是十万八千里，为什么一个筋斗云就能直接到达目的地，却要耗费十四年一步一步的走过去？​\n\n你有能力，没身份。你领导的侄子没能力是外行，有身份，怎样让他侄子也进到岗位当中。\n就是你做他侄子的助手，一步一步带着他走马观花，哄着他，认门路，各种领导侄子太多了，你也不敢得罪，所有啥事先请教大领导，别打错了妖精，你把他侄子扶上位后，事成之后，也能分你个一官半职。\n\n最后是他侄子领导得好，团队带的好，管理贡献突出，经历了八十一难，获得如今的位置，是理所当然，是他应得的，你也成了斗战胜佛，是的，打架的。",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/《和莎莫的五百天》.md",
      "title": "《和莎莫的五百天》",
      "abstract": "《和莎莫的五百天》\n感情本身就是一场博弈。它从一开始就是不对等的，直到最后，我变成了你，你变成了我。\n\n你看你，明明不相信爱情，却在看完电影之后痛哭流涕。\n我看着我，明明那么相信着爱情，却在说着“着仅仅是场电影而已”​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/一团烈火并不会因为清晨的露珠而毁灭​.md",
      "title": "一团烈火并不会因为清晨的露珠而毁灭​",
      "abstract": "一团烈火并不会因为清晨的露珠而毁灭​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/世界奇妙物语之瞬移到明天：.md",
      "title": "世界奇妙物语之瞬移到明天：",
      "abstract": "世界奇妙物语之瞬移到明天：\n生活就像数学题一样,只有答案没有解题的过程也是错的。\n当我垂垂老矣接近死亡的那一刻，除了记忆是我的之外，剩下的没有一件属于我。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/人为什么喜欢美丽呢，美丽的定义是什么？秦朝以壮硕为美唐朝以雍容为美，明清以瘦为美。人为什么要努力呢，.md",
      "title": "人为什么喜欢美丽呢，美丽的定义是什么？秦朝以壮硕为美唐朝以雍容为美，明清以瘦为美。人为什么要努力呢，",
      "abstract": "人为什么喜欢美丽呢，美丽的定义是什么？秦朝以壮硕为美唐朝以雍容为美，明清以瘦为美。人为什么要努力呢，为什么有人会那么贪婪，为什么有人不思进取，为什么会有好多种人啊。。。好难啊。。关于人生这道题，我不会做。。我想远离。。。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/倾听.md",
      "title": "倾听",
      "abstract": "倾听\n我常常以一个聆听者的身份，去倾听身边的故事。​\n我听到最多的一句话就是“你没经历过，你不懂”。你不懂，你不懂，这三个字久久在我耳边围绕。也许我真的无法体会那种伤心欲绝那种欣喜若狂。我知道“未经他人苦，莫劝他人善”所以我尽量避免评价一个人的功过是非，我想那个人做出一定选择的时候一定是思考很多的，也或许是被现实所迫。\n可是，当我拼尽全力去分担那种苦楚的时候，那种无力感带来的愧疚让我内心更加的难受与自责。可是我终究还是逃不过那句话“你不懂”。或许我真的不懂，当然了，你也不懂。",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/关于我对感情的认知.md",
      "title": "关于我对感情的认知",
      "abstract": "关于我对感情的认知\n    亲爱的王老师你好，很抱歉今晚​和你说出那样的话。其实从这几天的感受中我真的感受到在我与你的相处之中，你是在不断的妥协，对自己性格的妥协，对我的妥协。\n    其实在我的期待之中，我想的感情是两个人相遇相知然后在一起努力的路上和对方携手共进，三观一致，然后一方说出“我们一起继续往后走吧！”，这样的岁月静好。我和我朋友也说过这种事情，他只是回答了我四个字“痴心妄想”。我有时候明白，再这样快节奏的生活中，很难找到这个过程。在这不属于这个时代的感情之中期待着，是永远毫无结果的。可是我还是很希望这样，也许我们的时机尚未成熟，花还没结果就去摘，就得亚当和夏娃偷吃了失乐园的苹果一样，遭受了神的惩罚。\n    我还是不明白你为什么这么快的去想要一个答案，去这么快的在一起。我真的没有最好准备。而且，我发现，自从我和上一任的感情以失败结束后，再也找不到当时的感觉了。或许我还是再固执的认为着感情就是需要感觉的。\n    我也思考过，可以提前在一起啊！然后我们在生活中慢慢的磨合，慢慢的走，慢慢的成长。但是我就一直感觉我好难做到，很难摆把思想调整到这个状态，真的很抱歉。我想和你一起努力，可是每次你说我就是不行，我就是笨的时候，我真的好生气啊！但是还不能显露出来，就像我拉紧你的手去学校，你固执的说“我不要，我还想再玩一会”。可是学习的路上必然是辛苦的，但只有学习是世界上最简单的事情，它会让我们明白好多事情，明白这世界的千变万化，明白对立思想存在的必要性，明白爱情存在的真正意义。现在的努力与学习也是对我们未来的负责，为了未来更好的生活而打下基础。\n    说一说我家里的情况吧。。我家就是很普通的家庭，父亲是电气焊工人，母亲是服务员，这使我在上一段感情中十分的自卑，当对方家庭提出要求时，我看到了我父亲窘迫的模样，尴尬的笑容我真的难以忘怀。再加上我表弟考上了复旦，过年时候，我的爸妈少了很多的笑容，多的只是满脸的惆怅。有一天我突然接到我爸的电话，说“儿子，咱们家里买房了，你可以雪晨说了！别担心啊！”可是，那时候，我刚和我前对象分手不到一星期，我实在难以和我爸把分手的事情说出口。我很好奇是在哪里买房的，于是寒假回家的时候，我开始偷偷的翻箱倒柜，结果找到的只有为了买房的借据。我很佩服我的爸爸，他是个敢于承担的男人，而我却剑走偏锋，走骗了路。最近和我爸视频还是前天要钱交中公学费的时候，看着我爸那被电气焊烤红的脸我真的不知道怎么说出口。\n    很抱歉这样对你，我真的不知道如何承受你的喜欢，我很慌张，你的出现就想突然出现的礼物，让我手足无措。我问过很多人一个问题“你喜欢的人和喜欢你的人选择哪个”，好多人都是选择后者，我也是，可是那些人从来没做到。我更不用提了，根本无法直视一段你对我感情。\n    其实，你觉得我很成熟，你觉得我对你能拿捏得住，只是我理智存在的思考。我在读过的一本本书中也学到了如何对一个人，掌控一个人，获取一个人的信任。示弱，玩笑，甜言蜜语，都是感情中博弈的手段。\n    话又说回来，如果真的喜欢是可以经历时间的流逝的。就像表白之后我会思考，如何去合理的经营一段感情，如何用自己真正的爱去相伴余生。我不想那种谈恋爱就是玩玩的，那真的是很可怕的，我和你说过，这是对自己的不负责也是对自己另一半的不负责。\n    我想，在这个浮躁的社会，你我都需要静下心来，读一本自己喜欢的书，持久的爱着自己所爱的人。也许是时间会证明一切，不论生老病死，贫穷或富有。\n                                                       时二二年伍月拾叁日记",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/当我开始对一个女生有倾诉欲的时候，我会毫不犹豫的把她删除。不是因她的原因，而是因为我知道我是一个什么.md",
      "title": "当我开始对一个女生有倾诉欲的时候，我会毫不犹豫的把她删除。不是因她的原因，而是因为我知道我是一个什么",
      "abstract": "当我开始对一个女生有倾诉欲的时候，我会毫不犹豫的把她删除。不是因她的原因，而是因为我知道我是一个什么样的人。我很讨厌那种对谁都很温柔的女生，我总是把她对我的温柔误以为只是属于我的。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/我们以为贫穷就是饥饿、衣不蔽体和没有房。然而最大的贫穷，确是不被需要。没有爱和不被关心。如果爱只是一.md",
      "title": "我们以为贫穷就是饥饿、衣不蔽体和没有房。然而最大的贫穷，确是不被需要。没有爱和不被关心。如果爱只是一",
      "abstract": "我们以为贫穷就是饥饿、衣不蔽体和没有房。然而最大的贫穷，确是不被需要。没有爱和不被关心。如果爱只是一种感觉，那么当他遇到挑战，这种感觉很快就会消除。因为我们很容易在不同人的身上获得这种感觉，所以移情别恋最经常的说辞就是我没有感觉，但真真的爱并非一种感觉，他更多的是一种责任，是一种彼此的牺牲和彼此的成就。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/我做了一个梦，梦见一个人对我说，我的喜欢很廉价，而且很卑鄙。“你的喜欢来源于内心的自卑，你的灵魂是不.md",
      "title": "我做了一个梦，梦见一个人对我说，我的喜欢很廉价，而且很卑鄙。“你的喜欢来源于内心的自卑，你的灵魂是不",
      "abstract": "我做了一个梦，梦见一个人对我说，我的喜欢很廉价，而且很卑鄙。“你的喜欢来源于内心的自卑，你的灵魂是不完整的，所以当你看到别人的美好，你很容易去喜欢。同时，当她不再那么美好的时候，你的喜欢将荡然无存。”​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/我像一直鳗鲡,在产卵后过着属于自己的半生​.md",
      "title": "我像一直鳗鲡,在产卵后过着属于自己的半生​",
      "abstract": "我像一直鳗鲡,在产卵后过着属于自己的半生​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/我很好奇，为什么现在的每个人都是学到一个新词就想方设法的往那个新学到的词语上靠拢。.md",
      "title": "我很好奇，为什么现在的每个人都是学到一个新词就想方设法的往那个新学到的词语上靠拢。",
      "abstract": "           我很好奇，为什么现在的每个人都是学到一个新词就想方设法的往那个新学到的词语上靠拢。\n　　我睡不着，当我昏昏欲睡时，我梦见了我阅读过书中的好多人。我问他们，这究竟是为什么，他们没有说话，笑着让我自己去寻找答案。我在梦里遨游，遇见了在楼下逼着那个女孩跳楼的人，梦到微博当中不足十二岁还在追星的女孩，梦到了千千万万为了生活忙于奔波的路人，梦到了我这一生中遇到的各行各业的人。他们高谈阔论，说着自己的梦说着自己对这个世界的看法。\n　　我好像明白了些，原来，我们这个时代是个浅薄的时代。在快节奏的生活中，他们把自己眨眼瞥见的一句优美的话语视作人生哲理，把文学巨著中的一段话熟记于心。\n　　可是他们却忘记了，那些言语背后的故事。那些以为读了两三本书的人咄咄逼人，自以为读了几本书就是高人一等，却忘记了阅读的本质是为了塑造一个完整的人。\n　　我也是一个浅薄的人。。。在这个时代，每个人都是残缺的。。。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 6,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/我的人生有很多后悔，但是我知道我一旦反悔我就在否定一切。否定我曾经过的一切都没有意义，否定我现在的人.md",
      "title": "我的人生有很多后悔，但是我知道我一旦反悔我就在否定一切。否定我曾经过的一切都没有意义，否定我现在的人",
      "abstract": "我的人生有很多后悔，但是我知道我一旦反悔我就在否定一切。否定我曾经过的一切都没有意义，否定我现在的人格思想。所以后悔再多，我都不会这个样子来否定自己 。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/有些人读书往往只是为了找共鸣，为自己自私、愚蠢、狭隘的思想，找到片面的验证。所以往往也只有这种人，才.md",
      "title": "有些人读书往往只是为了找共鸣，为自己自私、愚蠢、狭隘的思想，找到片面的验证。所以往往也只有这种人，才",
      "abstract": "有些人读书往往只是为了找共鸣，为自己自私、愚蠢、狭隘的思想，找到片面的验证。所以往往也只有这种人，才会刻意把书里的各种语录铭记在心，找机会用来炫耀，或者自我标榜。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/果然，一副好皮囊，胜过千言万语。一句好话，胜过万般努力。​.md",
      "title": "果然，一副好皮囊，胜过千言万语。一句好话，胜过万般努力。​",
      "abstract": "果然，一副好皮囊，胜过千言万语。一句好话，胜过万般努力。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/煎和熬可以做一顿好菜，生活也是。​.md",
      "title": "煎和熬可以做一顿好菜，生活也是。​",
      "abstract": "煎和熬可以做一顿好菜，生活也是。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/这是2023年的中国，一个金钱想要用爱情腐化人们的时代，一个媒体想要用欣欣向荣的掩盖真实的存在，一个.md",
      "title": "这是2023年的中国，一个金钱想要用爱情腐化人们的时代，一个媒体想要用欣欣向荣的掩盖真实的存在，一个",
      "abstract": "这是2023年的中国，一个金钱想要用爱情腐化人们的时代，一个媒体想要用欣欣向荣的掩盖真实的存在，一个年轻人想要用抗争来证明自己的时代。清醒和愚昧就像是隔了一张纸，打破就是遇见，就是尖锐的争端。",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/随着长大，我们慢慢的都学会接纳。​.md",
      "title": "随着长大，我们慢慢的都学会接纳。​",
      "abstract": "随着长大，我们慢慢的都学会接纳。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/随笔/随笔记—被时间改变的我们.md",
      "title": "随笔记—被时间改变的我们",
      "abstract": "随笔记—被时间改变的我们\n只记得那是个传奇的年份，我的高中三年，多如牛毛的软件从我们的视野中升起，像一颗冉冉升起的太阳，虽然不耀眼，但已经出具锋芒。\n\n这是2021年，大概在五年前，人们口中没有口口说的哔哩哔哩，也没有什么深夜网易云，那时候，知乎也是刚刚进入了我的视野。\n\n想必他们为了公关也费了很大的力气吧，精选留言，报纸宣传，几乎随处可以见到它的身影。我拿起一本《读者》，上面那些美言杂句有着知乎的身影。我看视频，上面有着人们说着的网易云。\n\n那些悲惋凄惨，烙印着许多文艺青年的过往。那些美妙绝伦的句子，也刺痛了许多人的内心。也罢，那个时候，多是高中的生活罢了，压力软绵而又无力，这些软件给了好多人一个心灵的寄托，也给了一个温柔的港湾。因为互不认识，可以吐露心声。因为互不认识，可以听歌掩面而泣他人不知。\n\n渐渐的，所有的一切都变了味道。广告，硬性植入，等等，把用户挤得没有了喘息的余地。那些真正热爱这个平台的用户们还在坚持着固有的阵地。\n\n人们肆意的谩骂，说什么变了味道，招了安。后来我渐渐的才发现，这几年来变得不止是那些所谓的软件，还有我们自己。我们变得越来越尖酸刻薄，眼里容不得别人的意思错误。我们变得越来越懒，懒到自己的失败堆积如山而不动。\n\n我们是长大了，也渐渐地远离了当年的自己，随着这个社会的大齿轮渐渐的打磨自己的形状，软件也是，毕竟他们的背后也是人，为人父母，养一个家并不容易。不招商，他们很快就会消失在我们的视野。是非成败，总归是那无形齿轮的驱使。\n\n毕竟，网络上人们的忘性大，可是，我仍旧记得那个庆阳市那个跳楼的女孩，我仍旧记得楼下人们说着“怎么还不跳啊”的无耻嘴脸，三观的扭曲把他们扭曲成一个个嗜血的野兽，在人类社会中放肆横行。\n\n一切的悲哀，源于人们自己的不自知不自觉。更悲哀的是，人们对自己的自知自觉而骄傲。\n\n无奈，可悲。​",
      "dateFormat": "2024-11-12 10:34:51",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "随笔",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/# 电影推荐.md",
      "title": "# 电影推荐",
      "abstract": "\n​海上钢琴师\n阿甘正传\n肖申克的救赎\n跳出我天地\n模仿游戏\n美丽心灵\n心灵捕手\n放牛班的春天\n死亡诗\n社洛奇\n百万美元宝贝\n白日梦想家\n当幸福来敲门\n钢琴家\n辛德勒的名单\n泰坦尼克号\n美丽人生\n这个杀手不太冷\n触不可及\n闻香识女人\n落叶归根\n楚门的世界",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-06-04 08:29:41",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        }
      ],
      "stats": {
        "words": 23,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/# 这些东西是不会灭亡的.md",
      "title": "# 这些东西是不会灭亡的",
      "abstract": "# 这些东西是不会灭亡的\n\n**石川啄木**\n\n我一只胳膊靠在书桌上，吸着纸烟，一面将我的写字疲倦了的眼睛休息在摆钟的指针上面。我于是想着这样的事情。——凡一切的事物，倘若在我们感到有不便的时候，我们对于这些不便的地方可以不客气的去改革它。而且这样的做正是当然的，我们并不为别人的缘故而生活着，我们乃是为了自己的缘故而生活着的。譬如在短歌里，也是如此。我们对于将一首歌写作一行的办法，已经觉得不便，或者不自然了，那么便可以依了各首歌的调子，将这首歌写作两行，那首歌写作三行，就是了。即使有人要说，它本身如既然和我们的感情不能翕然相合，那么我们当然可以不要什么客气了。倘若三十一字这个限制有点不便，大可以尽量的去做增字的歌。（案：日本短歌定例三十一字，例外增加字数通称为字余。）至于歌的内容，也不必去听那些任意的拘束，说这不像是歌，或者说这不成为歌，可以别无限制，只管自由的说出来就好了。只要能够这样，如果人们怀着爱惜那在忙碌的生活之中，浮到心头又复随即消去的刹那刹那的感觉之心，在这期间歌这东西是不会灭亡的。即使现在的三十一字变成了四十一字，变成了五十一字，总之歌这东西是不会灭亡的。我们因了这个，也就能够使那爱惜刹那刹那的生命之心得到满足了。\n\n我这样想着，在那秒针正走了一圈的期间，凝然的坐着，我于是觉得我的心渐渐的阴暗起来了。——我所感到不便的，不仅是将一首歌写作一行这一件事情。但是我在现今能够如意的改革，可以如意的改革的，不过是这桌上的摆钟砚台墨水瓶的位置，以及歌的行款之类罢了。说起来，原是无可无不可的那些事情罢了。此外真是使我感到不便，感到苦痛的种种的东西，我岂不是连一个指头都不能触它一下么？不但如此，除却对于它们忍从屈服，继续的过那悲惨的二重生活以外，岂不是更没有别的生于此世的方法么？我自己也用了种种的话对于自己试为辩解，但是我的生活总是现在的家族制度，阶级制度，资本制度，知识买卖制度的牺牲。\n\n我转过眼来，看见像死人似的被抛在席上的一个木偶。歌也是我的悲哀的玩具罢了。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        }
      ],
      "stats": {
        "words": 6,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/# 一言随摘.md",
      "title": "# 一言随摘",
      "abstract": "# 一言随摘\n1. 什么样的人最快乐，极其自律的人和彻底摆烂的人，什么样的人最难过，心是清醒的，身子是堕落的。\n2. 你的好与坏都不够纯粹，所以你会痛苦\n3. 以前我太老实没有女孩，他们说男不坏女不爱，后来我就开始学坏，发现还是没有女孩，可能内心太善良坏的不够彻底，所以我决定在变好，结果发现好也不会了。\n4. 申请升职加薪时：你以为你不可替代吗?地球没了谁照样转。 申请休假时：你休息了谁干活？\n5. 祥子到死那天都觉得是自己不够努力。\n6. 面具之下满身痴情种，现实之中多是负心人\n7. 把海弄干的鱼，在海干前上了陆地，从一片黑暗森林奔向另一片黑暗森林\n8. 如果没有书，那么所有的知识就会永远消失。我们不能只建城墙，人们需要书，书才能带给人们希望。\n9. 真正的自由不是你想做什么就做什么，而是你不想做什么就不做什么\n10. 用阶级理论，给不如意的工作一个安慰。用性别理论，给不如意的情感一个安慰。这些大而化之的理论，可以解释所有的不如意，但却无法纠正任何一个微小的不如意。这些理论反而固化了人的认知，让人觉得“万方有罪，唯我无辜”。这表面上是对世界的指责，其实是对自己人生的放弃。\n11. 或许那些难关正是成长的代价\n12. 物质与意识的辩证关系：物质决定意识，意识反作用于物质\n13. “成功越大，运气的成分越高，自身水平所占的比例越低。”\n14.我渐渐的好像明白了，为什么一直放不下你不是因为你有多好，而是在几年前我们情窦初开的时候，你刚刚好进入了我的世界，也刚刚好给了我最初那种不是爱却也夹在喜欢中间的感觉一《被旧岛沉埋的我们》 \n15. 没有钱的时候，人的心中就往往充满恶念。没有好的音乐，人们的心中就充斥着郁闷。人最根本的本性，不是善与恶，而是回避痛苦。\n16. 大多数情况下，诉诸情绪总比诉诸逻辑要更容易得到响应，毕竟逻辑的门槛其实比情绪要高。\n\n\n​\n\n\n\n\n\n\n\n\n\n\n",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 36,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/半生封心，半生补 修修弄弄 漠归途.md",
      "title": "半生封心，半生补 修修弄弄 漠归途",
      "abstract": "半生封心，半生补 修修弄弄 漠归途",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/圣诞老人是不是更喜欢有钱的孩子​.md",
      "title": "圣诞老人是不是更喜欢有钱的孩子​",
      "abstract": "圣诞老人是不是更喜欢有钱的孩子​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/在看似欣欣向榮的社會背後 ，卻有很多人的精神卻是空虚的，信仰是缺失的行為是醜陋的​.md",
      "title": "在看似欣欣向榮的社會背後 ，卻有很多人的精神卻是空虚的，信仰是缺失的行為是醜陋的​",
      "abstract": "\n在看似欣欣向榮的社會背後 ，卻有很多人的精神卻是空虚的，信仰是缺失的行為是醜陋的​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/培根说：知识就是力量，更重要的是驾驭知识的能力。.md",
      "title": "培根说：知识就是力量，更重要的是驾驭知识的能力。",
      "abstract": "\n培根说：知识就是力量，更重要的是驾驭知识的能力。\n不要因为我们之所学而蒙蔽了我们的良知，要用我们的良知来驾驭我们之所学。\n这个世界充满着太多的聪明人，但是这个世界往往被这些聪明人搞得乌烟瘴气；这个世界充满了太多智力超群的人，往往是这些智力超群的人让我们今天的世界变得那么的令人悲伤啊。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/多一字恐失言.md",
      "title": "多一字恐失言",
      "abstract": "\n多一字恐失言\n少一句情不够\n扰了一时清净\n乱了心上秋\n最美四个字不过  如愿以偿\n最负人也不过   自作多情\n欢安长乐  素昧平生​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/女孩子受教育的目的不是去凌架众人之上，而应该是能清醒认识到社会的复杂性，并把握自己的人生与未来！！​.md",
      "title": "女孩子受教育的目的不是去凌架众人之上，而应该是能清醒认识到社会的复杂性，并把握自己的人生与未来！！​",
      "abstract": "女孩子受教育的目的不是去凌架众人之上，而应该是能清醒认识到社会的复杂性，并把握自己的人生与未来！！​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/如果不去遍历世界，我们就不知道什么是我们精神和情感的寄托，但我们一旦遍历了世界，却发现我们再也无法回.md",
      "title": "如果不去遍历世界，我们就不知道什么是我们精神和情感的寄托，但我们一旦遍历了世界，却发现我们再也无法回",
      "abstract": "如果不去遍历世界，我们就不知道什么是我们精神和情感的寄托，但我们一旦遍历了世界，却发现我们再也无法回到那美好的地方去了。当我们开始寻求，我们就已经失去，而我们不开始寻求，我们根本无法知道自己身边的一切是如此可贵。​​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/如果有人说“女人就该……”，会被各种角度指责。.md",
      "title": "如果有人说“女人就该……”，会被各种角度指责。",
      "abstract": "\n如果有人说“女人就该……”，会被各种角度指责。\n如果有人说“男人就该……”，哦好像不用“如果”，一直是这样的。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/我们对年龄的恐惧，其实并不在于年龄增长所带来的苍老，恐惧的是随着年龄的增长，我们仍然一无所得..md",
      "title": "我们对年龄的恐惧，其实并不在于年龄增长所带来的苍老，恐惧的是随着年龄的增长，我们仍然一无所得.",
      "abstract": "我们对年龄的恐惧，其实并不在于年龄增长所带来的苍老，恐惧的是随着年龄的增长，我们仍然一无所得.",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/文化就是根植于内心的修养，无需提醒的自觉，以约束为前提的自由，为别人着想的善良。”​.md",
      "title": "文化就是根植于内心的修养，无需提醒的自觉，以约束为前提的自由，为别人着想的善良。”​",
      "abstract": "文化就是根植于内心的修养，无需提醒的自觉，以约束为前提的自由，为别人着想的善良。”​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/无论今天发生多么糟糕的事，都不应该感到悲伤，今天是你往后日子里最年轻的一天了，因为有明天，今天永远只.md",
      "title": "无论今天发生多么糟糕的事，都不应该感到悲伤，今天是你往后日子里最年轻的一天了，因为有明天，今天永远只",
      "abstract": "无论今天发生多么糟糕的事，都不应该感到悲伤，今天是你往后日子里最年轻的一天了，因为有明天，今天永远只是起跑线。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/有一天，你会静下来，像个局外人一样看着自己的故事，笑着摇摇头​.md",
      "title": "有一天，你会静下来，像个局外人一样看着自己的故事，笑着摇摇头​",
      "abstract": "有一天，你会静下来，像个局外人一样看着自己的故事，笑着摇摇头​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/有朋友让我谈谈虚伪，我说自己就很虚伪。但惟有人会虚伪，动物不会。.md",
      "title": "有朋友让我谈谈虚伪，我说自己就很虚伪。但惟有人会虚伪，动物不会。",
      "abstract": "有朋友让我谈谈虚伪，我说自己就很虚伪。但惟有人会虚伪，动物不会。",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/标签化是贬低和侮辱人的一种手段。.md",
      "title": "标签化是贬低和侮辱人的一种手段。",
      "abstract": "标签化是贬低和侮辱人的一种手段。",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/没有结局的时候，过程很重要，有结局的时候，过程就显得没有结局重要了…​.md",
      "title": "没有结局的时候，过程很重要，有结局的时候，过程就显得没有结局重要了…​",
      "abstract": "没有结局的时候，过程很重要，有结局的时候，过程就显得没有结局重要了…​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/现在很多国内的年轻人开演唱会时跟着idol喊自己“要劳斯莱斯换着开，每天跟美女hustle”，结果唱.md",
      "title": "现在很多国内的年轻人开演唱会时跟着idol喊自己“要劳斯莱斯换着开，每天跟美女hustle”，结果唱",
      "abstract": "现在很多国内的年轻人开演唱会时跟着idol喊自己“要劳斯莱斯换着开，每天跟美女hustle”，结果唱完了自己去挤地铁十号线回家。\n眼下的潮流对他的生活是割裂的，他们吃下了时髦的面包，内心却依然饿得咕咕叫。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/而如今不同的是，每个人都以为自己是自己世界的英雄，在自己的世界里活得多姿多彩，或者是惋惜遗憾。.md",
      "title": "而如今不同的是，每个人都以为自己是自己世界的英雄，在自己的世界里活得多姿多彩，或者是惋惜遗憾。",
      "abstract": "而如今不同的是，每个人都以为自己是自己世界的英雄，在自己的世界里活得多姿多彩，或者是惋惜遗憾。",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/自己不负责任还要怨全世界.md",
      "title": "自己不负责任还要怨全世界",
      "abstract": "自己不负责任还要怨全世界\n五十年前，人说武侠小说会毁掉下一代。\n四十年前，人说流行音乐能毁掉下一代。\n三十年前，人们发现电视节目要毁掉下一代。\n二十年前，人民说互联网开始毁掉下一代。\n十年前，人们说电子游戏正在毁掉下一代。\n现在，人们说短视频已经毁掉下一代。\n人类的发展证明： 【没有什么能毁掉下一代，除了上一代】\n他们希望你幸福，但他们不希望你有属于自己的幸福\n他们希望你有能被别人认可的、被别人羡慕的、能给他们挣面子的“幸福”​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/舒淇在《剩者为王》里有段经典台词： _ 我就是死要面子，自尊心特别重，我只要一发现对方没有那么喜欢我.md",
      "title": "舒淇在《剩者为王》里有段经典台词： _ 我就是死要面子，自尊心特别重，我只要一发现对方没有那么喜欢我",
      "abstract": "舒淇在《剩者为王》里有段经典台词： \" 我就是死要面子，自尊心特别重，我只要一发现对方没有那么喜欢我了，我就会把这段感情判死刑，不想勉强自己喜欢别人，也绝不勉强别人喜欢自己，对方迈一步，我会更热情，对方退一步，我就想消失。\"​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 3,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/让你失望的人，怎么可能只让你失望一次。 ​​​.md",
      "title": "让你失望的人，怎么可能只让你失望一次。 ​​​",
      "abstract": "让你失望的人，怎么可能只让你失望一次。 ​​​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/请用你绝对清醒的理智压制你不该有的感情​.md",
      "title": "请用你绝对清醒的理智压制你不该有的感情​",
      "abstract": "请用你绝对清醒的理智压制你不该有的感情​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/句读/这个世间，没钱有没钱人苦恼、有钱人有有钱人的癫狂。​.md",
      "title": "这个世间，没钱有没钱人苦恼、有钱人有有钱人的癫狂。​",
      "abstract": " 这个世间，没钱有没钱人苦恼、有钱人有有钱人的癫狂。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/# 少年赠她红玫瑰.md",
      "title": "# 少年赠她红玫瑰",
      "abstract": "# 少年赠她红玫瑰\n\n     桌上玫瑰花娇艳的红，刺入眼。\n年少往事，落在白纸上，笔尖意犹未尽。照片里，少年坐在凳子上，埋头奋笔疾书，少女靠在桌前，单手支撑着脑袋，一手比着大大耶，露出明媚笑颜。\n早恋，暗恋，学霸，学渣。\n四个关键词，敲定少年少女整个青春主题。\n\n“小王子驯服狐狸，却顾着玫瑰花。”\n“我不想成为你的狐狸。”\n少女洋洋洒洒几千字小作文，归纳总结提点就两句话。搁下笔，少年伸个懒腰，看看窗外蓝天白云，放松眼睛。黑板前，她垫着脚擦完最后一笔，夕阳余晖落在空荡教室里。\n“你还不走?”\n“我等你啊。”\n\n“数学好难啊。”她嘟囔着。\n“要是不学就好了。”少年没作声，弯下腰蹲在她前面，为她系上散开的鞋带。少女一怔，止住抱怨。低头，他眉眼温柔。\n再回神，他拿着热气腾腾的鱼丸串，站在身边。\n“趁热吃，小心烫。”\n少女呆呆，小声应道，接过鱼丸咬一口，被烫得眼泪汪汪，抬头看他。他伸手摸了摸人头。\n“都说了，让你小心烫。”\n\n“你说，那时候，我主动点，不恃宠而骄…”\n方潮停下来。夏屿沉默。\n\n第一次吵架，是在午后蝉鸣声中，他刚为测验分数懊恼，就见她蹦蹦跳跳拿着薯片可乐进来。\n“没啥，就一次考试，放轻松。”少女愉悦话落，一罐可乐落座他眼前。\n许是她动作幅度微大，少女卷子从抽屉滑出，惨烈红线拼出“34”分，扎眼。她手忙脚乱将它塞进去，皱皱巴巴。他摊手，眉皱更紧。\n“拿出来。”\n“别看。”若是他细致，就能注意到她羞红的眼。\n\n“你是天之骄子，我只是咸鱼。”她振振有词。\n抿嘴，杏眸瞪圆，被踩中尾巴的猫附体，活灵活现。没底气的人，声音越大。\n“咸鱼可以翻身。”他神色淡淡，懒于争执。有这功夫，不如再做两道题，以备考试。他转身，弯腰捡起掉在桌腿边的可乐罐，拉开环，递向她。\n她没服软。\n少女看了眼他脸色，忽将可乐罐推开。没防备，咖啡色液体溅落在白衣蓝裤脚上，污渍染白，乱七八糟一片，他没说话。\n冷战开始了。\n\n他身后没了小尾巴。\n放学，下课，做作业，等忙完，夕阳西下。背着包抱着书，耳边没有少女往常叽叽喳喳。\n穿过走廊，路过栀子花丛，洁白花儿叠着幽香，绿叶之下美如油画。风过，沙沙，砖红墙面爬山虎伸展枝桠。突然，有些无聊了。\n路边快收摊，他看着鱼丸买下一串烤肠，却在付完钱后没了胃口，流浪猫凑在远处观望。\n少年走了，夕阳拉出长长影子跟随。猫儿快速上前，狼吞虎咽。\n\n5月20日。\n班里闹哄哄，你追我赶。他坐在桌前，坐得笔直。手心有汗，握着笔杆，脸上风轻云淡。\n少女在友人陪伴下，拎着零食袋，满载而归。看他发呆，敛去笑容，从袋里掏出一罐冰镇可乐，可乐瓶身泛着白雾。\n他稳着没出声。少女看了眼他微微一笑，将可乐罐放在他身旁同桌空桌上。\n“我的呢?”少年稳不住了。\n“这还没入夏，咋就有蚊子闹哄哄了？奇怪！”少女说完，拿起桌面的书在耳旁轻扇了扇。\n\n“巧克力?谁送的?”\n前后桌围过来看着少女羞红脸藏不住笑。刚打完球，大汗淋漓抱着篮球回来的同桌，冲少年挤眉弄眼，意思很明显:前两天问我哪款合适，在这儿?\n少年起身让人回座，一副“懂得别说”表情。\n同桌点头，落座，吃瓜不显事大，探身，起哄。\n“诶诶诶诶！谁送的?有情况啊！”\n一群人推推搡搡，笑开了。\n“别看我，我可不知道。”\n听同桌话落，少年拿出纸，擦擦手心汗水，继续写题。\n\n“我们和好吧。我原谅你了。本姑娘大人有大量。我知道，巧克力是你送的。”\n上课时，她递来一张小纸条，秀气钢笔字。\n“给玫瑰花的礼物，也就你这么肉麻，土味情话太俗了！”\n收到纸条，少年嘴角藏不住上扬。\n傲娇啥，小姑娘，还土味情话，你不是甘之如饴吗？​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 54,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/# 自律是反人性的，拒绝拖延从不要对自己太狠开始.md",
      "title": "# 自律是反人性的，拒绝拖延从不要对自己太狠开始",
      "abstract": "# 自律是反人性的，拒绝拖延从不要对自己太狠开始\n\n**文/渔眠小姐**\n\n到手一项工作任务，你很清楚它非常重要，也大概知道该怎么着手、需要协同什么样的人、经历一些什么步骤，但凡哪个环节有让你内心抵触的地方你总会选择拖延，甚至不需要任何理由，仅是习惯性就开始拖延。\n\n在拖延的这段时间里，你并不会忘记它，反而它时时刻刻在你的脑海里出没，玩的时候不尽兴，陪家人的时候不专注，睡的时候不踏实，可以说它实实在在的影响了你在做其他事情时本该有的状态和情绪，但是，就是不愿意开始！\n\n等到截止期限的最后两天，你终于不得不硬着头皮开始吃这只青蛙，你精神高度集中，不再一会刷手机，一会泡咖啡，一会刷新闻八卦，一会去趟卫生间……这样，经过无比专注的两天，你最终赶在最后期限完成了工作、交了差，重点是工作质量是过关的，你的心顿时轻快了起来，这个时候空气是新鲜的，孩子是可爱的，万事万物都是可控的……\n\n经过这件事，理性再次告诉你，拖延真的是一个特别不好的习惯，下次一定要立即开始处理难缠而重要的事情，因为这样做的好处简直不要太多，比如早处理可以有充足的时间去发现问题、去改进，从而做的尽善尽美；比如优先吃掉这只丑陋的青蛙，一整天就可以身心愉悦、全情投入等等。\n\n然而，理性这个东西总是像一位正确而刻板的教导主任，人内心真实的自我又特别像一个不受管教的小孩，你说的都对，但我就是不愿意听，说的多了，还特别容易产生厌烦逆反情绪。\n\n乖一点的孩子可能会克制一段时间，能不能坚持下去不一定；而调皮“乐观”一点的孩子则完全获得了另一个有趣的经验：我的潜力自己都不敢想象，两个星期的任务用两天就能完美搞定，下次可以继续安心拖着了……\n\n你看，一个人的想法远比自己想象的更天马行空而不受束缚，时间管理的书籍看了无数本，看的过程热血沸腾，开始执行的几天也干劲十足，但只要期间有一天断开，基本就彻底回归，放飞自我的那种自由完全盖过拖延带来的痛苦……\n\n那么，到底怎样才能有效的拒绝拖延呢？\n\n我的答案是，不要对自己太狠，顺着自己的心来。\n\n我始终认为靠意志力支撑的自律（让你感到痛苦的自律）是反人性的，而反人性的东西是很难坚持下去的。\n\n能坚持下去的，一定是找到了让心舒服，从而情愿去做的方法。\n\n你看到听到有那么多牛人自律的可怕，他们坚持锻炼、坚持读书、坚持早起、坚持对工作保有热情……你忍不住一边佩服他们的自控力太强大，一边想他们不累吗？其实，你不知道的是，他们可能真的不觉得累，甚至乐在其中。\n图片\n意志力是一种有限的能量，今天的量用完了就没有了，所以要省着用，没做到某些事时不要急着苛责自己意志力不足，这种苛责本身也是一种浪费，运用一些方法达到我们的目的就好。\n\n比如，早晨在睡梦中被闹铃惊醒，要做的不是用意志力与离不开被窝的身心做对抗，而是开灯，灯光会唤醒身体，启动起床指令，等一会，你自会发现起床没那么难了。\n\n比如，不想立即开始一件事，告诉自己只做五分钟，到时间了不想做今天就不做，总之给自己预设的心理压力越小越好，先哄着自己开了头，开了头最难的一步就已经跨过去了，之后是顺理成章的事情。\n\n亲爱的你，不要焦虑，不要强迫，放松，听听内心的声音，先安抚心，再安排事，然后向前一步，再向前一步，慢慢抵达你想要去的地方……\n\n![img](http://www.zreading.cn/wp-content/uploads/2021/04/2021-04-21_192058.jpg)\n\n左岸记：柏拉图说：“自制是一种秩序，一种对于快乐与欲望的控制。”所以说自律，不是一个人的性格特质，而是一次次行为选择的结果。真正的自律，不是一味克制自己的，应该是积极主动地自我实现。自律，在自律的同时，适当满足自己的欲望。会获得更多的动力，激励着自己，继续坚持下去。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 22,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/# 谈谈人生与喜欢.md",
      "title": "# 谈谈人生与喜欢",
      "abstract": "# 谈谈人生与喜欢\n\n**人生**\n\n\n以前的我是喜欢喜剧的结尾的，在不断的成长与经历中，这种喜剧和完美都成了奢求。因为生活的不如愿才会寄托于希望于那些精神文化的需求，才会寄托于那些完美的大团圆的结局。\n在不断的经历过悲欢离合，奢望和失望之后，我才逐渐的认识到，悲剧才是人这一生最珍贵的写照。\n人呐，在经历过什么之后才会有太多的灵感，太多的所思所想。才会在这一次次的打击中浴火重生，成长为我们最不希望的那个人。\n我是一个喜欢被动的人，仿佛这一切都是我随波逐流而走。其实也对，别人说什么，我去做什么，努力的活成他们喜欢的样子。我也在活着之中失去了自己，忘了自己真正的需要。其实我也是很有自己的想法的，不过，因为大众的原因，我憋住了。随大流总归不会错吧，于是我失去了无数个我的机会。\n如果要真的谈人生的话其实是个很无聊的一件事情，古今中外谈的人太多太多了。东西一旦到了太多的份上，就滥了。但人之所以为人，人生还真得谈，因为在人生过程中，总有些地方让你感慨万端。\n我不希望很多人像我一样都在被动的活着，这注定着你的平庸。我也曾热血过，也曾努力过，可是到头来都被现实冲的一丝不剩。学谁都不要学我。人生是苦，但是来过一趟，总该要留下点什么吧。\n\n\n**喜欢**\n\n\n这几天脑子一直不怎么好用，浑浑噩噩的。也许是心中有了挂念的人。我很不希望这样的。这样的生活反而让我更加的痛苦了。\n吃饭的时候，在想她有没有吃。\n睡觉的时候，在想她有没有睡。\n她和别的男生说话我会吃醋。\n她在刷抖音我会好奇的看一眼。\n就连看到美丽的风景都要和她分享过去。\n可是，得到的结果总归是那几句，“睡了”“真好看”“可”“下次吧”“再说吧”\n我有时候在想这些是不是她在吊着我，也许是呢。感性不会太好的，不如理性一些。我始终会相信，时间会冲淡一切的。有时候心中的结需要自己去慢慢解开，这会是一个漫长而痛苦的过程。\n青春的喜欢，完全是充满了荷尔蒙的躁动，真正能理智下来的人寥寥无几。所谓的一见钟情，不过是一见钟性罢了。大家都身为一个普通人，终归是回向现实屈服和低头的。\n青春，把爱情放一放，做一些更有趣的事情，写写日记，看看书，比什么都好。\n\n有时候我写文字，不过是为了劝解自己，寻找一个精神的解脱。白天话说少了，到了晚上，文字反而成了一种情绪的发泄方式。\n\n**如何停止喜欢一个不喜欢自己的人**\n\n\n你如果看下去，我相信你是一个自卑者，不用生气，因为我也是这样。\n喜欢不喜欢自己的人，或是甘愿待在这样一个人身边，一个主要的原因是低自尊。低自尊者总是觉得自己不够好，相信自己配不上美好的事物和人。\n你还需要认识到健康的亲密关系应该是什么样子的。双方平等，互相尊重，肯定对方的价值，重视对方的意愿，这些都是建立一段好的亲密关系的基础。在这样的关系里，两个人就好似两棵依偎着彼此的树，即使亲密得将枝叶都缠绕在一起，也是始终相互独立的两棵树。它们不会让身边的树按照自己想象中的模样生长，它们爱着对方本来的模样。\n有句话说：“人与人之间想要保持长久舒适的关系，靠的是共性和吸引 ，而不是压迫、捆绑，奉承和一味的付出，以及道德式的自我感动。”\n\n\n**再谈人生**\n\n\n余秋雨曾经对人生有一段很美的描述，他说“成熟是一种明亮而不刺眼的光辉，一种圆润而不腻耳的声响，一种不再需要对别人察言观色的从容，一种终于停止了向周围申诉求告的大气，一种不理会喧闹的微笑，一种洗涮了偏激的淡漠，一种无需声说的厚实，一种看很远但并不陡峭的高度”。这句话，既形象又深刻。\n\n曾经看过罗翔老师的一个视频，他引用过古希腊哲学家爱比克泰德曾经说过的一句著名的话:“我们登上并非我们所选择的舞台，演出并非我们所选择的剧本。”\n\n的确，我们来到这个世上没有一个人是自愿到来到的。每个人都扮演着不同的角色，适时的上场演义自己的故事。人生哪有那么多的如愿，只不过是在不断演绎的过程中学会了忍。\n\n人生也有太多的来不及，最怕离别的那句话成为了后会无期。\n\n早点睡吧，晚安！​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 33,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/“你锯倒这棵树用了多长时间？”.md",
      "title": "“你锯倒这棵树用了多长时间？”",
      "abstract": "\n“你锯倒这棵树用了多长时间？”\n“不到十分钟吧。”\n“它多少岁了？”\n“不知道，数数它的年轮呗。”\n“我数了，三百岁，三百多年啊，它发芽的时候还是明朝呢，它经历过多少风雨，见证过多少事，可你只用几分钟就把它锯倒了，你真没感到什么？”\n“你想让我感到什么？不就是一棵树吗？这片林子里最不缺的就是树，比它年长的老松多得是！”\n\n“你消灭这个文明用了多长时间？”\n“不到十天吧。”\n“它多少岁了？”\n“不知道，测一测它的生物化石呗。”\n“我测过了，三十多亿岁，三十多亿年啊，它诞生的时候还是现在宇宙寿命的四分之一呢，它经历过多少风雨，见证过多少事，可你只用了几天时间就把它降到了二维，你真没感到什么？”\n“你想让我感到什么？不就是一个文明吗？这片宇宙里最不缺的就是文明，比它高级的文明多得是！​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 13,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/人对于人工智能的思考，并不简简单单的是抵触，而是畏惧。.md",
      "title": "人对于人工智能的思考，并不简简单单的是抵触，而是畏惧。",
      "abstract": "人对于人工智能的思考，并不简简单单的是抵触，而是畏惧。\n因为畏惧老虎猛兽，才出现了猎枪，因为畏惧大海和鲸鱼的庞大才出现了潜水艇。这样说莫过于以偏概全了，人和人也是存在畏惧的，因为畏惧才会让这些庞然大物尖兵利器，浮现于战火硝烟当中。\n出现的仿生，大致是对生物本事的一种超越。\n当人们见到一个比自己智力还高的一个奇行种出现在自己的视野当中之时，当然也会畏惧，对人工智能的可控也是人类沾沾自喜的模样。\n遏制，是畏惧人工智能的真正发展，没人会想到人类造出的比自己还要强大的生物或者是机械的时候是否会杀死自己。\n这种畏惧会是动力也会是人对于自我本身的一种限制。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 6,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/初一时，智能手机开始流行，我爸用老板给的奖金买了一部。我出于好奇，喜欢把玩我爸的新手机。.md",
      "title": "初一时，智能手机开始流行，我爸用老板给的奖金买了一部。我出于好奇，喜欢把玩我爸的新手机。",
      "abstract": "\n初一时，智能手机开始流行，我爸用老板给的奖金买了一部。我出于好奇，喜欢把玩我爸的新手机。\n\n有一天我悄悄地在他的手机上打开短信，在发件箱看见一条短信，上面写道：“宝贝，吃饭没？”\n\n那个手机号码不是我妈的，也不是我的，我只看得到短信的那头是一个姓余的人。这条短信之前的信息应该是被删干净了，至于之后还没有回复。\n\n尽管那时的我才初一，我也知道这条短信意味着什么残酷的事实。仿佛我才是被出轨的妻子一样，我拿着手机颤抖、恍惚，露出一脸不可置信又愤怒的神情，尽管根本没人看见我在干什么。\n\n随后我把手机放回了我爸的包里。我背下了那串面目可憎的号码，用我自己的手机拨了过去。电话那头果然是一个年轻的女声，冲着我喂了好几遍。我没有出声，她就挂断了电话。\n\n自那以后，我报复一般地不停朝那个号码打骚扰电话。早上起来上厕所打一遍，走在上学路上打一遍；中午午休时打一遍，晚上进了被窝再打一遍。\n\n每次打骚扰电话我都不出声，只听那个女人隔着电话不停地喊喂，然后挂断电话。有时她还没等接听就直接挂断了，我不甘心，要一直打到她接听为止。有时她被我骚扰到抓狂，对着电话大声爆粗口，然后还是挂断电话。\n\n激怒她就是我的目的，她越是撒泼，我心里越是暗爽。\n\n我继续没日没夜地拨打骚扰电话，在这期间我再也没在我爸的手机上发现有关这个女人的任何痕迹。也许他和她已经断了联系，也许他只是把暧昧的信息都删干净了，但只要我妈看不到，这看似无理取闹的一切就是有意义的。\n\n骚扰电话持续了一个多星期。在一个我爸声称赴饭局而没有回家的晚上，我在被窝里第无数次拨打了那串倒背如流的号码。\n\n电话通了，这次不再是那个女人对着电话喂喂喂，而是传来我爸略带怒意的声音：“你是哪个？”\n\n我拿着自己的手机，再一次颤抖、恍惚。我本应该对着我爸破口大骂，骂他这个不要脸的男人，对不起我和我妈。可我好像习惯了在打骚扰电话时保持沉默一样，一句话也说不出来。\n\n随即那头挂断了电话。\n\n我在被窝里无声地流泪。我用不到一分钟就记住了情妇的电话号码，他却认不出他十三岁的儿子的来电。\n\n自那以后我再也没有打过骚扰电话，我发现我这些天以来的坚持都是徒劳的，我再也不能拉回他那颗飘忽在外的心。由于我和我爸的隐瞒，我们一家人过着和从前一般平静的日子，我也不知道他和情妇如今是否还在纠缠不清。\n\n爸妈步入五十岁以后，关系越发冷漠疏离。这难道真的是因为婚龄渐长吗？只有我知道，早在我初一的那一年，他们的婚姻就因为其中一方不可挽回的错误而化作了泡影。至于后来的日子，都是一场残忍无比却没有落幕的戏。\n\n我把秘密看在眼里，却只能在心头唏嘘。",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 18,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/女孩终于明白，她追求的所谓爱情、婚姻，骨子里其实就是亟需一场陪伴。爱情、婚姻，是属于特定某个人的，陪.md",
      "title": "女孩终于明白，她追求的所谓爱情、婚姻，骨子里其实就是亟需一场陪伴。爱情、婚姻，是属于特定某个人的，陪",
      "abstract": "女孩终于明白，她追求的所谓爱情、婚姻，骨子里其实就是亟需一场陪伴。爱情、婚姻，是属于特定某个人的，陪伴就不一定。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/好的两性关系有弹性，彼此既非僵硬地占有，也非软弱地依附。相爱的人给予对方的最好礼物是自由。两个自由人.md",
      "title": "好的两性关系有弹性，彼此既非僵硬地占有，也非软弱地依附。相爱的人给予对方的最好礼物是自由。两个自由人",
      "abstract": "好的两性关系有弹性，彼此既非僵硬地占有，也非软弱地依附。相爱的人给予对方的最好礼物是自由。两个自由人之间的爱，拥有必要的张力。这种爱牢固，但不板结；缠绵，但不粘滞。没有缝隙的爱太可怕了，爱情在其中失去了自由呼吸的空间，迟早要室息。\n好的两性关系当然也有灵性，双方不但获得官能的满足，而且获得心灵的愉悦。现代生活的匆忙是性爱的大敌，它省略细节，缩减过程，把两性关系简化为短促的发泄。两性的肉体接触更随便了，彼此在精神上却更陌生了。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/当一个人痛苦的时候才会变得才华横溢，当我的生活步入正轨时，我开始跟你一样，像你忘记我那样忘记你，然后.md",
      "title": "当一个人痛苦的时候才会变得才华横溢，当我的生活步入正轨时，我开始跟你一样，像你忘记我那样忘记你，然后",
      "abstract": "当一个人痛苦的时候才会变得才华横溢，当我的生活步入正轨时，我开始跟你一样，像你忘记我那样忘记你，然后忘掉那些痛苦，开始变得平庸可耻。我不愿这样，也不愿意这样，我无法触及你，你就像盖茨比的梦，璀璨无比，却又触不可及。前方的路上诱惑太多，我没有盖茨比那么了不起，我可能走上其他的路，无法一直追逐你的脚步。​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/当你意识到自己的虚伪可能意味着你愿意朝着更高的标杆去前进。虽然这种前进反而会让你更深刻的认识到虚伪的.md",
      "title": "当你意识到自己的虚伪可能意味着你愿意朝着更高的标杆去前进。虽然这种前进反而会让你更深刻的认识到虚伪的",
      "abstract": "当你意识到自己的虚伪可能意味着你愿意朝着更高的标杆去前进。虽然这种前进反而会让你更深刻的认识到虚伪的本性，不断地督促你正视自己内心深处的幽暗。这种幽暗翻江倒海，稍有不慎就会外泄成灾，所以需要去倾听他人的批评和自己内心的责问，不做狡辩，日拱一卒，每天离虚伪远一点。",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/当你达到最基本的要求，就会想要精致的房子豪华的汽车 人性不以个人意志为转移​.md",
      "title": "当你达到最基本的要求，就会想要精致的房子豪华的汽车 人性不以个人意志为转移​",
      "abstract": "当你达到最基本的要求，就会想要精致的房子豪华的汽车 人性不以个人意志为转移​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 2,
        "text": "1分钟"
      }
    },
    {
      "link": "蜜蜂便签/收藏/我不太喜欢跟她打电话，也懒得跟她沟通。嫌她反应好慢，理解能力又差，也没见过什么市面，又笨又善良，因此.md",
      "title": "我不太喜欢跟她打电话，也懒得跟她沟通。嫌她反应好慢，理解能力又差，也没见过什么市面，又笨又善良，因此",
      "abstract": "\n我不太喜欢跟她打电话，也懒得跟她沟通。嫌她反应好慢，理解能力又差，也没见过什么市面，又笨又善良，因此被骗过很多次也不长记性.好多时候跟她说话我都听不下去，逻辑能力又差说什么都说不清楚，絮絮叨叨的老是重复着一些事情.\n\n什么都不懂，什么都要我教，什么都要问我。\n很多时候听着听着我总感觉有种说不出的烦闷，\n然后打断她说：\n好了我什么都知道，行了别说了.\n那天我在外面，她在微信支支吾吾的说她被朋友骗了5000.\n或许是怕我说她，赶忙跟我解释\n说这是她的好朋友，想拉她进什么项目.她被说的没办法又有些心动最后了5000.那个人还叫她去发展下级.\n她觉得不对劲却不知道怎么办，只能告诉我.\n我气的话都说不出来.\n气她永远都这么蠢，气她为什么不提前告诉我，气她几十岁的人还是贪图小利怕拒绝人就被这些简单的东西骗来骗去.\n气她一辈子永远就这点出息.\n我的言辞逐渐激烈起来，打着长串的字一步一步给她分析\n告诉她这是很明显的传销.\n告诉她这类朋友必须保持距离淡开交往\n教她如何去应对那些朋友，接下来怎么办.\n告诉她以后必须有什么事都要跟我提前商量.\n她不断的发着那个早就没人用的大笑脸表情表示她在听.\n我看着她的反应越说越气，烦燥的打出了两句更激烈的话准备按出发送\n却看到显示对方正在输入\n断断续续，一种迟钝的笨拙感几乎要透出屏幕。\n我突然觉得好像被戳漏气的气球一下子瘪了下来。\n顿了顿，按着删除箭头慢慢的一字一字的删掉那些有些激烈的指责的话.\n正准备继续说些什么\n\n屏幕上蹦出一段话\n“儿子你现在懂好多东西啊.小时候你就那么聪明和懂事.你现在更让人放心了！\n现在社会发展太快了.\n老妈什么都不懂又太笨了，反应也跟不上.老是被别人骗.\n但是有你在我就觉得好安心！[呲牙]”\n后面又是那个熟悉的落伍的大笑脸的表情.\n\n我有些愣愣的看着那段话.\n感觉心里有一股股酸楚揪着心口缓慢的溢出.\n好像看到了网络那端满头银发和憔悴疲惫透的脸。\n那种感觉漫上我的眼角眉梢让我瞬间散去了全部怒气.\n她还在那边断断续续的打字，\n“儿子你以后要多教教老妈....\n我之前怕你生气都不敢跟你说.....[呲牙]\n跟你说了我心里好多了！现在感觉特别轻松，她是我很好的朋友.我压力特别大.....\n[呲牙]\n我以后什么都先问你，我多给你打电话.......\n你不要嫌我烦啊.\n[呲牙]\n妈都听你的.”\n一行一行的话不断的在对话框蹦.显示着那端的人急切的想要诉说些什么.\n我摸着手机反复看着这些话，手都开始颤抖，努力的深吸气想把那股窒息一样的酸楚感压下去，却半天打不出剩余的话。\n也许是看这边没有反应\n她顿了顿开始继续说\n“儿子你吃饭没有？快月末了你钱还够用吗....\n你现在在做什么啊，还需要钱吗？\n儿子 你还在看吗？”\n看到最后一句的时候，我努力维持的平静终于被打破了，无地自容的愧疚感像利刀一样狠狠的扎了进来。\n我紧紧的捏着手机慢慢的蹲下去，把头埋在双腿之间，屏幕不断的花，又不断的被我擦干，\n我双手颤抖着打字：\n“老妈我在看\n没关系的老妈[呲牙]\n就5000块也不多没事的\n我在做事了，能赚点钱.过几天就有些钱到了\n被骗了我再给你嘛！\n[呲牙]\n我在做挺多事儿的.\n我那么聪明你知道的嘛，你不用担心我啊\n你以后什么事一定要告诉我啊老妈\n我才不会说你的\n不懂我教你嘛有什么关系\n小时候都是你教我的\n我是你儿子嘛.\n[呲牙]”\n\n打完最后一句把头埋在双手之间蹲在路边缓了很久。\n\n我拿着你的钱，享受着你制造的温暖.\n生活背靠着你提供的一切。\n如今学着你没听过的知识，见着你没见过的世面，接触着你没看过的世界。\n我长大了，你老去了，就好像我吸干了你的营养。\n\n学会了对陌生人宽容对朋友和蔼,转头看着你一辈子困于方寸之地打转的时候，却开始嫌弃你的笨拙与不堪.\n你不是没有机会出去，只是把他让给了我。\n你不是没没事漂亮，只是把他让给了我。你不是没心思学习，只是把他让给了我。你不是不渴望光鲜亮丽，只是把它让给了我。\n你整个世界都心甘情愿的让给了我，却老是看着我愧疚地低头不断重复着，\n“妈妈没有能力，什么都没办法给你.”\n\n你还要给我什么呢？\n\n看啊这兜兜转转二十年，折柳赠红颜.\n\n你就是我的英雄.​",
      "dateFormat": "2024-11-12 10:34:50",
      "changeTime": "2024-03-25 16:29:26",
      "tags": [
        {
          "name": "蜜蜂便签",
          "link": "#"
        },
        {
          "name": "收藏",
          "link": "#"
        }
      ],
      "stats": {
        "words": 82,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024年9月30日.md",
      "title": "2024年9月30日",
      "abstract": "\n\n##  2024年9月30日\n1. 永远需要一个莫名其妙的形式来预告自己接下来虚无缥缈的行动。朋友圈，个性签名，手机桌面，手机壳。自己画的饼只有自己吃的最香，自己的梦也只有在梦里才会实现\n2. 现代社会的人，似乎对自己“自由”的权力越来越在意，细分到LGBT、男女关系、生育态度、大国关系等等，而一个充满秩序的文明社会，是不能有无限制自由的（包括看盗版），这或许就是大家感觉的现代化压抑原因之一。\n3. 追求高级、美、真实、时间亦或是其他美好的事物，是人的本性，对美不同的定义，让人们得以划分自己的属性，在“滤镜”的加持下，组成五彩斑斓的社会。​\n4. I am not afraid of storms, for I am learning how to sail my ship​\n5. “多数世人， 甚至可以说天下芸芸众生， 都过着随遇而安的生活。纵然有人愤然以为自己似方凿圆枘， 只要换个环境， 可能更有作为， 多数人若不是对各种遭际安之若泰， 也只有得过且过地认命。这些人像有轨电车， 永远在同样的轨道上运行， 倒回去再开出来， 周而复始， 一成不变， 直到爬不动了被当作废铁卖掉。在这世界上， 你难得找到一个勇于掌握自己人生轨迹的人。倘若果真找到， 那就值得好好看看此人了。”—— 毛姆​\n6. “我慢慢明白了为什么我不快乐，因为我总是期待一个结果。看一本书，期待它让我变得深刻；吃饭游泳，期待它让我一斤斤瘦下来；发一条微信，期待它被回复；对别人好，期待被回待以好；写一个故事说一个心情期待被关注，被安慰；参加一个活动期待换来充实丰富的经历。这些预设的期待如果实现了，我长舒一口气，如果没实现呢，就自怨自艾。可是小时候也是同一个我，用一个下午的时间看蚂蚁搬家，等石头开花。小时候不期待结果，小时候哭笑都不打折。”——《允许自己虚度时光》​\n7. “海王”“海后”“普信男”“低分女”“撩妹话术”“斩男技巧”……我们能用一个细分标签迅速地开展或结束一段恋情，也能用一套通用的评价体系精确衡量每段关系的价值。我们每个人都好像聪明起来了，没人犯蠢了。现代恋情包裹在精致的体面和精巧的计算之中，讲的是低成本高收益，春梦里都是一本万利。尽管这种聪明曾经被视作真挚爱情的致命毒药，是影视剧里坏人们才会耍的手段。​\n8. 不容何病，不容然后见君子\n9. 不去期望。失去了不会伤心，得到便是惊喜。​\n10. 也许你的故事并不是从快乐开始的，可这并不能决定你的一生，你想要变成什么样子，全看你自己的选择​\n11. 事实上作为男人，前两步成功，人生已算得上圆满，做到第三步堪称伟大，而随意颠倒次序的那些人，一般不值得信任。——《教父》台词​\n12. 人生是不断变化的过程，要想过好我们这一生，我们需要接受改变，自我觉察，以求知若渴，谦卑如愚的心态，保持正念，实事求是地去思考，去行事。​\n13. 你学过的每一样东西，你遭受的每一次苦难，都会在你一生中的某个时候派上用场。—— 菲茨杰拉德​\n14. 你患得患失太在意从前，又太担心将来。有句话说的好：“昨天是段历史，明天是个谜团，而今天是天赐的礼物，像珍惜礼物那样珍惜今天”​\n\n\n\n\n",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-09-30 16:40:05",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 61,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-08-08.md",
      "title": "2024-08-08",
      "abstract": "\n- 13:34 普通人不但要麻木的像条狗一样活着，还总是被逼着向我们仅有的情感里不停的添加些乱七八糟的东西。<br>#一言  ^hhihrx",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-08-08 13:35:21",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 5,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-06-04.md",
      "title": "2024-06-04",
      "abstract": "\n- 08:28 至于后来的日子，都是一场残忍无比却没有落幕的戏。<br>我把秘密看在眼里，却只能在心头唏嘘。<br>#一言\n- 08:29 独处时我将会无比快乐。拥有自由、书籍、鲜花和月亮的人怎会不快乐？<br>#一言\n- 08:29 随着人们掌握的信息资源越来越多，未来的道路是疏不是堵。<br>信息孤岛是一个人的信息孤岛，跳出去终究成了笑话，不过是从一个黑暗森林走向另一个黑暗森林。<br>社会认识水平的提高，终究带来社会形式的转变，我只不过是这洪流中一粒不起眼的沙子罢了。<br>#随想\n- 08:29 “无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。”<br><br>—— 马尔克斯​<br>#一言\n- 08:30 人的本质意义上是孤独的，因为你无法准确表达自己。即便你能准确表达，别人也不一定能够正确理解。<br>——《百年孤独》​<br>#一言\n- 08:30 你为什么读书？<br>为了金钱和美女，不对，是为了事业和爱情​<br>#一言\n- 08:30 你既不能要求所有人都懂得什么是尊重，什么是宽容；也不能要求所有人不去发散思路，只关注于事实。​<br>#一言\n- 08:31 可是在我看来，他是唯一不荒唐的人。也许这是因为他那么忙碌却不是为了他自己。​<br>#一言\n- 08:31 今天偶然间打开知乎,瞬间弹上来一堆什么什么佳句摘抄，看到底下评论的那些“受教了”，“感触很深”等等的话语，不禁觉得一阵可笑。的确，当时的我确实是挺喜欢的。但是放在现在想了想，只觉得当时的自己十分的幼稚。后来又想到自己看那种分享阅读感受的视频，觉得自己和评论底下的人无二。一昧追求信息获取的效率，长时间的接受那些划定了的结论，让我渐渐的懒于思考，思想变得极端。或许只有沉下心来去阅读，才能让我们走出信息茧房，冲出大数据框定之外的世界，才能引发我们的思考，让自己的思想变得更加的深刻。。。​<br>#随想",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-06-04 08:31:38",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 29,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-04-27.md",
      "title": "2024-04-27",
      "abstract": "\n- 11:06 老话说吃什么补什么，所以吃苦成不了人上人，吃人才行<br>#一言",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-04-27 11:06:39",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-29.md",
      "title": "2024-03-29",
      "abstract": "\n- 11:01 如果陪伴久了的话就可以谈恋爱，那不如不谈，纯纯搭伙过日子，肉欲，精神，金钱的互通与交织让俩人在一起，太俗气太卑鄙了<br>#随想",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-29 11:01:06",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-25.md",
      "title": "2024-03-25",
      "abstract": "\n- 17:04 我记得一个记录片《中华之剑》里第5集里有一个片段。毒贩用手雷炸死了两名边境缉毒警察，之后办理缉毒死者葬礼时，按照当地习俗，主持者用刀切断了死者与妻子手里拉着的红线…代表他们的阳间缘分到了。这以后，死者八十多岁的老妈妈被人搀扶着来到儿子棺材旁，无奈，生气的给了儿子一巴掌，当时眼泪就出来了！…<br>借用记录片里一个死刑犯的话：“但凡粘上毒品的人，要么蹲监，要么死在街头，都没有什么好结果。”<br>#一言",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-25 17:04:32",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-21.md",
      "title": "2024-03-21",
      "abstract": "",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-21 20:25:15",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 1,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-14.md",
      "title": "2024-03-14",
      "abstract": "\n- 15:58 自从把理想戒了，人生过的挺惬意的……<br>#一言",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-14 15:58:17",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-07.md",
      "title": "2024-03-07",
      "abstract": "\n- 19:47 你会在下雨天出门仅仅因为享受板鞋踩踏着雨水的声音，我也会在漫无目的出门坐着公交感受慢下来的风景。有些事情不需要原因，也不需要成本，请好好爱惜吧，这些弥足珍贵的东西。<br>#随想",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-07 19:47:54",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-05.md",
      "title": "2024-03-05",
      "abstract": "\n- 14:39 女孩终于明白，她追求的所谓爱情、婚姻，骨子里其实就是亟需一场陪伴。爱情、婚姻，是属于特定某个人的，陪伴就不一定。<br>#一言\n- 15:01 煎和熬可以做一顿好菜，生活也是。<br>#一言\n- 15:04 我真的好累，我应该适当休息一下的，但是事实却不允许我这样，我好羡慕他们，可以做很多自己喜欢的事情 <br>#随想",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-05 15:04:46",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 11,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-03-04.md",
      "title": "2024-03-04",
      "abstract": "\n- 16:26 你说的那些人我认识，他们已经死在斯大林格勒了”<br>#一言<br>",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-03-04 16:26:13",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 4,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-02-28.md",
      "title": "2024-02-28",
      "abstract": "\n- 13:27 没有结局的时候，过程很重要，有结局的时候，过程就显得没有结局重要了…<br>#随想 ^n8fo1i\n- 19:44 灵魂相似的两个人真的会走向婚姻吗？在现在这个社会，太多有情人并不能成眷属，大部分情况，选择了现实就要割舍爱情，选择了爱情就要为柴米油盐奔波……选择本身并没有错，但我们要做好选择的代价，爱情和面包在何为第一？每个人的回答都是不同的，这个问题本身并没有错，关键在于我们是否能用一生坚持自己的选择……<br>#随想",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-02-28 19:44:12",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 8,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2024-02-27.md",
      "title": "2024-02-27",
      "abstract": "\n- 13:50 #随想 <br>社会的新陈代谢带着我走向了死亡  ^cboa4s\n- 13:54 #随想<br>不知道从何时起，互联网从讨论逐渐变成了人们情感的宣泄口。这难道就是新闻的魅力吗？ ^0x1zrh\n\n- 13:55 #随想<br>好奇怪 我越敷衍就越有人爱我 我越用心他们就像抓住了我的把柄来和我谈条件\n- 13:55 #随想<br>初中时候，觉得世界是围着我转的，高中的时候，觉得我是围着别人转的，大学的时候我才意识到大家原来都很普通，能在三十多人里面出彩已经很了不起了，步入社会，我明白了原来我的死活不会有人在乎，自己好好活着就已经很了不起了。其实大多数的人的成长就是一个慢慢与自己和解，慢慢认识到自己平庸的一个过程，每个人或许是少年方仲永，但长大以后很多人都会泯然众人矣。\n- 13:55 #随想<br>我虽然是个废物,但我仍然选择用自己喜欢的方式度过自己的余生\n- 13:56 #随想<br>我把回忆藏进梦里，偷偷和枕头说着我的梦想。醒来继续麻木的面对着生活的一地鸡毛。\n- 13:56 #短文<br>“他已经三十二岁，还没有结婚，对于女人，他只能想到性欲。他的脸同诗文一样不招女人喜爱，所以他因为接近不了女人而恨女人。看到别人和女性一块走，他马上想到一些最脏最丑的情景，并去写几句他自以为最毒辣而其实是不通的诗和文，发泄他心中的怨气。他的诗文似乎专为骂人的，而自认为最富有正义感。”<br><br>——老舍《四世同堂》\n- 13:57 #随想<br>当我经历了一份全身心都投入的失败感情后，突然间发现，我好像失去了爱一个人的能力。或许是哀莫大于心死，我生活的一切都伴随着我的心变得枯燥乏味。我像一个机器人一样的活着，每天执行着三点一线的指令。胖了，丑了，似乎活着的意义只剩下了让自己开心 。以前我是为她而活，昂扬向上，努力刻苦。现在为自己而活，我好像好像失去了动力一样。<br><br>我不断的努力去尝试爱一个人，喜欢一个人，可是到头来却发现，我喜欢的只是她们的外表。从未触及她们的灵魂，我是卑鄙的，挺喜欢的名义坠入声色犬马的世界。<br><br>好想爱一个人，去灵魂的触碰，去心与心的相拥，想去试试那种奋不顾身的感觉，粉身碎骨也无所谓了。。。可是，我又怎么该劝自己呢？\n- 13:57 #诗词<br>得鹿梦鱼出自黄庭坚的《杂诗七首》其一<br><br>此身天地一蘧庐，世事消磨绿鬓疏。<br><br>毕竟几人真得鹿，不知终日梦为鱼。\n- 13:57 #诗词<br><br>人间无事人出自杜荀鹤的《赠质上人》：<br><br>枿坐云游出世尘，兼无瓶钵可随身。<br><br>逢人不说人间事，便是人间无事人。\n- 13:58 #随想<br>纯爱最基本是站在对方的角度上，理解对方的感受，接受对方的认知，尽力满足对方的需求。是带着一颗利他的心。\n- 14:01 #短文<br>「矿工的葬礼」<br><br><br>早就该死了<br><br>可是撑到现在，才死<br><br>腿早就被砸断了<br><br>可轮椅又让他，在尘世上<br><br>奔波了无数寒暑<br><br>老婆早嫁了，孩子在远方<br><br>已长成监狱里的愣头青<br><br>只有老母亲，一直陪着<br><br>仿佛上帝派来的天使<br><br>她越活，越年轻<br><br>在他三十岁时，洗衣服<br><br>在他四十岁时，给他喂饭<br><br>去年，还抱着哭泣的他<br><br>轻声安慰。赔偿款早就花完了<br><br>可他新添的肺病，眼疾<br><br>还得治一下<br><br>于是，她又把他<br><br>重新抚养了一遍<br><br>现在，他死了<br><br>在葬礼上<br><br>她孤独地哭着<br><br>像极了一个，嗷嗷待哺的女儿 ^mirchg\n- 20:52 #随想<br>不知道从何时起，互联网上的声音从互相的讨论慢慢的变成了人们情感的宣泄口。敏感的话题让人们互相圈地，越来越多的人披着充满荆棘的盔甲行走在互联网的世界，或许从互联网诞生的那一刻就注定了这种结局。身处互联网的人思维逐步向着二极管演化，以前大家都是讨论出结果，现在呢，多数是有一个既定的结局，留给大家去喷去吐槽。我发现我关注多数是时评博主，仔细想想，为什么不能是表达自己的观点呢？人要有一个独立思考的能力，而不是建立在别人思考的角度上去认可他人观点的正确与错误。 ^5fv86o",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-02-27 20:56:55",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 48,
        "text": "1分钟"
      }
    },
    {
      "link": "句读/2022-11-11.md",
      "title": "2022-11-11",
      "abstract": "- 作者：Del Levin\n- 日期：2022-11-28\n\n\n## 2022-11-24\n- 17:33 #诗词<br>甘居人下者鲜。御之失谋，非犯，则篡耳。上无威，下生乱。威成于礼，恃以刑，失之纵。私勿与人，谋必辟。幸非一人，专固害。机心信隐，交接靡密，庶下者知威而畏也。下附上以成志，上恃下以成名。下有所求，其心必进，迁之宜缓，速则满矣。上有所欲，其神若亲，礼下勿辞，拒者无助矣。人有所好，以好诱之无不取，人有所惧，以惧迫之无不纳。才可用者，非大害而隐忍。其不可制，果大材而亦诛。赏勿吝，以坠其志。罚适时，以警其心。恩威同施，才德相较，苟无功，得无天耶？<br>\n## 2022-11-20\n- 15:37 #随想<br>我不是不相信爱情，我只是不相信爱情会落到我身上 \n## 2022-11-11\n- 20:13 #一言<br>文字是一种被钉在了纸上的脆弱生物。它们像蝴蝶一样在房间里漫天飞舞。<br>                                                   多米尼克·福捷《我居于无限可能》\n## 2022-11-04\n- 14:51 #诗词 <br>玉楼春·尊前拟把归期说<br>【作者】欧阳修 【朝代】宋<br>尊前拟把归期说。未语春容先惨咽。<br>人生自是有情痴，此恨不关风与月。<br>离歌且莫翻新阕。一曲能教肠寸结。<br>直须看尽洛城花，始共春风容易别。 ^1tkr1a\n## 2022-10-22\n- 11:03 #一言 <br>不是所有的事情都能被时间打磨平，不是经过了岁月，我们就能和自己和解，有些东西，就像深扎进肉里的刺，永远永远，刺痛且无可奈何。就算你挖开血肉，想给自己一个摆脱它的机会，却还是会发现，它早就融在身体里，成了无药的顽疾，余生必须与其为伴，永远如鲠在喉。\n## 2022-08-24\n- 10:57 #一言 <br>可是快乐，有时候在这个世界上是有罪的\n- 10:57 #一言<br>或许,有些离别异常的沉重就是因为它的不可重复\n## 2022-08-02\n- 09:38 #一言<br>活了这么久，高不成，低不就，可笑可笑。\n## 2022-07-18\n- 19:18 #一言<br>史铁生的一句话曾激励过我很久：<br><br>“苦难既然把我推到了悬崖的边缘，那么就让我在悬崖的边缘坐下来，顺便看看这悬崖下的流岚雾霭，唱支歌给你听。”<br><br>生活总是伴随着艰辛，但荒漠中开出的花，往往最鲜艳。<br><br>人生总是伴随着伤痛，但结成伤疤的地方，往往最坚硬。\n## 2022-06-25\n- 22:24 #一言 <br>不要把英雄看轻了，任何坚定自己信念的人都是傲慢的。没什么本该黑化不黑化的，只是这点挫折不配扭曲他自己的本心。 ^3zit7p\n- 22:38 #一言 <br>我们对年龄的恐惧，其实并不在于年龄增长所带来的苍老，恐惧的是随着年龄的增长，我们仍然一无所得.\n- 22:39 #一言<br>“只有强者或者势均力敌，才有资格谈和解，弱者那叫投降”\n- 22:39 #一言<br>你最初喜欢他的时候,也是你最不了解他的时候\n\n- 23:25 #一言<br>当我们已经承受过忍耐的身心疼痛，重新联系或继续断联也只是与这个人的缘分深浅。只有学会不再把所有情感都投放到某个人身上，才对得起这段旅程中受尽回忆折磨的自己。<br>友情或爱情，没有血缘的关系，都有可能是阶段性的存在。当你能始终以自我成长为生活轴心，便会接受生命中过客的来来往往，不会一步步深陷某段情感的相依与陪伴。\n\n## 2022-06-26\n- 19:17 #一言<br>“批评他人可以让我们轻易地掩盖自己，从容地逃避自己的道德责任。”<br>                                                                                ——罗翔\n- 19:21 #一言<br>“无论走到哪里，都应该记住，过去都是假的，回忆是一条没有尽头的路，一切以往的春天都不复存在，就连那最坚韧而又狂乱的爱情归根结底也不过是一种转瞬即逝的现实。”<br><br>                                                                                   —— 马尔克斯\n- 21:13 #一言<br>越穷的人越需要克制自己的消费欲望，因为他们的人生，他们的命运本来就缺乏变数，而攒下来的钱是他们为自己改变命运势能的一个积累 ^yk4au8\n- 21:13 #一言<br>事实上不如别人还是不如别人，考砸了还是考砸了，下岗了还是下岗了……这段视频无非就是换张面孔换个台词，依旧灌输自欺欺人的阿Q心里罢了\n## 2022-06-28\n- 13:53 #短文<br>我们有时候把自己认知错了，很多当我们想放弃的时候，那只是种错觉。 你不是想放弃，你是只是想休息，而你总是想用放弃代替休息，动不动就放弃，是很吓人的。 所以你每次想放弃的时候就和自己说，我可能感觉错了，我只是想休息一下，休息一天到两天继续前进。<br><br>你可以发个朋友圈抱怨说自己难，但一定会记得删除。你把难处记在你的小日记中，毕竟说出来总比一昧的闷在自己的心里要好手很多。<br><br>也许生活很给我们很多的压力，可以上火，但一定要记得按时吃药。我总以为我的身边没有人会关心会体贴我。但当我真正随手发了一个抱怨的朋友圈的时候，还没到五分钟，就删除了，我的父母，老师，同学，都来问我是什么情况，虽然不能说出口，但心里难免会很感动。<br><br>你看吧，你所认为的孤独，只是你自己的孤独。当你想放弃的时候想想吧，想想总有人在背后给您加油，期待着你的凯旋而归。千万不要放弃，放弃了一切都没有了。 休息吧，可以低迷，但不要沉沦。释放吧，可以大声喊叫，但不要把自己困住。<br><br>生活总是需要向前看的，不要低着头走路哇！\n- 14:37 #一言<br>他突然开始有点喜欢这个看似严苛无趣、却偶尔能给人惊喜的世界了，因为面前这个他特别喜欢的人。这大概是他有生以来最大程度的爱屋及乌。<br>                                                                                 ——《黑天》\n- 15:24 #一言<br>“我渐渐的好像明白了，为什么一直放不下你，不是因为你有多好，而是在几年前我们情窦初开的时候，你刚刚好进入了我的世界，也刚刚好给了我最初那种不是爱却也夹在喜欢中间的感觉，那种感觉，我找了很多很多年”       \n- 20:06 #一言<br>物质和精神毕竟是不能分开的，现有物质，再谈精神，如果一味追求精神文明，也是舍本逐末了，文明本身就是向更好的生存而发展的，所以我觉得物质点也不算错，精神更多的是物质到极限后再去追求的吧\n- 20:29 #一言 <br>当一个人痛苦的时候才会变得才华横溢，当我的生活步入正轨时，我开始跟你一样，像你忘记我那样忘记你，然后忘掉那些痛苦，开始变得平庸可耻。我不愿这样，也不愿意这样，我无法触及你，你就像盖茨比的梦，璀璨无比，却又触不可及。前方的路上诱惑太多，我没有盖茨比那么了不起，我可能走上其他的路，无法一直追逐你的脚步。\n## 2022-06-29\n- 00:51 #一言 <br>不去期望。失去了不会伤心，得到了便是惊喜。\n- 22:45 #一言<br>当你知道世界上受苦的不是只有你，你会减少痛苦，也会在绝望中燃起希望。<br>                                                                                 —— 罗曼.罗兰\n## 2022-07-01\n16:36 #一言<br>底线是一条界限，你不靠近它，你感受不到它的存在。你感受不到它的存在，不等于它不存在。\n## 2022-07-02\n- 15:48 #一言<br>文化就是根植于内心的修养，无需提醒的自觉，以约束为前提的自由，为别人着想的善良。”\n## 2022-07-05\n- 08:54 #一言<br>你遇见的人,都是来渡你的 <br>\n- 09:08 #一言<br>“生活中的一切重大事情都是这样。一个人获得这类认识，从不是通过别人的经验，而始终只能从自己的命运中获得。”<br><br>—— 茨威格\n## 2022-07-07\n- 08:47 #一言<br>巅峰产生虚伪的拥护，黄昏见证虔诚的信徒。<br>\n- 08:47 #一言<br>圣诞老人是不是更喜欢有钱的孩子\n## 2022-07-10\n- 14:17 #一言<br>追求高级、美、真实、时间亦或是其他美好的事物，是人的本性，对美不同的定义，让人们得以划分自己的属性，在“滤镜”的加持下，组成五彩斑斓的社会。 ^vz94q7\n- 15:35 #一言<br>人生后半场总是塞满无奈：<br><br>工作显得枯燥，社交变得单调；<br><br>账单成为日常，医院去得频繁；<br><br>理想遥远可笑， 家庭鸡飞狗跳。<br><br>而站在中年路口的男人，总习惯包裹自己、怯于袒露感情。<br>\n## 2022-07-12\n09:04 #一言<br>“真有才能的人总是善良的，坦白的，爽直的，决不矜持；他们的讥讽只是一种精神游戏，并不针对别人的自尊心。”                     <br>—— 巴尔扎克\n## 2022-07-15\n\n人生有三大诱惑：少年时贪玩，荒废了学业没打下扎实的基础；青年时贪情，在朋友和情人面前迷失了自我；中年时贪功，躺在功劳簿上骄傲自满地犯懒。——《德川家康》 ​​​​\n ## 2022-07-17\n- 15:07 #一言<br>刑场上的悔过比犯罪现场的认罪更真诚，生命重点的感悟比道德书本的理论更接近真相。<br>我们爱的不是一个具体的人，我们爱的是抽象的自己。\n- 18:09 #一言<br>烤面包的烘培师吃不到半点面包渣，做鞋补鞋的鞋匠露着脚趾头，织布缝衣的裁缝衣不蔽体，盖起高楼大厦、城堡宫殿的泥瓦匠的茅屋为秋风所破……什么都生产的人什么都没有，什么都不生产的人什么都有。<br>    －《我为什么是一名盗贼》马里乌斯.雅各布\n- 18:10 #随想<br>我除了健康,别的,真没有什么可以换的了...... ^79bdoj\n## 2022-07-25\n   这个世间，没钱有没钱人苦恼、有钱人有有钱人的癫狂。\n",
      "dateFormat": "2024-11-12 10:34:42",
      "changeTime": "2024-02-27 14:00:51",
      "tags": [
        {
          "name": "句读",
          "link": "#"
        }
      ],
      "stats": {
        "words": 189,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/java/mybatisPlus的代码生成器GUI.md",
      "title": "mybatisPlus的代码生成器GUI",
      "abstract": "---\ntitle: 'mybatisPlus的代码生成器GUI'\ntags: [数组,技术，工具]\npublished: true\n---\n\n\n\n## mybatisPlus的代码生成器GUI\n\n今天写了个mybatisPlus代码生成器的GUI\n\n主要办法就是通过填入地址，端口号，数据库名，用户名，密码这些数据来扫描 输入数据库 内的所有表，并弹出窗口展示，选择对应表名之后，点击生成代码，就可以生成对应的代码。\n\n### 界面展示\n\n填入地址\n\n![7c6930267cd73112c897be795f787ab](./assets/mybatisPlus的代码生成器GUI/7c6930267cd73112c897be795f787ab.png)\n\n\n表名查看\n\n![47e2632a5c8a9cb45d1cf8c0c586539](./assets/mybatisPlus的代码生成器GUI/47e2632a5c8a9cb45d1cf8c0c586539.png)\n\n选择表名\n\n![db17f688320e25ee6cecde7e295b345](./assets/mybatisPlus的代码生成器GUI/db17f688320e25ee6cecde7e295b345.png)\n\n\n\n弹出窗口\n\n![f776b4dab452c7d6fb7f53d2cd200f4](./assets/mybatisPlus%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8GUI/f776b4dab452c7d6fb7f53d2cd200f4.png)\n\n生成代码\n\n![8f92a50e0151a59f850a78f29000c29](./assets/mybatisPlus%E7%9A%84%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8GUI/8f92a50e0151a59f850a78f29000c29.png)\n\n\n\n### **runGUI**  swing界面\n\n```java\npackage com.wonder.run;\n\n\nimport java.awt.*;\nimport java.awt.event.*;\nimport java.util.ArrayList;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class runGui extends JFrame implements ActionListener\n{\n\n    JLabel labelData  = new JLabel(\"\", JLabel.CENTER);\n    JTextField textFieldData;\n    JLabel labelUrl  = new JLabel(\"\", JLabel.CENTER);\n    JTextField textFieldUrl;\n    JLabel labelPort  = new JLabel(\"\", JLabel.CENTER);\n    JTextField JTextFieldPort;\n    JLabel labelUserName  = new JLabel(\"\", JLabel.CENTER);\n    JTextField JTextFieldPortUsername;\n    JLabel labelPassword  = new JLabel(\"\", JLabel.CENTER);\n    JTextField JTextFieldPortPassword;\n    JButton submitButton = new JButton(\"Submit\");\n\n    public runGui()\n    {\n        JPanel myPanel = new JPanel();\n        add(myPanel);\n        textFieldUrl  =new JTextField(10);\n        JTextFieldPort=new JTextField(10);\n        textFieldData = new JTextField(10);\n        JTextFieldPortUsername = new JTextField(10);\n        JTextFieldPortPassword = new JTextField(10);\n\n        labelUrl.setText(\"数据库地址\");\n        myPanel.add(labelUrl);\n        textFieldUrl.setText(\"127.0.0.1\");\n        myPanel.add(textFieldUrl);\n\n        labelPort.setText(\"数据端口\");\n        myPanel.add(labelPort);\n        JTextFieldPort.setText(\"3306\");\n        myPanel.add(JTextFieldPort);\n\n        labelData.setText(\"数据库名\");\n        myPanel.add(labelData);\n        textFieldData.setText(\"test_sql\");\n        myPanel.add(textFieldData);\n\n        labelUserName.setText(\"用户名\");\n        myPanel.add(labelUserName);\n        JTextFieldPortUsername.setText(\"root\");\n        myPanel.add(JTextFieldPortUsername);\n\n        labelPassword.setText(\"密码\");\n        myPanel.add(labelPassword);\n        JTextFieldPortPassword.setText(\"123456\");\n        myPanel.add(JTextFieldPortPassword);\n\n        myPanel.add(submitButton);\n        submitButton.addActionListener(this);\n\n\n    }\n\n    public void actionPerformed(ActionEvent actionEvent)\n    {\n        JDialog frame = new JDialog();//构造一个新的JFrame，作为新窗口。\n        frame.setBounds(// 让新窗口与SwingTest窗口示例错开50像素。\n                new Rectangle(\n                        (int) this.getBounds().getX() + 50,\n                        (int) this.getBounds().getY() + 50,\n                        (int) this.getBounds().getWidth(),\n                        (int) this.getBounds().getHeight()\n                )\n        );\n\n        if (actionEvent.getSource() == submitButton) {\n            String url = textFieldUrl.getText();\n            String port = JTextFieldPort.getText();\n            String data = textFieldData.getText();\n            String username = JTextFieldPortUsername.getText();\n            String password = JTextFieldPortPassword.getText();\n            DatebaseTable datebaseTable = new DatebaseTable();\n            try {\n                List<String> resList = datebaseTable.tableName(data,url,port,username,password);\n                //System.out.println(resList.size());\n                if(resList.size() ==0){\n                    System.out.println(\"没有这个数据库\");\n                    JOptionPane.showMessageDialog(null,\"没有这个数据库！\",\"没有这个数据库！\",JOptionPane.WARNING_MESSAGE);\t//消息对话框\n                }else {\n                    frame.setLayout(new BorderLayout());\n                    frame.setLayout(new GridLayout(4,4,5,5));\n                    JCheckBox[] boxs = new JCheckBox[resList.size()];// 创建控件数组\n                      for (int i = 0; i < resList.size(); i++) {\n                          //System.out.println(resList.get(i));\n                          boxs[i] = new JCheckBox (resList.get(i));// 初始化数组中的复选框组件\n                          frame.add(boxs[i]);\n                      }\n                    JButton submitButtonCode = new JButton(\"生成代码\");\n                    frame.add(submitButtonCode);\n                    submitButtonCode.addActionListener(new ActionListener(){// 增加监听动作\n                        public void actionPerformed(ActionEvent e){// 满足 动作 事件 的选择后触发以下事件\n                            //System.out.println(e.getSource());\n                            List<String> addList=new ArrayList<String>();\n                            for (int i = 0; i <boxs.length ; i++) {\n                                //System.out.println(boxs[i].getText() + \" 是否选中: \" + boxs[i].isSelected());\n                                if(boxs[i].isSelected()){\n                                    //System.out.println(boxs[i].getText());\n                                    addList.add(boxs[i].getText());\n                                }\n                            }\n                            System.out.println(addList);\n                            if (addList.size()==0) {\n                                System.out.println(\"没有这个数据库\");\n                                JOptionPane.showMessageDialog(null,\"哥，你还没有选表。。。\",\"你还没有选表！\",JOptionPane.WARNING_MESSAGE);\t//消息对话框\n                            }else {\n                                CodeGenerator.makeCoder(url+\":\"+port+\"/\"+data,username,password,addList);\n                                JOptionPane.showMessageDialog(frame,\"代码已经生成，关闭gui窗口查看\");\n                                frame.setVisible(false);\n                            }\n\n                        }\n                    });\n                    frame.setModalityType(Dialog.ModalityType.APPLICATION_MODAL);    // 设置模式类型。\n                    frame.setVisible(true);\n                }\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n\n        }\n    }\n\n\n    public static void main(String args[])\n    {\n        runGui g = new runGui();\n        g.setLocation(200, 250);\n        g.setSize(181, 200);\n        g.setVisible(true);\n    }\n}\n```\n\n### **DatebaseTable**  扫描某数据库的表类\n\n```java\npackage com.wonder.run;\n\nimport java.sql.*;\nimport java.util.*;\n\n\npublic class DatebaseTable {\n    public List<String> tableName(String datasourceName,String url,String port,String username ,String password) throws Exception {\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://\"+url+\":\"+port+\"\", username, password);\n        DatabaseMetaData metadata = conn.getMetaData();\n        //System.out.println(\"获取指定的数据库的所有表的类型\");\n        ResultSet rs1 = metadata.getTables(datasourceName, null, null, null);\n        List<String> listTables = new ArrayList<>();\n        //int count = 1;\n        while (rs1.next()) {\n            System.out.println();\n            listTables.add(rs1.getString(3));\n            //count++;\n        }\n//        System.out.println(count);\n//        for(String value: setTables){\n//            System.out.println(value);\n//        }\n        return  listTables;\n    }\n    public static void main(String[] args) throws ClassNotFoundException, SQLException {\n        Class.forName(\"com.mysql.cj.jdbc.Driver\");\n        Connection conn = DriverManager.getConnection(\"jdbc:mysql://localhost:3306\", \"root\", \"123456\");\n        DatabaseMetaData metadata = conn.getMetaData();\n        /**\n         * 获取指定的数据库的所有表的类型,getTables()的第一个参数就是数据库名\n         * 因为与MySQL连接时没有指定,这里加上,剩下的参数就可以为null了\n         * 第二个参数是模式名称的模式,但是输出也是什么都没有。谁知道告诉我一声\n         */\n        //System.out.println(\"获取指定的数据库的所有表的类型\");\n        ResultSet rs1 = metadata.getTables(\"test_sql\", null, null, null);\n        //Map<String, String> map = new HashMap<String, String>();\n        Set<String> setTables = new HashSet<String>();\n        int count = 0;\n        while (rs1.next()) {\n            System.out.println();\n            //map.put(rs1.getString(1)+\"/\"+count , rs1.getString(3));\n            //System.out.println(\"数据库名:\" + rs1.getString(1));\n            //System.out.println(\"表名: \" + rs1.getString(3));\n            setTables.add(rs1.getString(3));\n            count++;\n        }\n        System.out.println(count);\n        for(String value: setTables){\n            System.out.println(value);\n        }\n//        map.forEach((key, value) -> {\n//            System.out.println(key + \":\" + value);\n//        });\n        rs1.close();\n        //showTables(conn);\n    }\n\n    private static void showTables(Connection conn) throws SQLException {\n        ResultSet rs;// 获取数据库表\n        System.out.println(\">>>>>>>>>>>>>>>>>>>数据库表\");\n        DatabaseMetaData meta = conn.getMetaData();\n        rs = meta.getTables(null, null, null,\n                new String[]{\"TABLE\"});\n        int count = rs.getMetaData().getColumnCount();\n        ResultSetMetaData rsmd = rs.getMetaData();\n        for (int i = 1; i <= count; i++) {\n            System.out.print(String.format(\"%1$20s\", rsmd.getColumnName(i)));\n        }\n        System.out.println();\n        int j = 20 * count;\n        while (j > 0) {\n            System.out.print(\"-\");\n            j--;\n        }\n        System.out.println();\n        while (rs.next()) {\n            for (int i = 1; i <= count; i++) {\n                System.out.print(String.format(\"%20s\", rs.getString(i)));\n            }\n            System.out.println();\n        }\n    }\n}\n```\n\n\n\n### **CodeGenerator** 代码生成器类\n\n```java\npackage com.wonder.run;\n\n\nimport com.baomidou.mybatisplus.annotation.FieldFill;\nimport com.baomidou.mybatisplus.annotation.IdType;\nimport com.baomidou.mybatisplus.core.mapper.BaseMapper;\nimport com.baomidou.mybatisplus.generator.FastAutoGenerator;\nimport com.baomidou.mybatisplus.generator.config.OutputFile;\nimport com.baomidou.mybatisplus.generator.config.rules.DateType;\nimport com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;\nimport com.baomidou.mybatisplus.generator.engine.FreemarkerTemplateEngine;\nimport com.baomidou.mybatisplus.generator.engine.VelocityTemplateEngine;\nimport com.baomidou.mybatisplus.generator.fill.Column;\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class CodeGenerator {\n    public static void makeCoder(String op, String name, String password, List<String> listTable) {\n    //public static void main(String[] args) {\n\n        //数据库地址，数据库用户 ，数据库密码\n        //String op = \"localhost:3306/test_sql\";\n        //String name=\"root\";\n        //String password=\"123456\";\n        //添加需要生成的数据表\n        //List<String> listTable = Arrays.asList(\"test_table\",\"tt2\",\"test_b\");  //设置需要自动代码生成的表名\n\n        //基本信息\n        String author = \"DelLevin\";    //作者\n        String parent = \"com\";   //父包名\n        String module = \"wonder\";   //模块包名\n\n\n        String url=\"jdbc:mysql://\"+ op +\"?serverTimezone=UTC&useUnicode=true&characterEncoding=utf-8\";\n        //List<String> listTableSuffix = Arrays.asList(\"_b\");    //设置 过滤 表的后缀\n        //List<String> listTablePrefix = Arrays.asList(\"t_\",\"c_\"); //设置 过滤 表的前缀\n        //已封装好，无需更改。可按照需求进行注释\n        //1、配置数据源\n        FastAutoGenerator.create(url, name, password)\n                //2、全局配置\n                .globalConfig(builder -> {\n                    builder.author(author) // 设置作者名\n                            .outputDir(System.getProperty(\"user.dir\") + \"/src/main/java\")   //设置输出路径：项目的 java 目录下【System.getProperty(\"user.dir\")意思是获取到项目所在的绝对路径】\n                            .commentDate(\"yyyy-MM-dd hh:mm:ss\")   //注释日期\n                            .dateType(DateType.ONLY_DATE)   //定义生成的实体类中日期的类型 TIME_PACK=LocalDateTime;ONLY_DATE=Date;\n                            .fileOverride()   //覆盖之前的文件\n                            .enableSwagger()   //开启 swagger 模式\n                            .disableOpenDir();   //禁止打开输出目录，默认打开\n                })\n                //3、包配置\n                .packageConfig(builder -> {\n                    builder.parent(parent) // 设置父包名\n                            .moduleName(module)   //设置模块包名\n                            .entity(\"entity\")   //pojo 实体类包名\n                            .service(\"service\") //Service 包名\n                            .serviceImpl(\"service.impl\") // ***ServiceImpl 包名\n                            .mapper(\"mapper\")   //Mapper 包名\n                            .xml(\"mapper.xml\")  //Mapper XML 包名\n                            .controller(\"controller\") //Controller 包名\n                            .other(\"config\")    //自定义包名(一般不在这里生成，而是后面编写的时候自己建包）\n                            .pathInfo(Collections.singletonMap(OutputFile.mapper.xml, System.getProperty(\"user.dir\")+\"/src/main/resources/mapper\"));    //配置 mapper.xml 路径信息：项目的 resources 目录下\n                })\n                //4、策略配置\n                .strategyConfig(builder -> {\n                    builder\n                            .enableCapitalMode()    //开启大写命名\n                            .enableSkipView()   //创建实体类的时候跳过视图\n                            .addInclude(listTable) // 设置需要生成的数据表名\n                            //.addTableSuffix(listTableSuffix) //设置 过滤 表的后缀\n                            //.addTablePrefix(listTablePrefix) // 设置 过滤 表的前缀\n\n                            //4.1、实体类策略配置\n                            .entityBuilder()\n                            .enableChainModel() //开启链式模型\n                            //.disableSerialVersionUID()  //默认是开启实体类序列化，可以手动disable使它不序列化。由于项目中需要使用序列化就按照默认开启了\n                            .enableTableFieldAnnotation()       // 开启生成实体时生成字段注解\n                            .enableLombok() //开启 Lombok\n                            .versionColumnName(\"version\")   //乐观锁字段名(数据库)\n                            .versionPropertyName(\"version\") //乐观锁属性名(实体)\n                            .logicDeleteColumnName(\"deleted\")   //逻辑删除字段名(数据库)\n                            .logicDeletePropertyName(\"deleteFlag\")  //逻辑删除属性名(实体)\n                            .naming(NamingStrategy.underline_to_camel)  //数据库表映射到实体的命名策略：默认是下划线转驼峰命。这里可以不设置\n                            .columnNaming(NamingStrategy.underline_to_camel)    //数据库表字段映射到实体的命名策略：下划线转驼峰命。（默认是和naming一致，所以也可以不设置）\n                            .addTableFills(\n                                    new Column(\"create_time\", FieldFill.INSERT),\n                                    new Column(\"modify_time\", FieldFill.INSERT_UPDATE)\n                            )   //添加表字段填充，\"create_time\"字段自动填充为插入时间，\"modify_time\"字段自动填充为插入修改时间\n                            .idType(IdType.AUTO)    //设置主键自增\n\n                            //4.2、Controller策略配置\n                            .controllerBuilder()\n                            .enableHyphenStyle()    //开启驼峰连转字符\n                            .formatFileName(\"%sController\") //格式化 Controller 类文件名称，%s进行匹配表名，如 UserController\n                            .enableRestStyle()  //开启生成 @RestController 控制器\n\n                            //4.3、service 策略配置\n                            .serviceBuilder()\n                            .formatServiceFileName(\"%sService\") //格式化 service 接口文件名称，%s进行匹配表名，如 UserService\n                            .formatServiceImplFileName(\"%sServiceImpl\") //格式化 service 实现类文件名称，%s进行匹配表名，如 UserServiceImpl\n\n                            //4.4、Mapper策略配置\n                            .mapperBuilder()\n                            .superClass(BaseMapper.class)   //设置父类\n                            .enableBaseResultMap()  //启用 BaseResultMap 生成\n                            .enableBaseColumnList() //启用 BaseColumnList\n                            .formatMapperFileName(\"%sMapper\")   //格式化 mapper 文件名称\n                            .enableMapperAnnotation()       //开启 @Mapper 注解\n                            .formatXmlFileName(\"%sXml\") //格式化Xml文件名称\n                            .formatMapperFileName(\"%sMapper\");   //格式化Mapper文件名称\n\n                })\n                //5、模板\n                .templateEngine(new VelocityTemplateEngine())\n                /*\n                    模板引擎配置，默认 Velocity 可选模板引擎 Beetl 或 Freemarker(以下两个引擎用哪个就保留哪个)\n                   .templateEngine(new BeetlTemplateEngine())\n                   .templateEngine(new FreemarkerTemplateEngine())\n                 */\n                .templateEngine(new FreemarkerTemplateEngine())\t//本人选择了Freemarker\n                //6、执行\n                .execute();\n    }\n\n}\n```\n\n\n\n### 依赖\n\n```java\n   <dependencies>\n        <!--spring-boot-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n        <!--SpringBootTest-->\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n        </dependency>\n        <!--swagger-->\n        <dependency>\n            <groupId>io.swagger</groupId>\n            <artifactId>swagger-annotations</artifactId>\n            <version>1.6.3</version>\n        </dependency>\n        <!--lombok-->\n        <dependency>\n            <groupId>org.projectlombok</groupId>\n            <artifactId>lombok</artifactId>\n        </dependency>\n        <!--mysql 驱动-->\n        <dependency>\n            <groupId>mysql</groupId>\n            <artifactId>mysql-connector-java</artifactId>\n            <version>8.0.26</version>\n        </dependency>\n        <!--mybatis-plus-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-boot-starter</artifactId>\n            <version>3.5.2</version>\n        </dependency>\n        <!--mybatis-plus-generator 生成器-->\n        <dependency>\n            <groupId>com.baomidou</groupId>\n            <artifactId>mybatis-plus-generator</artifactId>\n            <version>3.5.2</version>\n        </dependency>\n        <!--velocity-->\n        <dependency>\n            <groupId>org.apache.velocity</groupId>\n            <artifactId>velocity-engine-core</artifactId>\n            <version>2.3</version>\n        </dependency>\n        <!--以下两个引擎模板保留一个即可，看个人爱好选择-->\n        <!--freemarker引擎模板-->\n        <dependency>\n            <groupId>org.freemarker</groupId>\n            <artifactId>freemarker</artifactId>\n            <version>2.3.31</version>\n        </dependency>\n    </dependencies>\n```\n\n",
      "dateFormat": "2024-11-11 22:43:16",
      "changeTime": "2024-11-11 23:09:16",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "java",
          "link": "#"
        }
      ],
      "stats": {
        "words": 951,
        "text": "5分钟"
      }
    },
    {
      "link": "技术笔记/java/cb() never called!的解决办法.md",
      "title": "cb() never called!的解决办法",
      "abstract": "---\r\ntitle: 'cb() never called!的解决办法'\r\ntags: [java,技术笔记,呆头呆脑]\r\npublished: true\r\n---\r\n\r\n##  cb() never called!的解决办法\r\n\r\n```bash\r\nnpm ERR! cb() never called!\r\n\r\nnpm ERR! This is an error with npm itself. Please report this error at:\r\n\r\nnpm ERR!     <https://npm.community>\r\n\r\nnpm ERR! A complete log of this run can be found in:\r\n\r\nnpm ERR!     /Users/geekchief/.npm/_logs/2021-07-12T06_56_29_399Z-debug.log\r\n```\r\n\r\ngithub的issue的讨论：https://github.com/npm/cli/issues/417\r\n\r\n错误的意思是，npm程序执行到未知流程节点中然后没有调用回调通知任务已执行完成，导致进程异常退出，据官方说法他们也没有太好的方式解决，不过网上的东西大多数不靠谱，但是有挺多人用的淘宝源，出这个错误的概率会大大提高。\r\n\r\n\r\n\r\n先尝试清楚npm缓存再安装试试\r\n\r\n`npm cache clean -force`\r\n\r\n然后\r\n\r\n`npm install`\r\n\r\n不过这个办法多数时候不管用\r\n\r\n造成这个办法的情况是使用的淘宝的源，建议换回官方的源，然后再次安装\r\n\r\n**查看是什么源**\r\n\r\n```bash\r\nnpm config get registry\r\n```\r\n\r\n![image-20230424230230225](./assets/cbnevercalled的解决办法/image-20230424230230225.png)\r\n\r\n淘宝的源，好的，果断替换\r\n\r\n**换回官方源**\r\n\r\n```bash\r\nnpm config set registry https://registry.npmjs.org/\r\n```\r\n\r\n再次查看\r\n\r\n![image-20230424230350141](./assets/cbnevercalled的解决办法/image-20230424230350141.png)\r\n\r\n替换成功了，多数时候下载会失败或者很慢，这就需要我们科学上网了，设置npm代理的端口。\r\n\r\n```bash\r\nnpm config set proxy=http://127.0.0.1:10809\r\n```\r\n\r\n然后如果想查看npm配置的话可以使用这个命令查看`npm config list`\r\n\r\n![image-20230424230648198](./assets/cbnevercalled的解决办法/image-20230424230648198.png)\r\n\r\n再次`npm install`安装就会成功了\r\n\r\n\r\n\r\n",
      "dateFormat": "2024-11-11 22:43:16",
      "changeTime": "2024-11-11 22:49:43",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "java",
          "link": "#"
        }
      ],
      "stats": {
        "words": 98,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/java/java数组动态初始化和静态初始化.md",
      "title": "java数组动态初始化和静态初始化",
      "abstract": "---\r\ntitle: 'java数组动态初始化和静态初始化'\r\ntags: [数组,技术]\r\npublished: true\r\n---\r\n\r\n简述：\r\n\r\n1.[数组](https://so.csdn.net/so/search?q=数组&spm=1001.2101.3001.7020)是指有序的元素序列。如果将有限个类型相同的变量的集合命名，那么这个名称就是数组名，而组成数组的各个变量称为数组的分量，也称为数组的元素，有时也称为下标变量。\r\n\r\n \\* 数组是一个引用类型\r\n\r\n \\* 数组当中的多个数据类型必须统一\r\n\r\n \\* 数组长度在程序运行中不可改变\r\n\r\n2.数组的初始化：在内存当中创建一个数组，并且向其中赋值一些默认值\r\n\r\n3.解析含义：\r\n\r\n  左侧数据类型：也就是数组当做保存的数据：全是统一类型\r\n\r\n  左侧的中括号：代表我是一个数组 \r\n\r\n  左侧数组名称：给数组取一个名字\r\n\r\n  右侧的new：代表创建数组的动作 \r\n\r\n  右侧的数据类型：必须和左侧的数据类型保持一致 \r\n\r\n  右侧中括号的长度，也就是数组当中，到底可以保存多少个数据，是一个int数字\r\n\r\n4.两种常见的初始化方式：\r\n\r\n  1.动态初始化（指定长度）\r\n\r\n  2.静态初始化（指定内容）\r\n\r\n \\* 动态初始化:指定长度：在创建数组时候 直接指定数组当中的数据元素个数  \r\n\r\n \\* 静态初始化:指定长度：在创建数组的时候，不直接指定数据个数多少，而是直接将具体数据内容进行指定\r\n\r\n5.动态初始化数组的格式：\r\n\r\n  数据类型[] 数组名称 =new 数据类型【数组长度】;\r\n\r\n例：![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16.png)\r\n\r\n 6.使用动态数组初始化数组时候，其中的元素将会自动拥有一个默认值：\r\n\r\n  \\* 如果是整数类型：那么默认为0；\r\n\r\n  \\* 如果是浮点数类型：那么默认为0.0;\r\n\r\n  \\* 如果是布尔类型：那么默认为false；\r\n\r\n  \\* 如果是引用类型：那么默认为null；\r\n\r\n例:![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16-1668424742205-1.png)\r\n\r\n 给动态初始化数组赋值：![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16-1668424742205-2.png)\r\n\r\n7.静态初始化数组的格式：\r\n\r\n  静态类型[ ] 数组名称=new 数据类型 [ ] {元素1，元素2.。。。};\r\n\r\n例：\r\n\r\n![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16-1668424742206-3.png)\r\n\r\n8.使用静态初始化数组时候:标准格式和省略格式：\r\n\r\n 标准格式：  \r\n\r\n   数据类型[ ] 数组名称=new 数据类型[ ] {元素1，元素2.。。};  \r\n\r\n 省略格式： \r\n\r\n  数据类型[ ] 数组名称={元素1.元素2，元素3.。。};\r\n\r\n![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16-1668424742206-4.png)\r\n\r\n注意事项：    \r\n\r\n 1.静态初始没有指定长度 但是会自动计算长度    \r\n\r\n 2.静态初始化标准格式可以拆分为2个格式 \r\n\r\n例：\r\n\r\n![img](assets/java数组动态初始化和静态初始化/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBA5aic5aicTA==,size_20,color_FFFFFF,t_70,g_se,x_16-1668424742206-5.png)",
      "dateFormat": "2024-11-11 22:43:16",
      "changeTime": "2024-11-11 22:49:40",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "java",
          "link": "#"
        }
      ],
      "stats": {
        "words": 78,
        "text": "1分钟"
      }
    },
    {
      "link": "技术笔记/java/Java 异步编程 (5 种异步实现方式详解).md",
      "title": "Java 异步编程 (5 种异步实现方式详解)",
      "abstract": "---\ntitle: 'Java 异步编程 (5 种异步实现方式详解)'\ntags: [java,技术笔记]\npublished: true\n---\n\n\n\n同步操作如果遇到一个耗时的方法，需要阻塞等待，那么我们有没有办法解决呢？让它异步执行，下面我会详解异步及实现[@mikechen](https://mikechen.cc/)\n\n目录\n\n- [什么是异步？](https://mikechen.cc/16123.html#什么是异步？)\n- [一、线程异步](https://mikechen.cc/16123.html#一、线程异步)\n- [二、Future异步](https://mikechen.cc/16123.html#二、Future异步)\n- [三、CompletableFuture异步](https://mikechen.cc/16123.html#三、CompletableFuture异步)\n- [四、SpringBoot @Async异步](https://mikechen.cc/16123.html#四、SpringBoot_@Async异步)\n- [五、Guava异步](https://mikechen.cc/16123.html#五、Guava异步)\n- [Java异步编程小结](https://mikechen.cc/16123.html#Java异步编程小结)\n\n## 什么是异步？\n\n首先我们先来看看一个同步的用户注册例子，流程如下：\n\n![img](./assets/Java%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%20(5%20%E7%A7%8D%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3)/java-asynchrony-02.png)\n\n在同步操作中，我们执行到**插入数据库**的时候，我们必须等待这个方法彻底执行完才能执行“**发送短信**”这个操作，如果**插入数据库**这个动作执行时间较长，发送短信需要等待，这就是典型的同步场景。\n\n于是聪明的人们开始思考，如果两者关联性不强，能不能将一些非核心业务从主流程中剥离出来，于是有了异步编程雏形，改进后的流程如下：\n![img](./assets/Java%20%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B%20(5%20%E7%A7%8D%E5%BC%82%E6%AD%A5%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E8%AF%A6%E8%A7%A3)/java-asynchrony-03.png)\n这就是异步编程，它是程序并发运行的一种手段，它允许多个事件同时发生，当程序调用需要长时间运行的方法时，它不会阻塞当前的执行流程，程序可以继续运行。\n\n在聊完异步编程后，那么我们一起来看看Java里面实现异步编程究竟有哪些方式呢？\n\n \n\n## 一、线程异步\n\n在 Java 语言中最简单使用异步编程的方式就是创建一个 线程来实现，如果你使用的 JDK 版本是 8 以上的话，可以使用 Lambda 表达式 会更加简洁。\n\n\n\n```java\npublic class AsyncThread extends Thread{\n    @Override\n    public void run() {\n        System.out.println(\"当前线程名称:\" + this.getName() + \", 执行线程名称:\" + Thread.currentThread().getName() + \"-hello\");\n    }\n}\n```\n\n\n\n```java\npublic static void main(String[] args) {\n\n    // 模拟业务流程\n    // .......\n\n    // 创建异步线程 \n    AsyncThread asyncThread = new AsyncThread();\n\n    // 启动异步线程\n    asyncThread.start();\n}\n```\n\n\n\n当然如果每次都创建一个 Thread线程，频繁的创建、销毁，浪费系统资源，我们可以采用线程池：\n\n\n\n```java\nprivate ExecutorService executor = Executors.newCachedThreadPool() ;\npublic void fun() throws Exception {\n    executor.submit(new Runnable(){\n        @override\n        public void run() {\n            try {\n                //要执行的业务代码，我们这里没有写方法，可以让线程休息几秒进行测试\n                Thread.sleep(10000);\n                System.out.print(\"睡够啦~\");\n            }catch(Exception e) {\n                throw new RuntimeException(\"报错啦！！\");\n            }\n        }\n    });\n} \n```\n\n将业务逻辑封装到 Runnable 或 Callable 中，交由 线程池 来执行。\n\n \n\n## 二、Future异步\n\n上述方式虽然达到了多线程并行处理，但有些业务不仅仅要执行过程，还要获取执行结果，后续提供在JUC包增加了Future。\n\n从字面意思理解就是未来的意思，但使用起来却着实有点鸡肋，并不能实现真正意义上的异步，获取结果时需要阻塞线程，或者不断轮询。\n\n\n\n```java\n@Test\npublic void futureTest() throws Exception {\n\n    System.out.println(\"main函数开始执行\");\n\n    ExecutorService executor = Executors.newFixedThreadPool(1);\n    Future<Integer> future = executor.submit(new Callable<Integer>() {\n        @Override\n        public Integer call() throws Exception {\n\n            System.out.println(\"===task start===\");\n            Thread.sleep(5000);\n            System.out.println(\"===task finish===\");\n            return 3;\n        }\n    });\n    //这里需要返回值时会阻塞主线程，如果不需要返回值使用是OK的。倒也还能接收\n    //Integer result=future.get();\n    System.out.println(\"main函数执行结束\");\n\n    System.in.read();\n\n}\n```\n\n\n\n## 三、CompletableFuture异步\n\nFuture 类通过 get() 方法阻塞等待获取异步执行的运行结果，性能比较差。\n\nJDK1.8 中，Java 提供了 CompletableFuture 类，它是基于异步函数式编程。相对阻塞式等待返回结果，CompletableFuture 可以通过回调的方式来处理计算结果，实现了异步非阻塞，性能更优。\n\nCompletableFuture 实现了 Future 和 CompletionStage 接口， 并提供了多种实现异步编程的方法，如supplyAsync, runAsync以及thenApplyAsync。\n\n下面我们使用CompletableFuture来实现上面的例子：\n\n```java\nCompletableFuture<Long> completableFuture = CompletableFuture.supplyAsync(() -> factorial(number));\nwhile (!completableFuture.isDone()) {\n    System.out.println(\"CompletableFuture is not finished yet...\");\n}\nlong result = completableFuture.get();\n```\n\n \n\n我们不需要显式使用 ExecutorService，CompletableFuture 内部使用了 ForkJoinPool 来处理异步任务，这使得我们的代码变的更简洁。\n\n \n\n## 四、SpringBoot @Async异步\n\n在@Async注解之前，使用多线程需要使用JDK的原生方法，非常麻烦，当有了@Async之后就比较简单了。\n\n首先，使用 @EnableAsync 启用异步注解:\n\n\n\n```java\n@SpringBootApplication\n@EnableAsync\npublic class StartApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(StartApplication.class, args);\n    }\n}\n```\n\n自定义线程池：\n\n```java\n@Configuration\n@Slf4j\npublic class ThreadPoolConfiguration {\n\n    @Bean(name = \"defaultThreadPoolExecutor\", destroyMethod = \"shutdown\")\n    public ThreadPoolExecutor systemCheckPoolExecutorService() {\n\n        return new ThreadPoolExecutor(3, 10, 60, TimeUnit.SECONDS,\n                new LinkedBlockingQueue<Runnable>(10000),\n                new ThreadFactoryBuilder().setNameFormat(\"default-executor-%d\").build(),\n                (r, executor) -> log.error(\"system pool is full! \"));\n    }\n}\n```\n\n在异步处理的方法上添加注解 `@Async` ，当对 `execute 方法` 调用时，通过自定义的线程池 `defaultThreadPoolExecutor` 异步化执行  `execute 方法`\n\n```java\n@Service\npublic class AsyncServiceImpl implements AsyncService {\n\n    @Async(\"defaultThreadPoolExecutor\")\n    public Boolean execute(Integer num) {\n        System.out.println(\"线程：\" + Thread.currentThread().getName() + \" , 任务：\" + num);\n        return true;\n    }\n\n}\n```\n\n\n\n用 @Async 注解标记的方法，称为异步方法。在spring boot应用中使用 @Async 很简单：\n\n- 调用异步方法类上或者启动类加上注解 @EnableAsync\n- 在需要被异步调用的方法外加上 @Async\n- 所使用的 @Async 注解方法的类对象应该是Spring容器管理的bean对象；",
      "dateFormat": "2024-11-11 22:43:16",
      "changeTime": "2024-11-11 22:48:34",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "java",
          "link": "#"
        }
      ],
      "stats": {
        "words": 353,
        "text": "2分钟"
      }
    },
    {
      "link": "技术笔记/java/Synchronized同步锁的作用范围.md",
      "title": "Synchronized同步锁的作用范围",
      "abstract": " 我们对一个方法 **增加Synchronized关键字后，当多个线程访问该方法时，整个执行过程会变成串行执行**，这种执行方式很明显会影响程序的性能，那么如何做好安全性及性能的平衡呢？\n  实际上，Synchronized关键字只需保护可能存在线程安全问题的代码，因此，我们可以通过控制同步锁的作用范围来实现这个平衡机制。在Synchronized中，提供两种锁，一是类锁，二是对象锁。\n\n# 类锁\n\n  类锁是全局锁，当多个线程调用不同对象实例的同步方法时会产生互斥，具体实现方式如下。\n\n## 修饰静态方法\n\n```java\n    public static synchronized void m1(){\n        //省略业务代码\n    }\n\n```\n\n## 修饰代码块\n\nsynchronized 中的锁对象是类，也就是Lock.class\n\n```java\npublic class Lock {\n    public void m2(){\n        synchronized (Lock.class){\n            //省略业务代码\n        }\n    }\n}\n\n```\n\n## 实战演练\n\n下面这段程序使用类锁来实现跨对象实例，从而实现互斥的功能。\n\n```java\npublic class SynchronizedForClassExample {\n\n    public void m1() {\n        synchronized(SynchronizedForClassExample.class) {\n            while (true) {\n                System.out.println(\"当前访问的线程：\" + Thread.currentThread().getName());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    public static void main(String[] args) {\n        SynchronizedForClassExample se1=new SynchronizedForClassExample();\n        SynchronizedForClassExample se2=new SynchronizedForClassExample();\n        new Thread(()->se1.m1(),\"t1\").start();\n        new Thread(()->se2.m1(),\"t2\").start();\n    }\n}\n\n```\n\n- 该程序定义了一个m1()方法，该方法中实现了一个循环打印当前线程名称的逻辑，并且这段逻辑是用类锁来保护的。\n- 在main()方法中定义了两个SynchronizedForClassExample对象实例se1和se2，又分别定义了两个线程来调用这两个实例的m1()方法。\n\n根据类锁的作用范围可以指导，即便是多个对象实例，也能够达到互斥的目的，因此最终输出的结果是：那个线程抢到了锁，哪个线程就持续打印自己的线程名字。\n![在这里插入图片描述](assets/Synchronized同步锁的作用范围/dd0fb04591dd4ec2ad4778b3838dad05.png)\n\n# 对象锁\n\n对象锁是实例锁，当多个线程调用同一个对象实例的同步方法时会产生互斥，具体实现方式如下。\n\n## 修饰普通方法\n\n```java\n    public synchronized void m1(){\n        //省略业务代码\n    }\n\n```\n\n## 修饰代码块\n\nsynchronized 的锁对象是普通对象实例\n\n```java\npublic class Lock {\n    Object lock = new Lock();\n    public void m2(){\n        synchronized (lock){\n            //省略业务代码\n        }\n    }\n}\n\n```\n\n## 实战演练\n\n下面这段程序演示了对象锁的使用方法，代码如下。\n\n```java\npublic class SynchronizedForObjectExample {\n    static Object lock=new Object();\n    public void m1(){\n        synchronized (lock){\n            while(true){\n                System.out.println(\"当前获得锁的线程：\"+Thread.currentThread().getName());\n                try {\n                    Thread.sleep(1000);\n                } catch (InterruptedException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        SynchronizedForObjectExample se1=new SynchronizedForObjectExample();\n        SynchronizedForObjectExample se2=new SynchronizedForObjectExample();\n        new Thread(()->se1.m1(),\"t1\").start();\n        new Thread(()->se2.m1(),\"t2\").start();\n    }\n\n}\n\n```\n\n我们先看一下执行结果：\n![在这里插入图片描述](assets/Synchronized同步锁的作用范围/84a521590a2e40058acf84fa0c3a435c.png)\n\n# 分析\n\n  从以上结果中我们发现，对于几乎相同的代码，在使用对象锁的情况下，当两个线程分别访问两个不同对象实例的m1()方法时，并没有达到两者互斥的目的，看起来好像锁没有生效，实际上并不是锁没有生效，问题的根源在于synchronized (lock)中锁对象lock的作用范围过小。\n  Class是在JVM启动过程中加载的，每个.class文件被装载后会产生一个Class对象，Class对象在JVM进程中是全局唯一的。通过static修饰的成员对象及方法的生命周期都属于类级别，他们会随着类的定义被分配和装载到内存，随着类被卸载而回收。\n  实例对象的生命周期伴随着实例对象的创建而开始，同时伴随着实例对象的回收而结束。\n  因此，类锁和对象锁最大的区别就是锁对象lock的生命周期不同，如果要达到多个线程互斥，那么多个线程必须要竞争同一个锁。\n  在上诉代码中，通过 `Object lock=new Object();`构建的锁对象的生命周期是由`SynchronizedForObjectExample` 对象的实例来决定的，不同的`SynchronizedForObjectExample` 实例会有不同的lock锁对象，由于没有形成竞争，所以不会实现互斥的效果。\n  如果想要让上诉程序达到同步的目的，那么我们可以对lock锁对象增加`static`关键字\n\n```java\nstatic Object lock=new Object();//增加`static`关键字\n```",
      "dateFormat": "2024-11-11 22:43:16",
      "changeTime": "2023-08-05 14:07:26",
      "tags": [
        {
          "name": "技术笔记",
          "link": "#"
        },
        {
          "name": "java",
          "link": "#"
        }
      ],
      "stats": {
        "words": 205,
        "text": "2分钟"
      }
    }
  ]
}